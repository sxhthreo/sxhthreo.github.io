<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
    <meta name="keywords" content="八股文整理, ShiQuLiZhi BLOG">
    <meta name="description" content="世界很暗，但是你来了">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>八股文整理 | ShiQuLiZhi BLOG</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 6.2.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>


    
        <style>
    body{
       background-image: url(https://cdn.jsdelivr.net/gh/Tokisaki-Galaxy/res/site/medias/background.jpg);
       background-repeat:no-repeat;
       background-size:cover;
       background-attachment:fixed;
    }
</style>

            

                <body>

                    <!-- hexo-inject:begin --><!-- hexo-inject:end --><header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">ShiQuLiZhi BLOG</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/goodpapers" class="waves-effect waves-light">
      
      <i class="fas fa-coffee" style="zoom: 0.6;"></i>
      
      <span>收藏</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友链</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">ShiQuLiZhi BLOG</div>
        <div class="logo-desc">
            
            世界很暗，但是你来了
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/goodpapers" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-coffee"></i>
			
			收藏
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友链
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

                        
<script src="/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/21.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">八股文整理</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/Web%E6%8A%80%E6%9C%AF/">
                                    <span class="chip bg-color">
                                        Web技术
                                    </span>
                                </a>
                                
                        </div>
                        
                </div>
                <div class="col s5 right-align">
                    
                        <div class="post-cate">
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                                <a href="/categories/Java%E4%B8%8E%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/" class="post-category">
                                    Java与开发基础
                                </a>
                                
                        </div>
                        
                </div>
            </div>

            <div class="post-info">
                
                    <div class="post-date info-break-policy">
                        <i class="far fa-calendar-minus fa-fw"></i>
                        发布日期:&nbsp;&nbsp;
                            2023-10-27
                    </div>
                    

                        
                            <div class="post-date info-break-policy">
                                <i class="far fa-calendar-check fa-fw"></i>
                                更新日期:&nbsp;&nbsp;
                                    2023-11-15
                            </div>
                            

                                
                                    <div class="info-break-policy">
                                        <i class="far fa-file-word fa-fw"></i>
                                        文章字数:&nbsp;&nbsp;
                                            33.3k
                                    </div>
                                    

                                        
                                            <div class="info-break-policy">
                                                <i class="far fa-clock fa-fw"></i>
                                                阅读时长:&nbsp;&nbsp;
                                                    116
                                                        分
                                            </div>
                                            

                                                
            </div>
        </div>
        <hr class="clearfix">

        
            <!-- 是否加载使用自带的 prismjs. -->
            <link rel="stylesheet" href="/libs/prism/prism.css">
            

                
                    <!-- 代码块折行 -->
                    <style type="text/css">
                        code[class*="language-"],
                        pre[class*="language-"] {
                            white-space: pre-wrap !important;
                        }
                    </style>
                    

                        <div class="card-content article-card-content">
                            <div id="articleContent">
                                <h1 id="集合类"><a href="#集合类" class="headerlink" title="集合类"></a>集合类</h1><h2 id="集合类的归类"><a href="#集合类的归类" class="headerlink" title="集合类的归类"></a>集合类的归类</h2><p>Java 集合， 也叫作容器，主要是由两大接口派生而来：一个是 <code>Collection</code>接口，主要用于存放单一元素；另一个是 <code>Map</code> 接口，主要用于存放键值对。对于<code>Collection</code> 接口，下面又有三个主要的子接口：<code>List</code>、<code>Set</code> 和 <code>Queue</code>。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/collection/java-collection-hierarchy.png" alt="Java 集合框架概览"></p>
<p><a target="_blank" rel="noopener" href="https://javaguide.cn/java/collection/java-collection-questions-01.html#%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93">https://javaguide.cn/java/collection/java-collection-questions-01.html#%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93</a></p>
<blockquote>
<p>使用集合的优势：</p>
<p>当我们需要存储一组类型相同的数据时，数组是最常用且最基本的容器之一。但是，使用数组存储对象存在一些不足之处，因为在实际开发中，存储的数据类型多种多样且数量不确定。这时，Java 集合就派上用场了。与数组相比，Java 集合提供了更灵活、更有效的方法来存储多个数据对象。Java 集合框架中的各种集合类和接口可以存储不同类型和数量的对象，同时还具有多样化的操作方式。相较于数组，Java 集合的优势在于它们的大小可变、支持泛型、具有内建算法等。总的来说，Java 集合提高了数据的存储和处理灵活性，可以更好地适应现代软件开发中多样化的数据需求，并支持高质量的代码编写。</p>
</blockquote>
<h2 id="List-Set-Queue-Map-四者的区别"><a href="#List-Set-Queue-Map-四者的区别" class="headerlink" title="List, Set, Queue, Map 四者的区别"></a>List, Set, Queue, Map 四者的区别</h2><ul>
<li><code>List</code>(对付顺序的好帮手): 存储的元素是有序的、可重复的。</li>
<li><code>Set</code>(注重独一无二的性质): 存储的元素不可重复的。</li>
<li><p><code>Queue</code>(实现排队功能的叫号机): 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</p>
</li>
<li><p><code>Map</code>(用 key 来搜索的专家): 使用键值对（key-value）存储，类似于数学上的函数 y=f(x)，”x” 代表 key，”y” 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://javaguide.cn/java/collection/java-collection-questions-01.html#%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93">https://javaguide.cn/java/collection/java-collection-questions-01.html#%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93</a></p>
<h2 id="HashMap的机制分析"><a href="#HashMap的机制分析" class="headerlink" title="HashMap的机制分析"></a>HashMap的机制分析</h2><p>HashMap是Java中常用的集合类之一，它基于哈希表实现。下面是HashMap的机制解释：</p>
<ol>
<li>哈希表：HashMap内部使用一个数组来存储数据，这个数组被称为哈希表或散列表。数组的每个元素称为桶(bucket)，每个桶可以存储一个或多个键值对。</li>
<li>哈希函数：当我们向HashMap中插入一个键值对时，首先会根据键的哈希码（通过hashCode()方法获取）计算出一个哈希值。哈希函数将哈希值映射到数组的索引位置上。</li>
<li>处理哈希冲突：由于不同的键可能产生相同的哈希值，这就是哈希冲突。HashMap使用链表或红黑树来解决哈希冲突。如果多个键的哈希值相同，它们会被放置在同一个桶中，以链表的形式连接起来。但当链表长度过长时，链表会转化为红黑树，以提高查找效率。</li>
<li>存储键值对：每个桶中存储了一个键值对的链表或红黑树。键值对以Entry对象的形式存在，其中包含键、值和指向下一个Entry的指针。</li>
<li>容量和负载因子：HashMap有两个重要的参数，即容量(capacity)和负载因子(load factor)。容量表示哈希表中桶的数量，默认为16。负载因子表示哈希表在自动扩容之前可以达到多满的程度，默认为0.75。当哈希表中的元素数量超过容量乘以负载因子时，就会触发扩容操作。</li>
<li>扩容：当HashMap中的元素数量超过容量乘以负载因子时，会自动进行扩容。扩容操作会创建一个新的数组，并重新计算每个键值对的哈希值和在新数组中的位置。这个过程比较耗时，但可以减少哈希冲突，提高查找效率。</li>
<li>迭代顺序：HashMap的迭代顺序是不确定的，它不保证键值对的顺序与插入顺序相同。如果需要有序的遍历，可以考虑使用LinkedHashMap。</li>
</ol>
<p>总结起来，HashMap通过哈希表实现高效的键值对存储和查找。它利用哈希函数将键映射到数组的索引位置上，并使用链表或红黑树解决哈希冲突。同时，它支持自动扩容来保持较低的哈希冲突率。</p>
<h2 id="解决哈希冲突的方法"><a href="#解决哈希冲突的方法" class="headerlink" title="解决哈希冲突的方法"></a>解决哈希冲突的方法</h2><p>哈希冲突是指不同的键值对映射到哈希表中相同的桶位置上，这种情况下需要解决冲突。以下是常见的解决哈希冲突的方法：</p>
<ol>
<li>链地址法(Chaining)：将哈希表中每个桶看作一个链表，当哈希冲突发生时，将新的键值对插入到对应桶的链表尾部。这种方法简单易实现，适用于插入和删除操作频繁的情况。</li>
<li>开放地址法(Open Addressing)：当哈希冲突发生时，通过一定的探测方式（如线性探测、二次探测、双重哈希等）在哈希表中寻找空桶，并将键值对存储在该桶中。这种方法可以减少链表的使用，但需要考虑探测方式的选择和哈希表的负载因子等因素。</li>
<li>建立公共溢出区(Overflow Area)：当哈希冲突发生时，将键值对存储到公共溢出区中。这种方法可以避免链表过长或探测失败的问题，但需要额外的存储空间，并且查找效率会降低。</li>
<li>再哈希(Rehashing)：当哈希冲突发生时，通过另一个哈希函数重新计算哈希值，直到找到一个空桶为止。这种方法可以避免链表和探测方式的使用，但需要考虑哈希函数的选择和计算成本等因素。</li>
</ol>
<p>需要注意的是，在实际应用中常常需要根据具体情况选择不同的解决哈希冲突的方法。例如，当哈希表中元素数量较少时，链地址法可能比开放地址法更适合；而当哈希表中元素数量较多时，开放地址法可能更加高效。</p>
<h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><ul>
<li><strong>并发</strong>：两个及两个以上的作业在同一 <strong>时间段</strong> 内执行。</li>
<li><strong>并行</strong>：两个及两个以上的作业在同一 <strong>时刻</strong> 执行。</li>
</ul>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="线程池的七个参数"><a href="#线程池的七个参数" class="headerlink" title="线程池的七个参数"></a>线程池的七个参数</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ye17186/article/details/89467919">https://blog.csdn.net/ye17186/article/details/89467919</a></p>
<p><strong><code>ThreadPoolExecutor</code> 3 个最重要的参数：</strong></p>
<ul>
<li><p><strong><code>corePoolSize</code> :</strong> <strong>核心线程数</strong>。线程池维护的最小线程数量，核心线程创建后不会被回收（注意：设置 <code>allowCoreThreadTimeout=true</code> 后，空闲的核心线程超过存活时间也会被回收）。大于核心线程数的线程，在空闲时间超过 <code>keepAliveTime</code> 后会被回收。线程池刚创建时，里面没有一个线程，当调用 <code>execute()</code> 方法添加一个任务时，如果正在运行的线程数量小于 <code>corePoolSize</code>，则马上创建新线程并运行这个任务。</p>
</li>
<li><p><strong><code>maximumPoolSize</code>: </strong> <strong>最大线程数</strong>。线程池允许创建的最大线程数量。当添加一个任务时，核心线程数已满，线程池还没达到最大线程数，并且没有空闲线程，工作队列已满的情况下，创建一个新线程并执行。</p>
</li>
<li><p><strong><code>workQueue</code>:</strong> <strong>工作队列</strong>。新任务被提交后，会先进入到此工作队列中，任务调度时再从队列中取出任务。</p>
<blockquote>
<p>①ArrayBlockingQueue</p>
<p>基于数组的有界阻塞队列，按FIFO排序。新任务进来后，会放到该队列的队尾，有界的数组可以防止资源耗尽问题。当线程池中线程数量达到corePoolSize后，再有新任务进来，则会将任务放入该队列的队尾，等待被调度。如果队列已经是满的，则创建一个新线程，如果线程数量已经达到maxPoolSize，则会执行拒绝策略。</p>
<p>②LinkedBlockingQuene</p>
<p>基于链表的无界阻塞队列（其实最大容量为Interger.MAX），按照FIFO排序。由于该队列的近似无界性，当线程池中线程数量达到corePoolSize后，再有新任务进来，会一直存入该队列，而基本不会去创建新线程直到maxPoolSize（很难达到Interger.MAX这个数），因此使用该工作队列时，参数maxPoolSize其实是不起作用的。</p>
<p>③SynchronousQuene</p>
<p>一个不缓存任务的阻塞队列，生产者放入一个任务必须等到消费者取出这个任务。也就是说新任务进来时，不会缓存，而是直接被调度执行该任务，如果没有可用线程，则创建新线程，如果线程数量达到maxPoolSize，则执行拒绝策略。</p>
<p>④PriorityBlockingQueue</p>
<p>具有优先级的无界阻塞队列，优先级通过参数Comparator实现。</p>
</blockquote>
</li>
</ul>
<p><code>ThreadPoolExecutor</code>其他常见参数 :</p>
<ul>
<li><strong><code>keepAliveTime</code></strong>: <strong>空闲线程存活时间</strong>。线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，多余的空闲线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁，线程池回收线程时，会对核心线程和非核心线程一视同仁，直到线程池中线程的数量等于 <code>corePoolSize</code> ，回收过程才会停止。</li>
<li><strong><code>unit</code></strong> : <code>keepAliveTime</code> 参数的<strong>时间单位</strong>。</li>
<li><strong><code>threadFactory</code></strong> : <strong>线程工厂</strong>。创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon线程等。</li>
<li><strong><code>handler</code></strong> : <strong>拒绝策略</strong>。关于拒绝策略下面单独介绍一下。</li>
</ul>
<h3 id="线程池处理任务的流程"><a href="#线程池处理任务的流程" class="headerlink" title="线程池处理任务的流程"></a>线程池处理任务的流程</h3><p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20231027163201381.png" alt="image-20231027163201381"></p>
<ol>
<li>如果当前运行的线程数小于核心线程数，那么就会新建一个线程来执行任务。</li>
<li>如果当前运行的线程数等于或大于核心线程数，但是小于最大线程数，那么就把该任务放入到任务队列里等待执行。</li>
<li>如果向任务队列投放任务失败（任务队列已经满了），但是当前运行的线程数是小于最大线程数的，就新建一个线程来执行任务。</li>
<li>如果当前运行的线程数已经等同于最大线程数了，新建线程将会使当前运行的线程超出最大线程数，那么当前任务会被拒绝，饱和策略会调用<code>RejectedExecutionHandler.rejectedExecution()</code>方法。</li>
</ol>
<h2 id="线程池的拒绝策略"><a href="#线程池的拒绝策略" class="headerlink" title="线程池的拒绝策略"></a>线程池的拒绝策略</h2><p>线程池的拒绝策略用于处理当线程池已满并且无法接受新的任务时的情况。在这种情况下，拒绝策略决定如何处理新提交的任务。</p>
<p>常见的线程池拒绝策略包括以下几种：</p>
<ol>
<li>AbortPolicy（默认）：这是最常见的拒绝策略，当线程池已满时，会直接抛出RejectedExecutionException异常，阻止任务的执行。</li>
<li>CallerRunsPolicy：当线程池已满时，会将任务返回给调用者来执行。这意味着提交任务的线程会自己执行该任务，而不是交给线程池中的线程执行。这样可以降低任务的提交速度，但也可能导致调用者的线程阻塞。</li>
<li>DiscardPolicy：当线程池已满时，直接丢弃该任务，不做任何处理。这种策略可能会导致任务丢失，潜在地影响系统的正常运行。</li>
<li>DiscardOldestPolicy：当线程池已满时，会丢弃最早提交的任务，然后尝试重新提交新任务。这种策略可以保证任务的执行，但可能会丢失一些已提交但未执行的任务。</li>
</ol>
<p>除了上述常见的拒绝策略外，还可以通过自定义拒绝策略来实现特定的处理逻辑。自定义拒绝策略需要实现RejectedExecutionHandler接口，并重写其rejectedExecution方法，根据具体需求来定义任务被拒绝时的处理方式。</p>
<p>选择合适的拒绝策略要根据具体的业务需求和系统特点来决定。例如，如果任务的及时性很重要，可以选择CallerRunsPolicy策略来保证任务的执行；如果任务的可丢失性较高，可以选择DiscardPolicy策略来尽快释放资源。</p>
<h2 id="常见的线程池"><a href="#常见的线程池" class="headerlink" title="常见的线程池"></a>常见的线程池</h2><p>1 newCachedThreadPool（可缓存的线程池）<br>2 newFixedThreadPool（固定大小的线程池）<br>3 newScheduledThreadPool（可做任务调度的线程池）<br>4 newSingleThreadPool（单个线程的线程池）<br>5 newWorkStealingPool（足够大小的线程池）</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sc179/article/details/115029531">https://blog.csdn.net/sc179/article/details/115029531</a></p>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="synchronized关键字和volatile关键字"><a href="#synchronized关键字和volatile关键字" class="headerlink" title="synchronized关键字和volatile关键字"></a>synchronized关键字和volatile关键字</h3><p>当多个线程同时访问共享资源时，为了保证线程安全和数据一致性，Java提供了synchronized关键字和volatile关键字来实现对共享变量的访问控制和可见性保证。</p>
<ol>
<li>synchronized关键字：<ul>
<li>用法：synchronized关键字可以修饰方法或代码块。</li>
<li>对象锁：当synchronized修饰方法时，它会获取当前对象的锁，即对象锁。其他线程在想要执行该方法时，需要先获得该对象的锁，如果锁被其他线程占用，则需要等待。当方法执行完毕或抛出异常时，会释放对象锁。</li>
<li>类锁：当synchronized修饰静态方法时，它会获取当前类的锁，即类锁。类锁是该类的所有实例对象共享的锁，因此同一时间只有一个线程可以执行被修饰的静态方法。</li>
<li>代码块锁：synchronized还可以修饰代码块，通过指定锁对象来控制多线程对共享资源的访问。当线程进入synchronized代码块时，会尝试获取锁对象的锁，其他线程需要等待锁的释放才能执行。</li>
<li>可重入性：synchronized是可重入的，即同一个线程可以反复进入同步代码块或方法，而不会被自己已经持有的锁所阻塞。</li>
</ul>
</li>
<li>volatile关键字：<ul>
<li>用法：volatile关键字可以修饰变量。</li>
<li>可见性：volatile关键字保证了被修饰的变量对所有线程的可见性。当一个线程修改了volatile变量的值后，会立即将该值刷新到主内存中，并且其他线程读取该变量时也会从主内存中获取最新的值，而不是从线程的工作内存中获取。</li>
<li>禁止指令重排序：volatile关键字还可以禁止指令重排序，保证程序执行的有序性。在编译器和处理器对指令进行优化时，可能会对指令顺序进行重排，但是对于被volatile修饰的变量，其读写操作的顺序是不会被重排序的。</li>
<li>不保证原子性：虽然volatile关键字保证了可见性和有序性，但它并不能保证复合操作的原子性。例如，i++操作不是原子性的，多个线程同时对i进行自增操作时可能会出现竞态条件，此时需要使用synchronized或者AtomicInteger等机制来保证原子性。</li>
</ul>
</li>
</ol>
<h3 id="实现线程安全的方法"><a href="#实现线程安全的方法" class="headerlink" title="实现线程安全的方法"></a>实现线程安全的方法</h3><h4 id="ConcurrentHashMap-线程安全"><a href="#ConcurrentHashMap-线程安全" class="headerlink" title="ConcurrentHashMap 线程安全"></a>ConcurrentHashMap 线程安全</h4><p><a target="_blank" rel="noopener" href="https://javaguide.cn/java/collection/java-collection-questions-02.html#concurrenthashmap-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F-%E5%BA%95%E5%B1%82%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0">https://javaguide.cn/java/collection/java-collection-questions-02.html#concurrenthashmap-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F-%E5%BA%95%E5%B1%82%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0</a></p>
<p>ConcurrentHashMap是Java中提供的线程安全的哈希表实现。它采用了一些机制来保证线程安全性：</p>
<ol>
<li>分段锁（Segment-level Locking）：ConcurrentHashMap将整个哈希表分成多个段（Segment），每个段都拥有一个独立的锁。不同的线程可以同时访问不同的段，从而提供了更高的并发度。每个段内部使用传统的锁机制（如ReentrantLock）来保证线程安全。</li>
<li>volatile关键字：ConcurrentHashMap使用volatile关键字来保证内存可见性。具体来说，当一个线程对某个段进行修改时，会确保其他线程能够立即看到这个修改。</li>
<li>CAS操作（Compare and Swap）：ConcurrentHashMap使用CAS操作来确保对元素的原子性操作。CAS操作是一种乐观锁的实现方式，它通过比较内存中的旧值和期望的值来确定是否更新。如果值没有被其他线程修改，就使用新值进行替换。</li>
</ol>
<blockquote>
<p>HashMap在多线程环境下，如果存在多个线程同时对其中的元素进行读写操作，可能会出现两个以下问题：</p>
<ol>
<li>竞态条件: 多个线程同时读写一个HashMap时，由于它不是线程安全的，可能会导致数据不一致的情况，即读取到的数据可能不是最新的。</li>
<li>死锁: 如果在多线程并发的情况下，多个线程同时对一个HashMap元素进行读写操作时，可能会因锁竞争而发生死锁。</li>
</ol>
<p>为了解决这些问题，Java提供了线程安全的HashMap实现类：ConcurrentHashMap。它使用了一种称为分段锁（Segment）的机制来保证线程安全，将整个容器分为多个段，每个段都拥有自己的锁，不同段之间操作互不影响。这种机制可以提高并发性能，避免锁竞争，从而提高程序的执行效率。</p>
</blockquote>
<h4 id="synchronized-volatile关键字"><a href="#synchronized-volatile关键字" class="headerlink" title="synchronized/volatile关键字"></a>synchronized/volatile关键字</h4><p>同上。当变量被声明为volatile时，它具有可见性和有序性的特性。多个线程对该变量的读写操作都能立即看到最新的值，且不会进行指令重排序。</p>
<h2 id="悲观锁和乐观锁"><a href="#悲观锁和乐观锁" class="headerlink" title="悲观锁和乐观锁"></a>悲观锁和乐观锁</h2><p><a target="_blank" rel="noopener" href="https://javaguide.cn/java/concurrent/java-concurrent-questions-02.html#%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81">https://javaguide.cn/java/concurrent/java-concurrent-questions-02.html#%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81</a></p>
<h2 id="锁机制的实现方式"><a href="#锁机制的实现方式" class="headerlink" title="锁机制的实现方式"></a>锁机制的实现方式</h2><p>LOCK机制是一种用于控制多线程并发访问共享资源的机制，其主要目的是保证在任意时刻只有一个线程可以访问共享资源，从而避免数据竞争和不一致性问题。</p>
<p>在实现LOCK机制时，常见的方式包括：</p>
<ol>
<li>互斥量：互斥量是一种最常用的LOCK机制实现方式。操作系统提供了一组API函数，可以通过调用这些函数来创建、销毁、加锁、解锁等操作。当一个线程请求加锁时，如果该锁已经被其他线程占用，则该线程会被阻塞，直到该锁被释放为止。互斥量的实现通常依赖于操作系统提供的底层机制，如信号量、原子操作等。</li>
<li>自旋锁：自旋锁是一种比较轻量级的LOCK机制实现方式。它不会像互斥量一样将线程阻塞，而是通过循环等待的方式不断尝试获取锁。如果在一定时间内无法获取到锁，则线程会放弃CPU资源，让其他线程运行。自旋锁的实现通常依赖于硬件提供的支持，如CAS（Compare-and-Swap）指令等。</li>
<li>读写锁：读写锁是一种特殊的LOCK机制，用于控制多线程并发访问共享资源时的读写操作。读写锁允许多个线程同时读取共享资源，但只允许一个线程进行写操作。读写锁的实现通常依赖于互斥量和条件变量等基本的LOCK机制。</li>
<li>信号量：信号量是一种比较通用的同步机制，也可以用于实现LOCK机制。它通过计数器来控制多线程对共享资源的访问。当一个线程请求加锁时，如果计数器的值为0，则该线程会被阻塞，直到其他线程释放锁为止。信号量的实现通常依赖于操作系统提供的底层机制，如原子操作等。</li>
</ol>
<h2 id="CAS和synchronized的区别"><a href="#CAS和synchronized的区别" class="headerlink" title="CAS和synchronized的区别"></a>CAS和synchronized的区别</h2><p>CAS（Compare-And-Swap）和synchronized都是Java中用于实现线程同步的机制，但它们有以下几点不同：</p>
<ol>
<li>实现方式：<ul>
<li>synchronized是一种悲观锁，它在进入同步代码块之前会先获取对象的锁，如果获取不到就会进入阻塞状态，直到获取到锁为止。</li>
<li>CAS是一种乐观锁，它不会阻塞线程，而是在执行更新操作时，先比较当前值是否与期望值相等，如果相等则执行更新操作，否则放弃更新并重试。</li>
</ul>
</li>
<li>性能：<ul>
<li>synchronized在多线程竞争激烈的情况下，由于需要频繁地获取和释放锁，会导致线程阻塞和上下文切换，从而影响程序的性能。</li>
<li>CAS在多线程竞争不激烈的情况下，由于不需要阻塞线程，可以避免上下文切换，从而提高程序的性能。</li>
</ul>
</li>
<li>适用场景：<ul>
<li>synchronized适用于对临界区进行保护的情况，即多个线程访问共享资源时需要进行同步操作的情况。</li>
<li>CAS适用于对单个变量进行原子性操作的情况，即多个线程对同一个变量进行读写操作时需要保证原子性的情况。</li>
</ul>
</li>
</ol>
<p>总的来说，synchronized和CAS都是Java中用于实现线程同步的机制，但它们的实现方式、性能和适用场景不同。需要根据具体的应用场景选择合适的机制，以达到最优的性能和稳定性。</p>
<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="JVM的主要功能"><a href="#JVM的主要功能" class="headerlink" title="JVM的主要功能"></a>JVM的主要功能</h2><p>JVM（Java Virtual Machine）是Java虚拟机的缩写，是一种用于执行Java字节码的虚拟机。它是Java语言的核心和基础，能够在不同的操作系统上提供统一的运行环境。</p>
<p>JVM的主要功能包括以下几个方面：</p>
<ol>
<li><p>类加载：JVM负责将编译后的Java字节码加载到内存中，并进行链接、初始化等操作。通过类加载器完成类的加载工作。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://javaguide.cn/java/jvm/classloader.html">https://javaguide.cn/java/jvm/classloader.html</a></p>
<p>JVM 中内置了三个重要的 <code>ClassLoader</code>：</p>
<ol>
<li><strong><code>BootstrapClassLoader</code>(启动类加载器)</strong>：最顶层的加载类，由 C++实现，通常表示为 null，并且没有父级，主要用来加载 JDK 内部的核心类库（ <code>%JAVA_HOME%/lib</code>目录下的 <code>rt.jar</code>、<code>resources.jar</code>、<code>charsets.jar</code>等 jar 包和类）以及被 <code>-Xbootclasspath</code>参数指定的路径下的所有类。</li>
<li><strong><code>ExtensionClassLoader</code>(扩展类加载器)</strong>：主要负责加载 <code>%JRE_HOME%/lib/ext</code> 目录下的 jar 包和类以及被 <code>java.ext.dirs</code> 系统变量所指定的路径下的所有类。</li>
<li><strong><code>AppClassLoader</code>(应用程序类加载器)</strong>：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。</li>
</ol>
</blockquote>
</li>
<li><p>内存管理：JVM为Java程序提供了自动的内存管理机制，包括堆、栈和方法区等。其中，堆用于存储对象实例，栈用于存储方法调用和局部变量等，方法区用于存储类的信息、常量池等。</p>
</li>
<li><p>垃圾回收：JVM具备垃圾回收功能，能够自动回收不再使用的对象内存空间，以便于程序员专注于业务逻辑而无需关心内存管理。</p>
</li>
<li><p>即时编译：JVM包含即时编译器（Just-In-Time Compiler），能够将热点代码（Hot Spot）转换为本地机器码，从而提高程序的执行效率。</p>
</li>
<li><p>安全机制：JVM通过安全管理器（Security Manager）实现对Java程序的安全控制，包括访问文件、网络等敏感资源的权限控制。</p>
</li>
<li><p>多线程支持：JVM支持多线程并发执行，通过线程调度器（Thread Scheduler）实现对线程的管理和调度，提供了线程同步、锁机制等。</p>
</li>
<li><p>异常处理：JVM提供了异常处理机制，能够捕获、处理和抛出异常，保证程序的健壮性和可靠性。</p>
</li>
</ol>
<p>总而言之，JVM作为Java语言的运行时环境，实现了跨平台的特性，使得Java程序可以在不同的操作系统上运行。它提供了内存管理、垃圾回收、安全机制、多线程支持等功能，为Java程序的执行提供了良好的基础。同时，JVM还可以根据实际情况进行优化，提高程序的执行效率。</p>
<h2 id="Java类如何加载"><a href="#Java类如何加载" class="headerlink" title="Java类如何加载"></a>Java类如何加载</h2><p>在Java中，类的加载是Java虚拟机（JVM）将类的字节码文件加载到内存中，并创建相应的Class对象的过程。类的加载是Java程序执行的一个重要阶段，它涉及到以下几个步骤：</p>
<ol>
<li>加载（Loading）：将类的字节码文件从磁盘或网络读取到内存中。加载过程由ClassLoader类来完成。ClassLoader负责在运行时查找和加载类的字节码文件。</li>
<li>验证（Verification）：验证加载的类的字节码文件的正确性和安全性。这个过程会进行一些静态的检查，例如检查字节码文件是否符合Java语言规范，是否包含不安全的操作等。</li>
<li>准备（Preparation）：为类的静态变量分配内存，并设置默认初始值。在这个阶段，JVM会为类中的静态变量分配内存空间，并初始化默认值，例如整型为0，引用类型为null。</li>
<li>解析（Resolution）：将常量池中的符号引用转换为直接引用。在Java中，类的方法和字段可以通过符号引用来引用其他类、方法或字段。在解析阶段，JVM将这些符号引用转换为对应的直接引用，以便后续的访问和调用。</li>
<li>初始化（Initialization）：执行类的初始化代码，包括静态变量赋值和静态代码块的执行。在这个阶段，JVM会按照程序中定义的顺序执行类的静态变量赋值和静态代码块。</li>
</ol>
<p>需要注意的是，类的加载过程是按需加载的，即在首次使用该类时才会进行加载。此外，JVM还提供了类的卸载（Unloading）机制，当一个类不再被引用且没有任何活跃的实例时，JVM可以卸载该类。</p>
<p>总结起来，Java类的加载是通过ClassLoader将类的字节码文件加载到内存中，并经过验证、准备、解析和初始化等阶段，最终创建相应的Class对象。加载过程是按需进行的，并且支持类的卸载机制。</p>
<h2 id="JVM配置参数"><a href="#JVM配置参数" class="headerlink" title="JVM配置参数"></a>JVM配置参数</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_40927436/article/details/109148648">https://blog.csdn.net/weixin_40927436/article/details/109148648</a></p>
<p><a target="_blank" rel="noopener" href="https://javaguide.cn/java/jvm/jvm-parameters-intro.html#_2-%E5%A0%86%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3">https://javaguide.cn/java/jvm/jvm-parameters-intro.html#_2-%E5%A0%86%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3</a></p>
<h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6919350421685288973">https://juejin.cn/post/6919350421685288973</a></p>
<p>Java内存模型（Java Memory Model，JMM）定义了Java程序中多线程访问共享变量时的行为规范。它规定了线程之间如何进行通信、如何同步以及如何对内存进行访问等方面的问题。Java内存模型包括以下几个方面：</p>
<ol>
<li>内存结构：Java内存模型将内存分为主内存和工作内存两部分。主内存是所有线程共享的内存区域，而每个线程都有自己的工作内存，用于存储该线程需要访问的变量和对象。</li>
<li>变量的读写：线程在读取共享变量时，必须先将变量从主内存复制到工作内存中，然后再进行读取操作。在修改共享变量时，线程也必须先将变量从主内存复制到工作内存中，然后进行修改操作，最后再将修改后的值写回主内存。</li>
<li>原子性操作：Java内存模型保证了基本数据类型的读取和赋值操作具有原子性，即一个线程执行这些操作时，其他线程无法干扰。但是对于复合操作（如i++）则不能保证原子性，需要使用synchronized或者Lock等机制来保证原子性。</li>
<li>可见性：Java内存模型保证了一个线程修改的变量对其他线程是可见的。具体来说，当一个线程修改了共享变量的值后，必须将该值刷新到主内存中，其他线程才能看到这个修改。</li>
<li>有序性：Java内存模型保证了程序执行的有序性。具体来说，在不同线程之间的操作可能会发生重排序，但是Java内存模型会保证重排序后的结果与程序原本的执行顺序相同。</li>
</ol>
<h2 id="JVM回收器"><a href="#JVM回收器" class="headerlink" title="JVM回收器"></a>JVM回收器</h2><p>JVM（Java虚拟机）是一种可以在不同平台上运行Java程序的软件平台。JVM中的垃圾回收器是负责回收Java对象的组件，它可以自动地管理内存，避免了手动管理内存的复杂性和错误。常见的JVM回收器有以下几种：</p>
<ol>
<li>Serial收集器：<ul>
<li>Serial收集器是一种单线程的垃圾回收器，它会暂停应用程序的所有线程，进行垃圾回收操作。</li>
<li>Serial收集器适用于小型应用程序或者开发、测试环境，因为它的回收效率较低，但占用的系统资源较少。</li>
</ul>
</li>
<li>Parallel收集器：<ul>
<li>Parallel收集器是一种多线程的垃圾回收器，它可以利用多核CPU的优势，提高回收效率。</li>
<li>Parallel收集器适用于大型应用程序或者生产环境，因为它的回收效率较高，但占用的系统资源也相对较多。</li>
</ul>
</li>
<li>CMS收集器：<ul>
<li>CMS（Concurrent Mark Sweep）收集器是一种基于标记-清除算法的垃圾回收器，它可以在应用程序运行的同时进行垃圾回收操作，减少了应用程序的停顿时间。</li>
<li>CMS收集器适用于响应时间要求较高的应用程序，因为它可以在减少应用程序停顿的同时，保证较高的回收效率。</li>
</ul>
</li>
<li>G1收集器：<ul>
<li>G1（Garbage-First）收集器是一种基于分代和区域化的垃圾回收器，它可以根据应用程序的需求动态地调整内存分配和垃圾回收策略，从而实现更高效的内存管理。</li>
<li>G1收集器适用于大型、高并发的应用程序，因为它可以在不影响应用程序性能的情况下，保证较高的回收效率和内存利用率。</li>
</ul>
</li>
</ol>
<h2 id="JVM垃圾收集算法"><a href="#JVM垃圾收集算法" class="headerlink" title="JVM垃圾收集算法"></a>JVM垃圾收集算法</h2><p><strong>标记-清除算法、复制算法、标记-整理算法、分代收集算法</strong></p>
<p><a target="_blank" rel="noopener" href="https://javaguide.cn/java/jvm/jvm-garbage-collection.html#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95">https://javaguide.cn/java/jvm/jvm-garbage-collection.html#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95</a></p>
<h2 id="JVM异常的分类"><a href="#JVM异常的分类" class="headerlink" title="JVM异常的分类"></a>JVM异常的分类</h2><p>JVM（Java虚拟机）在执行Java程序时可能会抛出多种异常，常见的JVM异常包括：</p>
<ol>
<li>OutOfMemoryError（内存溢出错误）：<ul>
<li>Java堆内存溢出：当创建对象时，无法为其分配足够的堆内存空间。</li>
<li>方法区（永久代）溢出：当加载类信息或者常量池中的数据过多，超出了方法区的限制。</li>
</ul>
</li>
<li>StackOverflowError（栈溢出错误）：<ul>
<li>当线程调用的方法调用层次过深，导致栈空间耗尽。</li>
</ul>
</li>
<li>NullPointerException（空指针异常）：<ul>
<li>当代码中使用了一个空对象的引用，并试图访问该对象的属性或方法时，抛出空指针异常。</li>
</ul>
</li>
<li>ArrayIndexOutOfBoundsException（数组越界异常）：<ul>
<li>当试图访问数组中不存在的索引位置时，抛出数组越界异常。</li>
</ul>
</li>
<li>ClassCastException（类转换异常）：<ul>
<li>当试图将一个对象强制转换为其子类或者不相关的类时，抛出类转换异常。</li>
</ul>
</li>
<li>IllegalArgumentException（非法参数异常）：<ul>
<li>当传递给方法的参数不满足方法的预期要求时，抛出非法参数异常。</li>
</ul>
</li>
<li>ArithmeticException（算术异常）：<ul>
<li>当进行数学运算时发生错误，例如除以零时，抛出算术异常。</li>
</ul>
</li>
<li>ClassNotFoundException（类未找到异常）：<ul>
<li>当试图加载不存在的类时，抛出类未找到异常。</li>
</ul>
</li>
<li>InterruptedException（线程中断异常）：<ul>
<li>当一个线程处于等待、睡眠或者被阻塞状态时，另一个线程中断了它，抛出线程中断异常。</li>
</ul>
</li>
<li>NoClassDefFoundError（类定义未找到错误）：<ul>
<li>当Java虚拟机无法找到某个类的定义时，抛出类定义未找到错误。</li>
</ul>
</li>
</ol>
<blockquote>
<p>排查JVM异常方法：</p>
<ol>
<li>查看异常信息：<ul>
<li>首先，查看控制台或日志中的异常信息。异常信息通常包含异常类型、异常堆栈轨迹和相关的错误消息，这些信息可以帮助定位问题所在。</li>
</ul>
</li>
<li>分析异常堆栈轨迹：<ul>
<li>异常堆栈轨迹是一系列方法调用的追踪记录，从异常发生的地方开始，一直追溯到异常被抛出的位置。通过分析异常堆栈轨迹，可以确定异常发生的具体位置和可能的原因。</li>
</ul>
</li>
<li>检查代码逻辑：<ul>
<li>审查引发异常的相关代码，检查是否存在潜在的错误或者不合理的逻辑。特别关注可能导致空指针异常、数组越界异常等常见异常的代码段。</li>
</ul>
</li>
<li>检查资源使用：<ul>
<li>检查程序中对于内存、文件、网络连接等资源的使用情况。内存溢出、文件句柄泄露等问题可能导致JVM异常。</li>
</ul>
</li>
<li>使用调试工具：<ul>
<li>使用调试工具（如IDE的调试功能、JVM监控工具等）来跟踪程序的执行过程，观察变量的取值、方法的调用顺序等，以便更好地理解和定位问题。</li>
</ul>
</li>
<li>进行日志输出：<ul>
<li>在关键的代码段或异常处理逻辑中增加日志输出，记录关键变量的值、方法的执行流程等信息，有助于排查问题。</li>
</ul>
</li>
<li>进行单元测试和集成测试：<ul>
<li>编写单元测试和集成测试，覆盖可能引发异常的代码路径，通过测试用例可以模拟异常情况并验证修复后的代码是否正常工作。</li>
</ul>
</li>
</ol>
</blockquote>
<h2 id="介绍一下AQS"><a href="#介绍一下AQS" class="headerlink" title="介绍一下AQS"></a>介绍一下AQS</h2><p>AQS（AbstractQueuedSynchronizer）是Java并发包中的一个抽象类，它提供了一种用于实现同步器（synchronizer）的框架。AQS是许多并发工具的基础，例如ReentrantLock、CountDownLatch、Semaphore等。</p>
<p>AQS 就是一个抽象类，主要用来构建锁和同步器。</p>
<p>AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是基于 <strong>CLH 锁</strong> （Craig, Landin, and Hagersten locks） 实现的。</p>
<p>CLH 锁是对自旋锁的一种改进，是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系），暂时获取不到锁的线程将被加入到该队列中。AQS 将每条请求共享资源的线程封装成一个 CLH 队列锁的一个结点（Node）来实现锁的分配。在 CLH 队列锁中，一个节点表示一个线程，它保存着线程的引用（thread）、 当前节点在队列中的状态（waitStatus）、前驱节点（prev）、后继节点（next）。</p>
<p><a target="_blank" rel="noopener" href="https://javaguide.cn/java/concurrent/aqs.html#aqs-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3">https://javaguide.cn/java/concurrent/aqs.html#aqs-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3</a></p>
<p>AQS的主要特点包括：</p>
<ol>
<li>状态管理：<ul>
<li>AQS使用一个整型变量来表示同步状态，可以表示资源的可用性或者其他自定义的状态。子类可以通过修改该状态来实现对资源的控制。</li>
</ul>
</li>
<li>队列管理：<ul>
<li>AQS内部维护一个双向队列，用于存储等待获取同步状态的线程。线程会按照先进先出的顺序排队，并在同步状态可用时被唤醒。</li>
</ul>
</li>
<li>等待与唤醒：<ul>
<li>当线程尝试获取同步状态时，如果同步状态不可用，线程将被加入到等待队列中并进入等待状态。当同步状态可用时，AQS会从等待队列中选择一个线程唤醒。</li>
</ul>
</li>
<li>共享与独占：<ul>
<li>AQS支持两种同步模式：独占模式和共享模式。独占模式下，只有一个线程可以获取同步状态；共享模式下，多个线程可以同时获取同步状态。</li>
</ul>
</li>
<li>条件变量支持：<ul>
<li>AQS提供了条件变量（Condition）的支持，可以通过条件变量在某个条件满足时唤醒等待线程。</li>
</ul>
</li>
</ol>
<p>AQS 定义两种资源共享方式：<code>Exclusive</code>（独占，只有一个线程能执行，如<code>ReentrantLock</code>）和<code>Share</code>（共享，多个线程可同时执行，如<code>Semaphore</code>/<code>CountDownLatch</code>）。</p>
<p>一般来说，自定义同步器的共享方式要么是独占，要么是共享，他们也只需实现<code>tryAcquire-tryRelease</code>、<code>tryAcquireShared-tryReleaseShared</code>中的一种即可。但 AQS 也支持自定义同步器同时实现独占和共享两种方式，如<code>ReentrantReadWriteLock</code>。</p>
<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="事务的特性及其隔离级别"><a href="#事务的特性及其隔离级别" class="headerlink" title="事务的特性及其隔离级别"></a>事务的特性及其隔离级别</h2><p>事务（Transaction）是指作为一个逻辑工作单元执行的一系列操作，这些操作要么全部成功执行，要么全部失败回滚。事务具有四个重要的特性，通常被称为 <strong>ACID 特性</strong>：</p>
<ol>
<li>原子性（Atomicity）：原子性要求事务中的所有操作要么全部执行成功，要么全部回滚失败，不允许出现部分成功部分失败的情况。即事务是一个不可分割的操作单位，要么全部执行，要么全部撤销。</li>
<li>一致性（Consistency）：一致性要求事务的执行不会破坏数据库的完整性约束和业务规则。在事务开始前和结束后，数据库必须处于一致性状态。</li>
<li>隔离性（Isolation）：隔离性要求并发执行的多个事务之间相互隔离，每个事务的执行都应当与其他事务的执行互不影响。事务的隔离性可以防止数据不一致和并发一致性问题。</li>
<li>持久性（Durability）：持久性要求一旦事务提交成功，对数据库的修改就是永久性的，即使系统发生故障或重启，数据库也能够保持事务的结果。持久性通过将事务的操作结果写入非易失性存储介质（如硬盘）来实现。</li>
</ol>
<p>这四个特性确保了事务的可靠性和数据的完整性，使得数据库系统能够处理并发操作、故障恢复等复杂场景。在使用数据库时，开发者需要了解事务的特性，并根据具体的业务需求合理地运用事务，以确保数据的一致性和可靠性。</p>
<p>SQL 标准定义了四个<strong>隔离级别</strong>：</p>
<ul>
<li><strong>READ-UNCOMMITTED(读取未提交)</strong> ：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li>
<li><strong>READ-COMMITTED(读取已提交)</strong> ：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li>
<li><strong>REPEATABLE-READ(可重复读)</strong> ：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li>
<li><strong>SERIALIZABLE(可串行化)</strong> ：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</li>
</ul>
<h2 id="MySQL查询流程"><a href="#MySQL查询流程" class="headerlink" title="MySQL查询流程"></a>MySQL查询流程</h2><p>MySQL的查询流程可以大致分为以下几个步骤：</p>
<ol>
<li>语法解析和预处理：当用户输入一条SQL语句后，MySQL会对其进行语法解析和预处理。这个过程会检查SQL语句的语法是否正确，并将SQL语句转化为内部数据结构。</li>
<li>查询缓存：如果查询缓存命中，则直接返回结果。否则，继续执行下一步。</li>
<li>优化器生成执行计划：MySQL会根据查询语句的特点和表的统计信息，生成多个可能的执行计划，并通过代价估算器来评估每个执行计划的代价，最终选择代价最小的执行计划。</li>
<li>执行器执行查询：执行器根据执行计划来执行查询。具体地，它会打开表并读取数据，然后进行过滤、排序、分组等操作，最终返回结果集。</li>
<li>返回结果集：执行器将结果集返回给客户端。如果结果集太大，会使用游标进行分批返回。</li>
</ol>
<h2 id="MySQL查询优化"><a href="#MySQL查询优化" class="headerlink" title="MySQL查询优化"></a>MySQL查询优化</h2><p>MySQL进行查询优化的过程主要包括以下几个方面：</p>
<ol>
<li>查询重写：MySQL会对用户输入的SQL语句进行重写，将其转换为等价的形式，以便更好地利用索引和其他优化技术。例如，将子查询转换为连接操作、使用覆盖索引等。</li>
<li>索引选择：MySQL会根据查询条件和表的统计信息来选择最适合的索引。优化器会评估不同索引的代价，并选择代价最小的索引。同时，MySQL还支持多列索引和联合索引，可以更好地满足复杂查询的需求。</li>
<li>表连接优化：当查询涉及到多个表的连接时，MySQL会根据连接类型（如内连接、外连接）和连接条件来选择合适的连接算法。常见的连接算法包括嵌套循环连接、排序-合并连接、哈希连接等。</li>
<li>子查询优化：MySQL会对子查询进行优化，尽量将其转换为更高效的形式。例如，使用关联子查询替代标量子查询、使用连接操作替代IN子查询等。</li>
<li>查询缓存：MySQL提供了查询缓存机制，可以将查询结果缓存起来，下次相同的查询可以直接从缓存中获取结果，避免了重复执行查询的开销。但需要注意的是，查询缓存只适用于静态数据，对于频繁更新的表，缓存效果可能不佳。</li>
<li>统计信息收集：MySQL会定期收集表的统计信息，包括行数、索引分布等。这些统计信息对于优化器选择执行计划非常重要，可以帮助优化器更准确地估算执行代价。</li>
</ol>
<h2 id="MySQL慢查询优化方式"><a href="#MySQL慢查询优化方式" class="headerlink" title="MySQL慢查询优化方式"></a>MySQL慢查询优化方式</h2><p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1545163">https://cloud.tencent.com/developer/article/1545163</a></p>
<p>（1）<strong>索引没起作用的情况</strong></p>
<ol>
<li>使用LIKE关键字的查询语句</li>
</ol>
<p>在使用LIKE关键字进行查询的查询语句中，如果匹配字符串的第一个字符为“%”，索引不会起作用。只有“%”不在第一个位置索引才会起作用。</p>
<ol>
<li><p>使用多列索引的查询语句</p>
<p>MySQL可以为多个字段创建索引。一个索引最多可以包括16个字段。对于多列索引，只有查询条件使用了这些字段中的第一个字段时，索引才会被使用。</p>
</li>
</ol>
<p>（2）<strong>优化数据库结构</strong></p>
<p>合理的数据库结构不仅可以使数据库占用更小的磁盘空间，而且能够使查询速度更快。数据库结构的设计，需要考虑数据冗余、查询和更新的速度、字段的数据类型是否合理等多方面的内容。</p>
<ol>
<li>将字段很多的表分解成多个表 </li>
</ol>
<p>对于字段比较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表。因为当一个表的数据量很大时，会由于使用频率低的字段的存在而变慢。</p>
<ol>
<li>增加中间表</li>
</ol>
<p>对于需要经常联合查询的表，可以建立中间表以提高查询效率。通过建立中间表，把需要经常联合查询的数据插入到中间表中，然后将原来的联合查询改为对中间表的查询，以此来提高查询效率。</p>
<p>（3）<strong>分解关联查询</strong></p>
<p>将一个大的查询分解为多个小查询是很有必要的。</p>
<h2 id="数据库索引"><a href="#数据库索引" class="headerlink" title="数据库索引"></a>数据库索引</h2><h3 id="MySQL的索引数据结构"><a href="#MySQL的索引数据结构" class="headerlink" title="MySQL的索引数据结构"></a>MySQL的索引数据结构</h3><p>索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息。</p>
<p><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/831250">https://developer.aliyun.com/article/831250</a></p>
<p>MySQL的索引数据结构最常使用的是B树中的B+Tree，但对于主要的两种存储引擎的实现方式是不同的。</p>
<blockquote>
<p>==<strong>InnoDB中data阈存储的是行数据，而MyISAM中存储的是磁盘地址。</strong>==</p>
</blockquote>
<ul>
<li><p><strong>MyISAM</strong>：</p>
<blockquote>
<p>B+Tree叶节点的data域存放的是数据记录的地址。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则根据data域中磁盘地址到磁盘中寻址定位到对应的磁盘块，然后读取相应的数据记录，这被称为“非聚簇索引”。</p>
</blockquote>
</li>
<li><p><strong>InnoDB</strong>：</p>
<blockquote>
<p>==其数据文件本身就是索引文件==。相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按照B+Tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录。这个索引的Key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为“<strong>聚簇索引（聚集索引）</strong>”。而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。</p>
</blockquote>
<ul>
<li>在根据主索引搜索时，直接找到Key所在的节点即可取出数据；</li>
<li>在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。</li>
<li>因此在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</li>
</ul>
</li>
</ul>
<h3 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+树索引"></a>B+树索引</h3><p>B+树索引是一种常用的索引结构，用于在数据库中加速数据的查找和访问。</p>
<blockquote>
<p><strong>B+树索引的特点是：</strong>基于磁盘的平衡二叉树，但树非常矮，通常为 3~4 层，能存放千万到上亿的排序数据。树矮意味着访问效率高，从千万或上亿数据里查询一条数据，只用 3、4 次 I/O。</p>
<p>又因为现在的固态硬盘每秒能执行至少 10000 次 I/O ，所以查询一条数据，哪怕全部在磁盘上，也只需要 0.003 ~ 0.004 秒。另外，因为 B+ 树矮，在做排序时，也只需要比较 3~4 次就能定位数据需要插入的位置，排序效率非常不错。</p>
</blockquote>
<p>下面是B+树索引的实现步骤：</p>
<ol>
<li>B+树的节点结构：B+树由内节点和叶子节点组成。每个节点包含一个键值和对应的指针（指向下一级节点或数据记录）。内节点用于索引键值，叶子节点存储数据记录。</li>
<li>插入操作：当需要插入一个新的键值时，首先从根节点开始搜索合适的位置。如果当前节点是叶子节点，则直接将键值插入到合适的位置，并保持有序性。如果当前节点是内节点，则根据键值大小继续向下搜索，直到找到合适的叶子节点。如果叶子节点已满，则进行分裂操作，将一部分键值移动到新的节点中。</li>
<li>删除操作：删除操作与插入操作类似，首先找到要删除的键值所在的叶子节点。然后删除该键值，并进行必要的调整操作，以保持B+树的平衡性。如果删除导致某个节点的键值过少，则可以进行合并操作，将其与相邻节点合并。</li>
<li>查找操作：从根节点开始，根据键值大小不断向下搜索，直到找到叶子节点。在叶子节点中进行二分查找，找到对应的数据记录。</li>
<li>范围查询：B+树索引支持范围查询。可以通过在叶子节点中进行范围扫描，找到满足条件的数据记录。</li>
<li>顺序访问：由于B+树的叶子节点是按照键值有序存储的，可以实现高效的顺序访问。例如，可以利用叶子节点之间的指针进行范围扫描，或者利用叶子节点的链表结构进行顺序遍历。</li>
</ol>
<p>需要注意的是，B+树索引还可以包含多级索引，以支持更大规模的数据存储。此外，为了提高B+树索引的性能，可以考虑使用页缓存技术，将热门数据页缓存到内存中，减少磁盘IO的开销。</p>
<h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>InnoDB是MySQL中一种常用的存储引擎，它使用了B+树作为索引结构。下面是InnoDB索引的主要特点和结构：</p>
<ol>
<li>B+树：InnoDB使用B+树作为索引结构，包括主键索引和辅助索引（Secondary Index）。B+树是一种平衡的多路搜索树，具有良好的平衡性和高效的查询、插入和删除操作。</li>
<li>聚簇索引（Clustered Index）：在InnoDB中，主键索引和数据行是紧密耦合的，称为聚簇索引。聚簇索引决定了数据在磁盘上的物理存储顺序，在索引结构中直接存储了数据行。因此，通过主键索引进行查询时，可以直接定位到对应的数据行，提供了很高的查询性能。</li>
<li>辅助索引（Secondary Index）：除了主键索引外，InnoDB还支持创建辅助索引。辅助索引中的每个索引条目包含辅助索引字段以及一个指向对应主键索引的引用。通过辅助索引进行查询时，首先根据辅助索引找到对应的主键值，然后再通过主键索引定位到实际的数据行。</li>
<li>聚簇因子（Clustering Factor）：聚簇因子是衡量聚簇索引效率的一个指标。它表示在磁盘上物理相邻的索引条目在逻辑上也相邻的程度。较低的聚簇因子意味着更高的查询效率，因为可以更少的I/O操作访问到所需的数据。</li>
<li>页和块：InnoDB使用固定大小的页（Page）来组织数据和索引。每个页默认大小为16KB。数据和索引被分成多个连续的页，形成一个页链表。为了减少I/O操作，InnoDB会预读相邻的页，提高磁盘访问效率。</li>
</ol>
<p>总结起来，InnoDB的索引结构采用B+树作为主要的索引机制，通过聚簇索引和辅助索引实现对数据行的访问。聚簇索引决定了数据行的物理存储顺序，提供了高效的主键查询。辅助索引则通过引用主键索引来定位对应的数据行。通过良好的索引结构设计，InnoDB能够提供高效的数据检索和修改性能。</p>
<blockquote>
<p>InnoDB 对比其他数据库引擎的优势：</p>
<ol>
<li>事务支持：InnoDB 支持事务处理，可以使用 ACID（原子性、一致性、隔离性和持久性）特性来确保数据的完整性和可靠性。这使得 InnoDB 适用于需要高度可靠性和数据一致性的应用程序，如金融系统或电子商务平台。</li>
<li>行级锁定：InnoDB 使用行级锁定机制，允许并发读取和写入操作，提供更好的并发性能。与传统的表级锁定相比，行级锁定可以减少锁冲突，提高多用户并发访问数据库的效率。</li>
<li>外键约束：InnoDB 支持外键约束，可以在数据库层面实现关系型数据库的完整性约束。这使得在表之间建立关联关系更加方便，保证了数据的一致性和完整性。</li>
<li>热备份和恢复：InnoDB 支持在线热备份和恢复，可以在数据库运行时进行备份操作，而不会中断正常的数据库访问。这对于需要高可用性和数据保护的应用程序非常重要。</li>
<li>支持大容量数据：InnoDB 能够处理大容量的数据集，支持多TB级别的数据存储，并具有良好的扩展性和性能。</li>
<li>自适应哈希索引：InnoDB 使用自适应哈希索引来提高查询性能。它会根据查询模式动态地创建和更新哈希索引，以加速常用查询的执行。</li>
<li>崩溃恢复和崩溃安全性：InnoDB 具有强大的崩溃恢复机制，可以在数据库崩溃后自动进行恢复操作，保证数据的一致性和可靠性。</li>
</ol>
</blockquote>
<h3 id="InnoDB是如何实现可重复读的"><a href="#InnoDB是如何实现可重复读的" class="headerlink" title="InnoDB是如何实现可重复读的"></a>InnoDB是如何实现可重复读的</h3><p>InnoDB是MySQL数据库中一种常用的存储引擎，它通过使用多版本并发控制（MVCC）机制来实现可重复读。</p>
<p>下面是InnoDB实现可重复读的基本流程：</p>
<ol>
<li>事务开始时，InnoDB会为每个事务分配一个唯一的事务ID（Transaction ID）。</li>
<li>在执行SELECT语句时，InnoDB会根据语句的要求创建一个一致性读视图（Consistent Read View）。这个视图会记录当前事务开始时数据库中各个数据行的版本信息。</li>
<li>当事务执行SELECT语句时，InnoDB会根据一致性读视图来确定可见的数据行。只有那些在事务开始之前已经提交的数据行才是可见的，而在事务开始后插入、更新或删除的数据行对该事务是不可见的。</li>
<li>在事务执行期间，如果其他事务对某个数据行进行了修改，并且这个修改操作已经提交，那么对于当前事务来说，它仍然看到的是事务开始时的数据版本。这是因为InnoDB通过MVCC机制保存了旧版本的数据行，以便支持并发访问和可重复读。</li>
<li>如果当前事务需要修改数据，则InnoDB会为这个事务创建一个新的数据版本，并且将修改操作记录在事务的undo日志中。这样可以保证即使在事务执行过程中其他事务读取同一行数据时，仍然能够看到一致的数据版本。</li>
<li>当事务提交时，InnoDB会将所有修改操作应用到数据库中，并释放相关的资源。</li>
</ol>
<p>通过以上的流程，InnoDB实现了可重复读的功能。它通过使用MVCC机制来提供高并发性和事务隔离性，保证了不同事务之间的数据访问互不干扰，并且在事务执行期间提供一致的数据视图。这使得开发人员可以在并发环境下安全地执行复杂的数据库操作。</p>
<h3 id="聚簇索引和非聚簇索引的区别"><a href="#聚簇索引和非聚簇索引的区别" class="headerlink" title="聚簇索引和非聚簇索引的区别"></a>聚簇索引和非聚簇索引的区别</h3><p>聚簇索引是关系型数据库中的一种索引类型，它将整张表的数据按照索引的顺序存储，并且叶子节点就是数据节点。也就是说，聚簇索引和表的数据存储方式是一致的，因此一个表只能有一个聚簇索引。</p>
<p>聚簇索引的主要特点如下：</p>
<ol>
<li>数据的物理存储和索引的逻辑存储是一致的，因此查询时可以直接根据索引找到需要的数据，这样可以大大提高查询效率。</li>
<li>聚簇索引的叶子节点存储的是数据节点，因此可以减少磁盘I/O操作，提高查询效率。</li>
<li>如果表中的数据经常需要被更新，那么聚簇索引会导致频繁的数据移动和页面分裂，影响性能。</li>
<li>一个表只能有一个聚簇索引，通常建议将聚簇索引设置在主键上，这样可以保证数据的唯一性和快速查询。</li>
<li>聚簇索引可以使用B+树等数据结构来实现，不同的数据库管理系统可能有不同的实现方式。</li>
</ol>
<p>总的来说，聚簇索引是一种非常重要的索引类型，它可以提高查询效率并保证数据的唯一性，但是需要根据具体的业务需求和数据特征来选择合适的索引类型，以达到最优的性能和可靠性。</p>
<p>聚簇索引和非聚簇索引是关系型数据库中常用的两种索引类型，它们的主要区别在于数据的组织方式和索引的实现方式。</p>
<ol>
<li>数据组织方式：<ul>
<li>聚簇索引：聚簇索引将整张表的数据按照索引的顺序存储，因此聚簇索引的叶子节点就是数据节点。也就是说，聚簇索引和表的数据存储方式是一致的，因此一个表只能有一个聚簇索引。</li>
<li>非聚簇索引：非聚簇索引将索引和数据分开存储，索引节点和数据节点是分开的。因此，一个表可以有多个非聚簇索引。</li>
</ul>
</li>
<li>索引实现方式：<ul>
<li>聚簇索引：聚簇索引的叶子节点存储的是数据节点，因此查询时可以直接根据索引找到需要的数据，这样可以大大提高查询效率。</li>
<li>非聚簇索引：非聚簇索引的叶子节点存储的是指向数据节点的指针，因此查询时需要先通过索引找到数据的位置，然后再根据指针找到实际的数据，这样会增加查询的开销，但是可以提高插入和更新的效率。</li>
</ul>
</li>
<li>适用场景：<ul>
<li>聚簇索引：适合经常需要查询某个范围内数据的列，例如日期、时间等连续的值。如果表中的数据经常需要被更新，那么聚簇索引会导致频繁的数据移动和页面分裂，影响性能。</li>
<li>非聚簇索引：适合经常需要查询某个具体值的列，例如主键、外键等。非聚簇索引可以在不影响表的物理存储方式的前提下，为多个列创建索引，提高查询效率。</li>
</ul>
</li>
</ol>
<p>总的来说，聚簇索引和非聚簇索引都有各自的优缺点和适用场景。在实际应用中，需要根据具体的业务需求和数据特征来选择合适的索引类型，以达到最优的性能和可靠性。</p>
<h2 id="MVCC机制实现"><a href="#MVCC机制实现" class="headerlink" title="MVCC机制实现"></a>MVCC机制实现</h2><p>MVCC（Multi-Version Concurrency Control）是一种数据库并发控制机制，用于实现高并发环境下的事务隔离性。在MVCC中，每个事务都可以看到一个一致性的数据库快照，而不会被其他事务的并发操作所干扰。</p>
<p>下面是MVCC机制的基本实现方式：</p>
<ol>
<li>为每个数据行添加额外的隐藏字段：在InnoDB中，每个数据行都会包含两个隐藏字段：创建版本号（Transaction ID）和删除版本号（Rollback Segment ID）。</li>
<li>创建版本链：每当对数据行进行更新时，InnoDB不会直接在原始数据行上进行修改，而是创建一个新的数据版本，并将新版本的指针链接到一个版本链中。这样就形成了数据行的多个版本。</li>
<li>事务开始时的读取操作：当事务开始时，它会被分配一个唯一的事务ID。在执行SELECT语句时，事务会根据自己的事务ID和版本链来确定可见的数据行版本。只有那些在事务开始之前已经提交的数据行版本才是可见的。</li>
<li>事务期间的写入操作：当事务执行INSERT、UPDATE或DELETE操作时，InnoDB会为这个事务创建一个新的数据版本，并将修改操作记录在事务的undo日志中。这样可以保证即使在事务执行过程中其他事务读取同一行数据时，仍然能够看到一致的数据版本。</li>
<li>事务提交时的清理操作：当事务提交时，InnoDB会将所有修改操作应用到数据库中，并更新数据行的版本信息。同时，旧版本的数据行会被标记为已删除，并在后续的清理过程中进行回收。</li>
</ol>
<p>通过使用这种MVCC机制，每个事务都能够看到一个一致性的数据库快照，而不会受到其他并发事务的影响。这样可以提高数据库的并发性能和事务隔离级别，保证了数据的一致性和完整性。</p>
<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="如何保证缓存和数据库之间数据的一致性"><a href="#如何保证缓存和数据库之间数据的一致性" class="headerlink" title="如何保证缓存和数据库之间数据的一致性"></a>如何保证缓存和数据库之间数据的一致性</h2><p>缓存和数据库之间的数据一致性是一个常见的问题，主要有以下几种解决方案：</p>
<ol>
<li>Cache-Aside模式：<ul>
<li>Cache-Aside模式是一种常见的缓存策略，它的基本思想是：先从缓存中读取数据，如果缓存中不存在，则从数据库中读取，并将数据放入缓存中。当更新数据时，先更新数据库，再删除缓存中的数据，下次读取时会从数据库中重新加载数据并放入缓存中。</li>
<li>这种方式可以保证数据的一致性，但需要注意缓存和数据库之间的读写顺序，以避免脏数据的产生。</li>
</ul>
</li>
<li>Write-Through模式：<ul>
<li>Write-Through模式是一种将更新操作直接写入缓存和数据库的策略，即在更新缓存的同时也更新数据库，保证缓存和数据库的数据一致性。</li>
<li>这种方式可以保证数据的实时一致性，但会增加写入操作的延迟和负载，对于高并发的应用程序可能会影响性能。</li>
</ul>
</li>
<li>Read-Write模式：<ul>
<li>Read-Write模式是一种将读操作从缓存中获取，写操作则直接写入数据库的策略，即读操作优先从缓存中获取，如果缓存中不存在，则从数据库中读取，并将数据放入缓存中；写操作直接写入数据库，不更新缓存。</li>
<li>这种方式可以减少写入操作的延迟和负载，但可能会导致缓存中的数据与数据库中的数据不一致。</li>
</ul>
</li>
<li>双写模式：<ul>
<li>双写模式是一种将更新操作同时写入缓存和数据库的策略，即在更新缓存的同时也更新数据库，并保证缓存和数据库的数据一致性。</li>
<li>这种方式可以保证数据的实时一致性，但会增加写入操作的延迟和负载，对于高并发的应用程序可能会影响性能。</li>
</ul>
</li>
</ol>
<p>需要根据具体的应用场景选择合适的缓存策略，以达到最优的性能和数据一致性。同时，需要注意缓存和数据库之间的读写顺序、缓存过期时间等细节问题，以避免脏数据的产生。</p>
<h2 id="Redis常用数据结构"><a href="#Redis常用数据结构" class="headerlink" title="Redis常用数据结构"></a>Redis常用数据结构</h2><p>Redis 中比较常见的数据类型有下面这些：</p>
<ul>
<li><strong>5 种基础数据类型</strong>：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。</li>
<li><strong>3 种特殊数据类型</strong>：HyperLogLog（基数统计）、Bitmap （位图）、Geospatial (地理位置)。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://javaguide.cn/database/redis/redis-questions-01.html#redis-%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B">https://javaguide.cn/database/redis/redis-questions-01.html#redis-%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B</a></p>
<h2 id="Redis跳表"><a href="#Redis跳表" class="headerlink" title="Redis跳表"></a>Redis跳表</h2><p>Redis中的有序集合（Sorted Set）使用跳表（Skip List）作为底层数据结构来实现。</p>
<p>跳表是一种基于链表的数据结构，它通过在每一层链表中增加跨越节点的指针，从而实现快速的查找和插入操作。跳表的结构使得元素的查找、插入和删除操作的时间复杂度都能够达到O(log n)，并且相比于平衡二叉树等其他数据结构，跳表的实现更加简单高效。</p>
<p>在Redis中，有序集合的跳表实现如下：</p>
<ol>
<li>跳表节点结构：每个跳表节点包含一个分值（score）和一个成员（member）。成员是有序集合中的元素，而分值用于对成员进行排序。</li>
<li>跳表索引层：除了最底层的链表外，跳表还包含多个索引层。每个索引层由若干个节点组成，这些节点按照一定的规则连接到下一层的节点。索引层的高度决定了跳表的性能。</li>
<li>顶层索引指针：Redis中的跳表有一个指向最高层的指针，称为顶层索引指针。通过顶层索引指针，可以快速访问到跳表的最高层，从而加速查找操作。</li>
<li>插入操作：当向有序集合中插入一个新的成员时，Redis会根据成员的分值，从最高层开始逐层查找合适的位置。然后，在每一层中插入新的节点，并更新索引层的指针。</li>
<li>查找操作：查找操作通过从顶层索引指针开始，逐层向下遍历跳表，直到找到目标成员或者找到比目标成员大的节点为止。</li>
<li>删除操作：删除操作需要先通过查找找到要删除的节点，然后在每一层中删除相应的节点，并更新索引层的指针。</li>
</ol>
<p>通过使用跳表作为有序集合的底层数据结构，Redis能够高效地支持有序集合的插入、查找和删除操作。跳表具有较低的复杂度和简单的实现方式，使得Redis在处理有序集合时能够保持良好的性能和可扩展性。</p>
<h2 id="实现Redis-分布式锁"><a href="#实现Redis-分布式锁" class="headerlink" title="实现Redis 分布式锁"></a>实现Redis 分布式锁</h2><p>Redis 分布式锁是一种基于 Redis 数据库实现的分布式锁机制，可以用于协调多个分布式节点对共享资源的访问控制。它可以确保在同一时刻只有一个节点能够持有锁，并且能够避免多节点并发访问时的数据竞争和冲突。</p>
<p>在 Redis 中，常用的实现分布式锁的方式有以下两种：</p>
<ol>
<li>基于 SETNX 和 EXPIRE 命令：使用 Redis 的 SETNX 命令尝试设置一个指定的键值对，如果键不存在则设置成功，表示获取到了锁；然后通过设置键的过期时间来避免锁被误锁。在解锁时，使用 DEL 命令删除键即可。</li>
<li>基于 Redlock 算法：Redlock 是 Redis 官方提供的一种分布式锁算法，适用于多个 Redis 节点的环境下。它通过在多个节点上加锁，并使用时钟差来保证同一时刻只有一个节点能够获得锁。在解锁时，需要向所有节点发送解锁请求。</li>
</ol>
<p>使用 Redis 分布式锁需要注意以下几点：</p>
<ul>
<li>锁的粒度：应该根据实际需求确定锁的粒度，避免过大或过小的锁粒度。</li>
<li>锁的超时时间：为了避免锁永久占用，需要设置合适的锁超时时间。</li>
<li>锁的准确性：由于网络延迟等原因，获取锁和释放锁的过程可能不可靠，需要设计合理的机制来确保锁的准确性。</li>
</ul>
<p>需要在使用 Redis 分布式锁时注意并发竞争、死锁、误删锁、锁粒度等问题，并根据具体场景选择合适的实现方式。同时，也可以考虑使用第三方的分布式锁组件，如 Redission、Curator 等，它们提供了更为完善和可靠的分布式锁解决方案。</p>
<h2 id="Redis持久化方式"><a href="#Redis持久化方式" class="headerlink" title="Redis持久化方式"></a>Redis持久化方式</h2><p>Redis 提供了两种持久化方式，分别是 RDB（Redis Database）和 AOF（Append-Only File）。</p>
<ol>
<li>RDB 持久化：RDB 是将 Redis 数据库在某个时间点的快照保存到磁盘上的一种持久化方式。它会将数据以二进制形式保存在一个 <code>.rdb</code> 文件中。RDB 持久化适合在备份数据和进行灾难恢复时使用。你可以通过配置 <code>redis.conf</code> 文件来设置 RDB 的触发机制和保存路径。</li>
<li>AOF 持久化：AOF 是将 Redis 的操作日志以追加的方式写入到一个文件中，该文件记录了系统执行的所有写命令，包括对数据的增删改操作。通过重新执行这些命令，可以还原出当时的数据状态。AOF 持久化适合在保证数据安全性方面使用。你可以通过配置 <code>redis.conf</code> 文件来设置 AOF 的触发机制和保存路径。</li>
</ol>
<p>Redis 还提供了三种 AOF 持久化方式的选项：</p>
<ul>
<li><code>always</code>：每个写操作都立即记录到 AOF 文件中，可以提供最高的数据安全性，但也可能导致性能下降。</li>
<li><code>everysec</code>：每秒钟将写操作记录到 AOF 文件中一次，在性能和数据安全性之间做了一个折中，是默认的 AOF 持久化方式。</li>
<li><code>no</code>：完全依赖操作系统缓存进行写入，不进行 AOF 持久化，可能导致数据丢失的风险。</li>
</ul>
<h2 id="Redis能解决并发的原因"><a href="#Redis能解决并发的原因" class="headerlink" title="Redis能解决并发的原因"></a>Redis能解决并发的原因</h2><p>Redis 能够在一定程度上解决并发问题，主要是因为其单线程的特性和内部的事件驱动模型。具体来说，以下是 Redis 能够解决并发问题的几点原因：</p>
<ol>
<li><strong>单线程模型：</strong> Redis 主要采用单线程模型来处理客户端的请求。这意味着在任何时刻，Redis 服务器只会执行一个命令，因此不会出现多个线程之间的竞争和同步问题。这有助于避免传统多线程编程中可能出现的死锁、竞争条件等并发问题。</li>
<li><strong>原子性操作：</strong> Redis 提供了一些原子性操作，如对字符串的自增（INCR）、对集合的添加或删除操作等。这些操作能够在单个命令中完成，并且是原子性的，不会受到并发操作的干扰。</li>
<li><strong>非阻塞 I/O：</strong> Redis 使用了基于事件驱动的非阻塞 I/O 模型。这意味着 Redis 服务器能够高效地处理大量并发连接，而不会因为阻塞式 I/O 操作而导致性能下降或并发性能问题。</li>
<li><strong>数据结构的支持：</strong> Redis 提供了丰富的数据结构，如字符串、哈希表、列表、集合、有序集合等，这些数据结构天生就支持并发访问，能够在并发场景下保持数据的一致性。</li>
<li><strong>乐观锁结构：</strong> 在 Redis 中，可以通过 WATCH 和 MULTI/EXEC 命令来实现乐观锁的机制，确保在事务执行期间数据不被其他客户端修改，从而避免并发更新造成的问题。</li>
</ol>
<p>虽然 Redis 本身能够一定程度上解决并发问题，但在面对高并发、复杂事务等情况时，也需要开发人员在应用层面进行合理的并发控制和事务管理，以充分利用 Redis 的并发优势，并确保系统的稳定和可靠性。</p>
<h2 id="Redis的内存淘汰策略"><a href="#Redis的内存淘汰策略" class="headerlink" title="Redis的内存淘汰策略"></a>Redis的内存淘汰策略</h2><p>Redis是一种内存数据库，当内存不足时，需要使用一些策略来淘汰一些不常用的数据，从而释放出更多的内存空间。Redis提供了以下五种内存淘汰策略：</p>
<ol>
<li>noeviction（默认）：当内存不足时，不进行任何淘汰操作，直接返回错误信息。</li>
<li>allkeys-lru：根据LRU（Least Recently Used，最近最少使用）算法淘汰所有key中最近最少使用的那个。</li>
<li>volatile-lru：根据LRU算法淘汰设置了过期时间的key中最近最少使用的那个。</li>
<li>allkeys-random：随机淘汰所有key中的一个。</li>
<li>volatile-random：随机淘汰设置了过期时间的key中的一个。</li>
</ol>
<p>其中，noeviction策略是默认的策略，当内存不足时，不进行任何淘汰操作，直接返回错误信息。而其他四种策略则会根据不同的算法来选择需要淘汰的key。</p>
<p>LRU算法是一种常用的缓存淘汰算法，它基于“最近最少使用”原则，即淘汰最近最少被使用的key。在Redis中，通过记录每个key的访问时间，可以实现LRU算法。</p>
<p>需要注意的是，当使用volatile-lru或volatile-random策略时，只会淘汰设置了过期时间的key，而不会淘汰没有过期时间的key。因此，为了避免内存泄漏，开发人员需要为每个key设置合适的过期时间。</p>
<h2 id="如何防止Redis宕机导致数据丢失"><a href="#如何防止Redis宕机导致数据丢失" class="headerlink" title="如何防止Redis宕机导致数据丢失"></a>如何防止Redis宕机导致数据丢失</h2><p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1730906">https://cloud.tencent.com/developer/article/1730906</a></p>
<ul>
<li>数据持久化</li>
<li>主从复制</li>
<li>自动故障恢复</li>
<li>集群化</li>
</ul>
<h1 id="Springboot"><a href="#Springboot" class="headerlink" title="Springboot"></a>Springboot</h1><h2 id="Spring常用的设计模式"><a href="#Spring常用的设计模式" class="headerlink" title="Spring常用的设计模式"></a>Spring常用的设计模式</h2><p>在Spring框架中，常用的设计模式包括以下几种：</p>
<ol>
<li>单例模式（Singleton Pattern）：Spring容器默认使用单例模式管理Bean对象。通过单例模式，可以确保在整个应用程序中只存在一个实例，提高性能和资源利用率。</li>
<li>工厂模式（Factory Pattern）：Spring使用工厂模式创建和管理Bean对象。通过工厂模式，可以将对象的创建和使用解耦，提供更高的灵活性和可扩展性。</li>
<li>依赖注入（Dependency Injection，DI）：依赖注入是Spring框架的核心特性，它通过控制反转（Inversion of Control，IoC）来实现。通过DI模式，可以将对象之间的依赖关系交给Spring容器管理，降低组件之间的耦合度，提高代码的可测试性和可维护性。</li>
<li>观察者模式（Observer Pattern）：Spring中的事件机制就是基于观察者模式实现的。通过观察者模式，可以实现对象之间的松耦合通信，当某个对象发生变化时，通知其他观察者对象进行相应的处理。</li>
<li>模板方法模式（Template Method Pattern）：Spring中的JdbcTemplate和HibernateTemplate等模板类就是基于模板方法模式实现的。通过模板方法模式，可以定义算法的骨架，将具体的实现细节延迟到子类中，提高代码的复用性和可扩展性。</li>
<li>代理模式（Proxy Pattern）：Spring AOP（面向切面编程）就是基于代理模式实现的。通过代理模式，可以在不改变原有代码的情况下，对方法进行增强或添加额外的处理逻辑，如事务管理、日志记录等。</li>
<li>适配器模式（Adapter Pattern）：Spring中的适配器模式主要应用于集成不同的技术或第三方库。通过适配器模式，可以将不兼容的接口转换为统一的接口，使得不同组件之间能够协同工作。</li>
</ol>
<p>这些设计模式在Spring框架中发挥着重要的作用，帮助开发人员更好地组织和管理代码，提高系统的可维护性、可扩展性和可测试性。</p>
<h2 id="Springboot启动流程"><a href="#Springboot启动流程" class="headerlink" title="Springboot启动流程"></a>Springboot启动流程</h2><p>Spring Boot的启动流程可以概括为以下几个步骤：</p>
<ol>
<li><strong>创建SpringApplication对象</strong>：Spring Boot启动的过程是从SpringApplication的run方法开始的，首先会创建一个SpringApplication对象。SpringApplication的构造函数会根据你的应用类型（是否是Web环境，是否是Reactive环境）来决定创建哪种类型的ApplicationContext。</li>
<li><strong>执行初始化器（Initializers）</strong>：SpringApplication会调用所有的SpringApplicationInitializers。这些初始化器都是在Spring.factories文件中配置的，可以用来做一些预处理工作。</li>
<li><strong>创建应用上下文（ApplicationContext）</strong>：根据前面的步骤确定的应用类型，Spring Boot会创建相应的ApplicationContext。</li>
<li><strong>执行监听器（Listeners）</strong>：SpringApplication会调用所有的SpringApplicationRunListeners。这些监听器都是在Spring.factories文件中配置的，可以用来在Spring Boot启动过程中的特定时刻执行特定的操作。</li>
<li><strong>准备环境</strong>：此阶段Spring Boot会获取并配置SpringApplication所需的Environment（包含Profile和Property等）。</li>
<li><strong>加载Spring Bean定义并启动Spring容器</strong>：Spring Boot会加载所有的Spring Bean定义并启动Spring容器。这个过程中会创建所有的Singleton Beans。</li>
<li><strong>执行命令行Runner和ApplicationRunner</strong>：如果你的应用程序中定义了CommandLineRunner或者ApplicationRunner，Spring Boot会在这个时候执行它们。</li>
</ol>
<h2 id="使用设计模式的好处"><a href="#使用设计模式的好处" class="headerlink" title="使用设计模式的好处"></a>使用设计模式的好处</h2><p>使用设计模式有以下几个好处：</p>
<ol>
<li>提高代码的可维护性：设计模式可以帮助开发人员遵循一套经过验证的最佳实践，使代码更加结构化、清晰和易于理解。这样可以降低代码的复杂性，提高代码的可读性和可维护性，减少后续修改和调试的难度。</li>
<li>增强代码的可扩展性：设计模式通过将系统中的不同部分解耦，使得系统更加灵活和可扩展。当需求变化时，可以更方便地添加新功能或修改现有功能，而无需对整个系统进行大规模的改动。</li>
<li>提高代码的复用性：设计模式鼓励开发人员将通用的解决方案抽象出来，形成可复用的组件或模块。这样可以减少重复编写类似代码的工作量，提高代码的复用性，同时也降低了引入错误的风险。</li>
<li>促进团队合作：设计模式提供了一种共同的语言和思维方式，使得团队成员之间更容易进行交流和协作。团队成员可以基于设计模式的概念和原则进行讨论和设计，从而更好地理解彼此的意图和代码，提高团队的协作效率。</li>
<li>提高代码的可测试性：设计模式可以帮助开发人员编写更具可测试性的代码。通过将系统的不同部分解耦，可以更容易地对单个组件进行单元测试，从而提高代码的质量和稳定性。</li>
</ol>
<p>总的来说，使用设计模式可以使代码更加可维护、可扩展、可复用和可测试，同时也有助于促进团队合作和降低开发风险。然而，需要根据具体的场景和需求选择适合的设计模式，并避免过度使用设计模式导致代码过于复杂或不必要的抽象。</p>
<h2 id="对Spring-ioc的理解"><a href="#对Spring-ioc的理解" class="headerlink" title="对Spring ioc的理解"></a>对Spring ioc的理解</h2><p>Spring的IoC（控制反转）是一种设计原则和模式，它通过将对象的创建、依赖关系的管理和对象的生命周期交给容器来管理，从而实现了对象之间的解耦和灵活性。</p>
<p>在传统的应用程序中，对象的创建和依赖关系通常由开发人员手动管理。这样会导致代码的紧耦合，使得代码难以维护、扩展和测试。而Spring的IoC容器通过控制反转的方式，将对象的创建和依赖关系的管理转移到容器中，开发人员只需要定义对象的配置信息，由容器负责创建和管理对象。</p>
<p><strong>IoC（Inversion of Control:控制反转）</strong> 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。不过， IoC 并非 Spring 特有，在其他语言中也有应用。</p>
<p><strong>为什么叫控制反转？</strong></p>
<ul>
<li><strong>控制</strong>：指的是对象创建（实例化、管理）的权力</li>
<li><strong>反转</strong>：控制权交给外部环境（Spring 框架、IoC 容器）</li>
</ul>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/frc-365faceb5697f04f31399937c059c162.png" alt="IoC 图解"></p>
<p>将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。</p>
<p>在实际项目中一个 Service 类可能依赖了很多其他的类，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IoC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。</p>
<p>在 Spring 中， IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个 Map（key，value），Map 中存放的是各种对象。</p>
<p>Spring 时代我们一般通过 XML 文件来配置 Bean，后来开发人员觉得 XML 文件来配置不太好，于是 SpringBoot 注解配置就慢慢开始流行起来。</p>
<p><a target="_blank" rel="noopener" href="https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html#%E8%B0%88%E8%B0%88%E8%87%AA%E5%B7%B1%E5%AF%B9%E4%BA%8E-spring-ioc-%E7%9A%84%E4%BA%86%E8%A7%A3">https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html#%E8%B0%88%E8%B0%88%E8%87%AA%E5%B7%B1%E5%AF%B9%E4%BA%8E-spring-ioc-%E7%9A%84%E4%BA%86%E8%A7%A3</a></p>
<h2 id="什么是-Spring-Bean？Spring-中-Bean-的作用域是什么？"><a href="#什么是-Spring-Bean？Spring-中-Bean-的作用域是什么？" class="headerlink" title="什么是 Spring Bean？Spring 中 Bean 的作用域是什么？"></a>什么是 Spring Bean？Spring 中 Bean 的作用域是什么？</h2><p>Bean 代指的就是那些被 IoC 容器所管理的对象。</p>
<p><a target="_blank" rel="noopener" href="https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html#%E4%BB%80%E4%B9%88%E6%98%AF-spring-bean">https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html#%E4%BB%80%E4%B9%88%E6%98%AF-spring-bean</a></p>
<p>Spring 中 Bean 的作用域通常有下面几种：</p>
<ul>
<li><strong>singleton</strong> : IoC 容器中只有唯一的 bean 实例。Spring 中的 bean 默认都是单例的，是对单例设计模式的应用。</li>
<li><strong>prototype</strong> : 每次获取都会创建一个新的 bean 实例。也就是说，连续 <code>getBean()</code> 两次，得到的是不同的 Bean 实例。</li>
<li><strong>request</strong> （仅 Web 应用可用）: 每一次 HTTP 请求都会产生一个新的 bean（请求 bean），该 bean 仅在当前 HTTP request 内有效。</li>
<li><strong>session</strong> （仅 Web 应用可用） : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean（会话 bean），该 bean 仅在当前 HTTP session 内有效。</li>
<li><strong>application/global-session</strong> （仅 Web 应用可用）：每个 Web 应用在启动时创建一个 Bean（应用 Bean），该 bean 仅在当前应用启动时间内有效。</li>
<li><strong>websocket</strong> （仅 Web 应用可用）：每一次 WebSocket 会话产生一个新的 bean。</li>
</ul>
<h2 id="IOC和AOP"><a href="#IOC和AOP" class="headerlink" title="IOC和AOP"></a>IOC和AOP</h2><p>IOC（Inversion of Control，控制反转）和AOP（Aspect-Oriented Programming，面向切面编程）是两个常用的软件开发概念。</p>
<p>IOC（控制反转）是一种设计思想，它将对象的创建、组装和依赖关系的管理交给容器来负责，而不是由代码显式地进行管理。在传统的编程模型中，对象间的依赖关系是由对象自身管理和维护的，而在IOC 中，对象通过容器来解决依赖关系，即控制权被反转给了容器。IOC 容器通过读取配置文件或者注解等方式来获取对象的创建和组装信息，并在运行时动态地创建对象并维护对象之间的依赖关系。常见的IOC 容器有Spring Framework中的ApplicationContext。</p>
<p>AOP（面向切面编程）是一种编程范式，它提供了一种机制来将程序的横切关注点（如日志、事务、安全性等）从核心业务逻辑中解耦出来。在传统的编程模型中，这些横切关注点往往会散布在各个方法中，导致代码重复和难以维护。AOP 使用切面（Aspect）的概念，通过在不修改原有代码的情况下，在核心业务逻辑的不同点上插入横切逻辑。切面可以定义在程序执行的各个阶段执行的代码，如方法调用前后、异常处理等。AOP 的优势在于提高了代码的可重用性和可维护性，将横切关注点与核心业务逻辑进行解耦。常见的AOP 框架有Spring AOP、AspectJ 等。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/pedro7k/article/details/115415675">https://blog.csdn.net/pedro7k/article/details/115415675</a></p>
<p>综合来说，IOC 和 AOP 是两种不同的概念和编程思想。IOC 关注对象之间的依赖关系以及由容器来负责对象的生命周期和依赖关系的管理；AOP 关注跨越多个对象的横切关注点，并提供了一种机制将其从核心业务逻辑中分离出来。在实际开发中，IOC 和 AOP 往往会结合使用，通过IOC 容器加载和管理对象，并通过AOP 技术实现对这些对象的横切逻辑的插入。例如，使用Spring Framework时，可以通过IOC 容器管理对象的创建和依赖关系，并通过Spring AOP 来实现日志、事务等横切关注点的处理。</p>
<h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><p>类加载是Java虚拟机将类的字节码加载到内存中，并对其进行验证、准备和解析的过程。类加载过程主要包括以下几个步骤：</p>
<ol>
<li>加载（Loading）：加载是类加载的第一阶段，它的目标是根据类的全限定名获取类的字节码数据，并将其转换为方法区（Method Area）的内部表示形式。加载过程可以从本地文件系统、网络等途径获取字节码数据。</li>
<li>验证（Verification）：验证是类加载的第二个阶段，它主要确保被加载的字节码符合Java虚拟机的安全规范。在验证阶段，会进行一系列的检查，例如字节码的格式验证、元数据验证、字节码语义验证等。</li>
<li>准备（Preparation）：准备是类加载的第三个阶段，它主要为类变量（静态变量）在方法区中分配内存并设置初始值。这里只会分配内存并初始化默认值，而不会执行初始化器（即静态代码块）。</li>
<li>解析（Resolution）：解析是类加载的第四个阶段，它主要将类、接口、字段和方法的符号引用解析为直接引用。解析阶段可以进一步划分为类或接口的解析、字段解析和方法解析。</li>
<li>初始化（Initialization）：初始化是类加载的最后一个阶段，它负责执行类的初始化器（即静态代码块）以及对静态变量的赋值操作。在初始化阶段，程序会按照编写的顺序执行静态代码块和静态变量的赋值操作。</li>
</ol>
<h2 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h2><p>在 Spring 框架中，Bean 的生命周期可以分为以下几个阶段：</p>
<ol>
<li>实例化（Instantiation）：在这个阶段，Spring 容器会根据配置信息或注解创建 Bean 的实例。这可以通过构造函数实例化或工厂方法实例化来完成。</li>
<li>属性赋值（Population）：在实例化完成后，Spring 容器会通过依赖注入（Dependency Injection）等方式为 Bean 的属性设置相应的值。这可以通过 XML 配置、注解或 Java Config 等方式来完成。</li>
<li>初始化（Initialization）：在属性赋值完成后，Spring 容器会调用 Bean 的初始化回调方法，对 Bean 进行一些额外的初始化操作。这可以通过实现 InitializingBean 接口、使用 @PostConstruct 注解或配置 init-method 来实现。</li>
<li>使用（In Use）：在初始化完成后，Bean 就可以被应用程序使用了。它可以被其他 Bean 引用、注入或通过 Spring 容器获取。</li>
<li>销毁（Destruction）：当应用程序关闭或 Spring 容器销毁时，容器会调用 Bean 的销毁回调方法，执行一些清理操作。这可以通过实现 DisposableBean 接口、使用 @PreDestroy 注解或配置 destroy-method 来实现。</li>
</ol>
<p>需要注意的是，Bean 的生命周期可以通过自定义的 Bean 后处理器（BeanPostProcessor）进行扩展和定制。Bean 后处理器可以在 Bean 的初始化前后插入自定义逻辑，对 Bean 进行额外的处理。</p>
<h2 id="Springboot常用注解"><a href="#Springboot常用注解" class="headerlink" title="Springboot常用注解"></a>Springboot常用注解</h2><p><a target="_blank" rel="noopener" href="https://javaguide.cn/system-design/framework/spring/spring-common-annotations.html">https://javaguide.cn/system-design/framework/spring/spring-common-annotations.html</a></p>
<h2 id="SpringCloud请求流程"><a href="#SpringCloud请求流程" class="headerlink" title="SpringCloud请求流程"></a>SpringCloud请求流程</h2><p>请求流程：</p>
<ol>
<li>客户端发起请求</li>
<li>Handler Mapping: 根据断言，去将请求转发到对应的路由</li>
<li>Web Handler: 处理请求 (一层层经过过滤器</li>
<li>实际调用服务</li>
</ol>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/1668952703302-f275a73c-1142-4d3c-87b6-8ac8f23c38e5.png" alt="img" style="zoom: 67%;" /></p>
<h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1><h2 id="RPC的核心组件"><a href="#RPC的核心组件" class="headerlink" title="RPC的核心组件"></a>RPC的核心组件</h2><p>RPC(Remote Procedure Call，远程过程调用)是一种用于实现分布式系统通信的协议和技术。它允许一个计算机程序调用另一个地址的函数或方法，就像本地函数调用一样，而不需要开发者显式地处理底层网络通信和数据序列化等问题。<br>Dubbo 是基于 Java 的高性能、轻量级的开源 RPC 框架，便于开发者轻实现分布式系统和微服务架构。此外Dubbo 还提供了服务治理等功能。<br>Dubbo RPC 框架的优势，简单来说就是性能高、协议多、功能强、生态好、易扩展具体的优势如下:<br>1.性能优秀: Dubbo 经过高度优化，具有出色的性能表现，适用于高并发和低延迟的场景<br>2.多协议支持: Dubbo 支持多种通信协议，可以根据不同的需求选择合适的协议，提供灵活性.<br>3.服务治理: Dubbo 提供了丰富的服务治理功能，包括负载均衡、路由、容错处理等，有助于构建可靠的分布式系统。<br>生态系统: Dubbo 有广泛的生态系统和社区支持，提供了大量扩展和插件，满足各种应用场景的需求.4.<br>5.可扩展性: Dubbo 的架构设计允许开发者轻松扩展和定制功能，以适应不同的业务需求。</p>
<p>三个核心组件为：</p>
<ul>
<li>注册中心，用于服务端注册远程服务以及客户端发现服务</li>
<li>服务端，对外提供后台服务，将自己的服务信息注册到注册中心</li>
<li>客户端，从注册中心获取远程服务的注册信息，然后进行远程过程调用</li>
</ul>
<p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20231108125434272.png" alt="image-20231108125434272"></p>
<p>RPC的核心组件通常包括以下几个方面：</p>
<ol>
<li><strong>客户端（Client）：</strong>服务调用方。</li>
<li><strong>客户端存根（Client Stub）：</strong>存放服务端地址信息，将客户端的请求参数数据信息打包成网络消息，再通过网络传输发送给服务端。</li>
<li><strong>服务端存根（Server Stub）：</strong>接收客户端发送过来的请求消息并进行解包，然后再调用本地服务进行处理。</li>
<li><strong>服务端（Server）：</strong>服务的真正提供者。</li>
<li><strong>Network Service：</strong>底层传输，可以是 TCP 或 HTTP。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/94983974">https://zhuanlan.zhihu.com/p/94983974</a></p>
<h2 id="cookie和session的区别"><a href="#cookie和session的区别" class="headerlink" title="cookie和session的区别"></a>cookie和session的区别</h2><p>Cookie 和 Session 是用于在 Web 应用中跟踪用户状态和实现会话管理的两种机制，它们之间的主要区别如下：</p>
<ol>
<li>存储位置：Cookie 存储在客户端浏览器端，而 Session 存储在服务器端。</li>
<li>数据存储方式：Cookie 将数据以键值对的形式存储在客户端浏览器的 Cookie 文件中，而 Session 将数据存储在服务器的内存或数据库中。</li>
<li>数据安全性：由于 Cookie 存储在客户端，因此存在被篡改的风险。为了增加安全性，可以对 Cookie 进行加密或签名处理。相比之下，Session 存储在服务器端，客户端无法直接访问或修改，安全性更高。</li>
<li>存储容量：由于 Cookie 存储在客户端，每个域名可设置的 Cookie 数量和大小都有限制，通常为几 KB 到几十 KB。而 Session 存储在服务器端，理论上没有明确的容量限制，取决于服务器的性能和存储空间。</li>
<li>生命周期：Cookie 可以设置过期时间，可以是会话级的（关闭浏览器时清除）或持久性的（在指定时间后过期）。而 Session 的生命周期由服务器控制，可以在一定时间内保持活动状态，超过设定时间未活动则会过期销毁。</li>
<li>跨域支持：Cookie 可以跨域名和子域名访问，但受同源策略的限制。而 Session 存储在服务器端，不受跨域问题的影响。</li>
</ol>
<p>综上所述，Cookie 适用于存储少量的非敏感数据，并且需要在客户端进行访问或展示；而 Session 适用于存储大量或敏感的用户数据，并且需要在服务器端进行处理和管理。在实际应用中，两者可以结合使用，通过 Cookie 存储 Session ID，在客户端和服务器之间建立关联，实现更安全、高效的用户会话管理。</p>
<h2 id="线程和进程的区别"><a href="#线程和进程的区别" class="headerlink" title="线程和进程的区别"></a>线程和进程的区别</h2><p>线程（Thread）和进程（Process）是操作系统中的基本概念，它们是实现并发编程和多任务处理的核心机制。下面是线程和进程的区别：</p>
<ol>
<li>资源占用：进程是操作系统资源分配的基本单位，它包括代码、数据、文件等资源；而线程是进程内部的执行单元，不拥有系统资源，但共享进程的资源。</li>
<li>调度：进程由操作系统进行调度，每个进程独立运行，而线程由进程进行调度，同一个进程中的线程共享进程的资源，可以同时执行。</li>
<li>内存隔离：进程之间拥有独立的内存空间，互不干扰，进程崩溃不会影响其他进程；而线程共享进程的内存空间，一个线程崩溃会导致整个进程挂掉。</li>
<li>切换开销：进程切换时，需要保存当前进程的状态，并恢复新的进程的状态，切换开销较大；而线程切换时，只需要保存当前线程的状态，并恢复新的线程的状态，切换开销较小。</li>
<li>通信方式：进程之间通信比较复杂，需要使用进程间通信机制；而线程之间通信比较简单，直接访问共享内存即可。</li>
</ol>
<p>总体来说，进程是资源分配的最小单位，线程是执行调度的最小单位。进程之间相互独立，而同一个进程中的线程共享进程的资源。线程切换开销较小，但需要注意线程安全问题；进程切换开销较大，但不会影响其他进程的运行。</p>
<h2 id="线程的一些状态"><a href="#线程的一些状态" class="headerlink" title="线程的一些状态"></a>线程的一些状态</h2><p>线程在生命周期中存在多种状态，主要包括以下几种状态：</p>
<ol>
<li>新建（New）：当线程对象被创建但尚未启动时，处于新建状态。此时还没有分配线程执行所需的系统资源。</li>
<li>运行（Runnable）：当调用线程的start()方法后，线程进入可运行状态。此时线程已经分配到了系统资源，并且可以开始执行线程的run()方法。但是并不一定立即开始执行，需要等待CPU调度。</li>
<li>运行（Running）：处于可运行状态（Runnable）的线程获得了CPU时间片，真正执行程序代码。</li>
<li>阻塞（Blocked）：线程被阻塞，暂时停止执行。常见的情况包括等待阻塞、同步阻塞、被其他线程挂起等。当条件满足时，线程会从阻塞状态转换为可运行状态，等待获取CPU资源。</li>
<li>等待（Waiting）：处于等待状态的线程是被告知在某个条件下等待。它会一直等待，直到被其他线程唤醒。</li>
<li>超时等待（Timed Waiting）：类似于等待状态，但是具有超时时间，在达到超时时间后会自动转为可运行状态。</li>
<li>终止（Terminated）：线程执行完run()方法后或者发生异常导致run()方法终止，线程进入终止状态。</li>
</ol>
<p>这些状态通过线程调度器来实现切换和管理，随着线程的执行和系统资源的分配，线程会在不同的状态之间转换。</p>
<h2 id="Maven排除依赖"><a href="#Maven排除依赖" class="headerlink" title="Maven排除依赖"></a>Maven排除依赖</h2><p>Maven 是一个开源的构建工具，用于管理 Java 项目的构建、依赖管理和项目生命周期本项目的所有依赖都是由 Maven 进行管理的，每个子项目都有自己的 pom.xml 进行管理。首先使用 mvninstall 命令将 common 公共模块在本地打打包，然后在其他子项目的 pom.xml 中引入该模块即可复用代码。每子项目可以独立通过 mvn package 命令进行打包和部署。Maven 还支持子父依赖多模块管理，通过 modules 配置给父项目指定子模块，从而实现统一的公共依赖和依赖版本定义。</p>
<p>当多个依赖项引用同一个库的不同版本时，就可能出现依赖冲突问题。如果两个或多个依赖项使用了不兼容的库版本，则可能会导致编译错误或者运行时异常。为了避免这种情况，我们需要及时解决依赖冲突。</p>
<p>可以通过以下方式解决 Maven 依赖冲突问题：</p>
<ol>
<li>排除依赖项：可以手动指定某些依赖项不进行传递性依赖，避免引入不兼容的依赖。例如，可以通过 Maven 的 <code>&lt;exclusions&gt;</code> 元素排除指定的依赖项。</li>
<li>升级依赖项：可以尝试升级依赖项的版本，以兼容当前项目所使用的其他依赖项。可以通过 Maven 的 <code>&lt;dependencyManagement&gt;</code> 元素声明项目依赖的版本号，从而避免重复版本的问题。</li>
<li>引入更精准的依赖项：可以使用更加精准的依赖项描述符，比如指定依赖项的范围（scope）或版本范围（version range），来避免不必要的传递性依赖。</li>
</ol>
<p>除此之外，还可以使用 Maven 的 <code>dependency:tree</code> 命令来查看项目的依赖树，以便更好地理解项目的依赖结构和进行冲突解决。</p>
<p><a target="_blank" rel="noopener" href="https://javaguide.cn/tools/maven/maven-core-concepts.html#%E6%8E%92%E9%99%A4%E4%BE%9D%E8%B5%96">https://javaguide.cn/tools/maven/maven-core-concepts.html#%E6%8E%92%E9%99%A4%E4%BE%9D%E8%B5%96</a></p>
<h2 id="Maven的快照库和发行库"><a href="#Maven的快照库和发行库" class="headerlink" title="Maven的快照库和发行库"></a>Maven的快照库和发行库</h2><p>在Maven中，有两种类型的仓库：快照库（Snapshot Repository）和发行库（Release Repository）。它们分别用于管理快照版本和发行版本的构件。</p>
<ol>
<li>快照库（Snapshot Repository）：<ul>
<li>快照版本是处于开发过程中的不稳定版本，通常带有”-SNAPSHOT”后缀。它们经常用于团队内部共享和测试，以及进行频繁的迭代和更新。</li>
<li>快照库是用于存储这些快照版本的仓库。当项目构建时，Maven会检查快照库以获取最新的快照版本，并下载相应的构件进行构建。</li>
<li>默认情况下，Maven配置文件（settings.xml）中的本地仓库和远程仓库都包括了一个默认的快照库。</li>
</ul>
</li>
<li>发行库（Release Repository）：<ul>
<li>发行版本是经过测试并且稳定的版本，没有”-SNAPSHOT”后缀。它们被认为是可靠的和适合部署的版本。</li>
<li>发行库是用于存储这些发行版本的仓库。当项目构建时，Maven会从发行库中获取相应的构件进行构建和部署。</li>
<li>发行库通常是公共的或者私有的，供团队或者组织内部使用。可以通过配置Maven的远程仓库来指定使用的发行库。</li>
</ul>
</li>
</ol>
<p>总结起来，快照库用于存储不稳定的快照版本，适用于开发和测试阶段，而发行库用于存储稳定的发行版本，适用于部署和发布阶段。通过区分这两种类型的仓库，可以更好地管理和控制项目的构建和发布过程。</p>
<h2 id="CPU核缓存和主存数据怎么保持一致"><a href="#CPU核缓存和主存数据怎么保持一致" class="headerlink" title="CPU核缓存和主存数据怎么保持一致"></a>CPU核缓存和主存数据怎么保持一致</h2><p>CPU核缓存和主存数据的一致性问题是计算机体系结构中非常重要的一个问题。由于CPU核缓存和主存数据之间的访问速度不同，当多个CPU核同时访问同一块内存时，就可能会出现缓存和主存数据不一致的情况。为了解决这个问题，通常有以下两种方法：</p>
<ol>
<li>总线锁定（Bus Locking）：<ul>
<li>总线锁定是一种硬件级别的解决方案，它可以保证在某个CPU核修改内存数据时，其他CPU核无法同时访问相同的内存地址。</li>
<li>当一个CPU核请求对某个内存地址进行写操作时，它会发出总线锁定信号，这样其他CPU核就无法通过总线访问该内存地址，直到该CPU核释放锁定信号为止。</li>
</ul>
</li>
<li>缓存一致性协议（Cache Coherence Protocol）：<ul>
<li>缓存一致性协议是一种软件级别的解决方案，它可以保证所有CPU核的缓存数据与主存数据保持一致。</li>
<li>当一个CPU核修改某个内存地址的数据时，它会向其他CPU核发送一个缓存失效信号，通知它们将相应的缓存数据标记为失效状态。当其他CPU核再次访问相同的内存地址时，它们会发现缓存数据已经失效，从而强制重新从主存中读取最新的数据。</li>
</ul>
</li>
</ol>
<p>总的来说，总线锁定和缓存一致性协议都可以解决CPU核缓存和主存数据不一致的问题。但是，总线锁定会导致系统的并发性能下降，而缓存一致性协议则需要消耗大量的计算资源和通信带宽。因此，在实际应用中需要根据具体的场景选择合适的方案。</p>
<h2 id="在浏览器输入URL，按下回车之后的流程"><a href="#在浏览器输入URL，按下回车之后的流程" class="headerlink" title="在浏览器输入URL，按下回车之后的流程"></a>在浏览器输入URL，按下回车之后的流程</h2><p>在浏览器输入URL并按下回车后，以下是一般的流程：</p>
<ol>
<li>URL解析：浏览器会解析输入的URL，分析其结构和组成部分。URL通常由协议（如HTTP、HTTPS）、域名（<a target="_blank" rel="noopener" href="http://xn--www-eo8e.example.com/">如www.example.com</a>）和路径（如/page）等组成。</li>
<li>DNS解析：浏览器将解析得到的域名发送给DNS服务器，以获取对应的IP地址。DNS服务器会返回与域名对应的IP地址，供后续建立网络连接使用。</li>
<li>建立TCP连接：浏览器使用HTTP协议通过TCP/IP协议栈与服务器建立网络连接。这个过程涉及到三次握手，即客户端向服务器发送连接请求，服务器响应确认，最后客户端再次确认。</li>
<li>发起HTTP请求：建立好TCP连接后，浏览器会向服务器发送HTTP请求。请求中包含了请求方法（如GET、POST）、请求头（如User-Agent、Cookie）和请求体（对于POST请求）等信息。</li>
<li>服务器处理请求：服务器接收到浏览器发送的HTTP请求后，会根据请求的内容进行相应的处理。这可能涉及到读取数据库、执行业务逻辑等操作。</li>
<li>服务器返回HTTP响应：服务器处理完请求后，会生成HTTP响应，并将其发送回浏览器。响应中包含了状态码（如200表示成功、404表示未找到）和响应内容等信息。</li>
<li>浏览器渲染页面：浏览器接收到服务器返回的HTTP响应后，会根据响应中的内容进行页面渲染。这包括解析HTML、CSS和JavaScript，并将其呈现给用户。</li>
<li>关闭TCP连接：页面渲染完成后，浏览器会关闭与服务器之间的TCP连接。这样可以释放资源并终止与服务器的通信。</li>
</ol>
<p>以上是一般的流程，实际情况可能会有些差异，例如使用HTTPS进行加密通信、缓存机制的应用等。不同的浏览器和服务器也可能有一些特定的优化和处理方式。</p>
<blockquote>
<p>在浏览器输入URL并按下回车后，涉及到网络层和数据链路层的一些操作如下：</p>
<ol>
<li>网络层（网络协议）：在URL解析完成后，浏览器会使用网络层协议（如IP协议）来确定目标服务器的IP地址。这个过程称为路由选择，浏览器会根据目标IP地址和本地网络配置，确定数据包传输的路径。</li>
<li>数据链路层（以太网协议）：在建立TCP连接之前，浏览器需要将数据包封装成帧，并通过数据链路层的协议（如以太网协议）发送到网络中。这个过程包括将IP数据报封装成以太网帧、添加源和目标MAC地址等操作。</li>
<li>路由器转发：在数据包从浏览器发送到服务器的过程中，可能会经过多个路由器。每个路由器都根据其路由表，将接收到的数据包转发到下一个目标地址。这个过程是在网络层进行的，用于实现数据包的跨网络传输。</li>
<li>ARP协议：在数据链路层中，当浏览器需要将数据包发送到目标服务器时，需要知道目标服务器的MAC地址。为了获取目标MAC地址，浏览器会使用ARP（地址解析协议）向本地网络中的其他设备发送ARP请求，以获取目标服务器的MAC地址。</li>
<li>数据包传输：经过路由器转发和ARP协议的处理后，数据包会通过数据链路层的物理介质（如以太网、Wi-Fi）传输到目标服务器。这个过程涉及到数据包的逐跳传输、物理介质的信号传输等。</li>
</ol>
</blockquote>
<h2 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h2><p>栈帧（Stack Frame），是在程序执行过程中用于支持函数调用和返回的一种数据结构。每当一个函数被调用时，都会在内存中创建一个对应的栈帧，用于存储函数的局部变量、参数、返回地址等信息。</p>
<p>栈帧通常包含以下几个重要的组成部分：</p>
<ol>
<li>局部变量（Local Variables）：用于存储函数内部声明的局部变量，包括基本数据类型、对象引用等。这些变量在函数执行期间可见，并在函数返回后被销毁。</li>
<li>参数（Arguments）：用于存储函数调用时传递的参数值。参数可以是基本数据类型或对象引用，在函数执行期间可以被访问和使用。</li>
<li>返回地址（Return Address）：用于存储函数执行完成后返回的位置，即调用该函数的指令的下一条指令地址。通过返回地址，程序可以继续执行调用函数之后的代码。</li>
<li>动态链接（Dynamic Link）：用于存储函数调用的动态链接信息，即指向调用函数的代码段的指针。通过动态链接，可以在函数调用时正确地访问到函数所在的代码段。</li>
<li>保存的上下文（Saved Context）：用于存储函数调用前的一些重要状态，如调用前的寄存器值、标志位等。这些状态在函数执行完成后需要恢复到调用函数的状态。</li>
</ol>
<p>栈帧的创建和销毁遵循函数调用的过程。当一个函数被调用时，会在栈上分配一个新的栈帧，并将参数、返回地址等信息压入栈中。函数执行期间，局部变量和中间结果都存储在当前栈帧中。当函数执行完成后，栈帧被销毁，程序回到调用函数的位置继续执行。</p>
<h2 id="模型层和业务层的概念及抽象公共模块的作用"><a href="#模型层和业务层的概念及抽象公共模块的作用" class="headerlink" title="模型层和业务层的概念及抽象公共模块的作用"></a>模型层和业务层的概念及抽象公共模块的作用</h2><p>模型层(Model) ：包括数据模型、实体类、业务封装对象等，一般不包含业务逻辑。<br>业务层 (Service):：包含了应用程序的业务逻辑和处理规则，一般会用到模型层的代码。</p>
<p>抽象公共模块的主要目的是为了复用代码。尤其是在微服务项目中，通常要把独立于业务的请求响应封装对象、全局异常处理类、常量、公共的数据模型抽象为公共模块，提供给各业务服务引入，便于项目的维护和理解。</p>
<h1 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h1><h2 id="双检锁单例模式"><a href="#双检锁单例模式" class="headerlink" title="双检锁单例模式"></a>双检锁单例模式</h2><p>双检锁单例模式（Double-Checked Locking Singleton Pattern）是一种常用的线程安全的单例模式实现方式。它的特点是能够在保证线程安全的情况下，通过延迟加载的方式提高对象的创建和获取效率。</p>
<p>下面是一个使用双检锁单例模式实现的示例代码：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance<span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 私有构造函数</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 第一次检查，避免不必要的同步</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 第二次检查，确保只有一个线程创建实例</span>
                    instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在上述代码中，关键点主要有以下几个：</p>
<ol>
<li>将实例变量 <code>instance</code> 声明为 <code>volatile</code> 类型，确保多线程环境下的可见性和有序性。</li>
<li>在获取实例的方法 <code>getInstance()</code> 中进行双重检查，首先检查 <code>instance</code> 是否已经被实例化，如果没有，则进入同步块。</li>
<li>在同步块内部再次检查 <code>instance</code>，这是为了防止多个线程同时通过了第一次检查，其中一个线程进入同步块创建实例后，其他线程再次进入同步块创建实例。</li>
</ol>
<p>通过双检锁单例模式，可以在多线程环境下保证只有一个实例被创建，并且在实例已经被创建后，不需要每次获取实例都进行同步操作，提高了性能。需要注意的是，该模式要求实例变量必须使用 <code>volatile</code> 关键字修饰，以确保可见性和有序性。此外，双检锁单例模式在早期的JDK版本中可能存在一些问题，如指令重排序等，但在较新的JDK版本中已经得到了解决。</p>
<h2 id="Nginx实现负载均衡的算法"><a href="#Nginx实现负载均衡的算法" class="headerlink" title="Nginx实现负载均衡的算法"></a>Nginx实现负载均衡的算法</h2><p>Nginx是一款常用的高性能HTTP和反向代理服务器，它提供了多种负载均衡算法来分发客户端请求到后端服务器。下面介绍几种常见的负载均衡算法：</p>
<ol>
<li>轮询（Round Robin）：<ul>
<li>默认的负载均衡算法，按照请求的顺序依次将请求分配给后端服务器。每个请求按照轮询的方式分发，均匀地分配到每个服务器上。</li>
</ul>
</li>
<li>加权轮询（Weighted Round Robin）：<ul>
<li>在轮询算法的基础上，为每个后端服务器设置一个权重值。权重值越高的服务器，被选中的概率就越大，处理更多的请求。</li>
</ul>
</li>
<li>IP哈希（IP Hash）：<ul>
<li>根据客户端的IP地址计算哈希值，然后将请求分配给对应哈希值的后端服务器。同一个IP地址的请求总是被分发到同一个后端服务器上，适用于需要保持会话的场景。</li>
</ul>
</li>
<li>最少连接（Least Connections）：<ul>
<li>统计每个后端服务器当前的连接数，将请求分配给连接数最少的服务器。这样可以确保请求被均衡地分发到连接数较少的服务器上，达到负载均衡的效果。</li>
</ul>
</li>
<li>随机（Random）：<ul>
<li>随机选择一个后端服务器来处理每个请求，每个服务器被选中的概率相等。适用于简单的负载均衡场景，但不保证每个服务器的负载均衡性。</li>
</ul>
</li>
</ol>
<p>除了以上几种常见的负载均衡算法，Nginx还支持其他一些高级的算法，如URL哈希、Fair（公平）等。可以根据实际需求选择合适的负载均衡算法来实现请求的分发和负载均衡。在Nginx的配置文件中，可以通过指定 <code>upstream</code> 块来定义后端服务器组，并使用 <code>server</code> 指令来设置负载均衡算法。例如：</p>
<pre class="line-numbers language-none"><code class="language-none">http &#123;
    upstream backend &#123;
        server backend1.example.com;
        server backend2.example.com;
        server backend3.example.com;
    &#125;

    server &#123;
        listen 80;
        location &#x2F; &#123;
            proxy_pass http:&#x2F;&#x2F;backend;
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上述配置中，定义了一个名为 <code>backend</code> 的后端服务器组，包含了三个后端服务器。通过 <code>proxy_pass</code> 指令将请求转发给 <code>backend</code> 后端服务器组，Nginx会根据指定的负载均衡算法将请求分发到后端服务器上。</p>
<h2 id="基于JWT的token验证流程"><a href="#基于JWT的token验证流程" class="headerlink" title="基于JWT的token验证流程"></a>基于JWT的token验证流程</h2><p>JWT 本质上就是一组字串，通过（<code>.</code>）切分成三个为 Base64 编码的部分：</p>
<ul>
<li><strong>Header</strong> : 描述 JWT 的元数据，定义了生成签名的算法以及 <code>Token</code> 的类型。</li>
<li><strong>Payload</strong> : 用来存放实际需要传递的数据（具体的业务数据），比如用户id。</li>
<li><strong>Signature（签名）</strong>：服务器通过 Payload、Header 和一个密钥(Secret)使用 Header 里面指定的签名算法（默认是 HMAC SHA256）生成。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://javaguide.cn/system-design/security/jwt-intro.html#%E4%BB%80%E4%B9%88%E6%98%AF-jwt">https://javaguide.cn/system-design/security/jwt-intro.html#%E4%BB%80%E4%B9%88%E6%98%AF-jwt</a></p>
<p>基于JWT（JSON Web Token）的token验证流程一般包括以下步骤：</p>
<ol>
<li>用户通过用户名和密码进行身份认证，服务器验证用户信息并生成一个JWT token。</li>
<li>服务器将JWT token发送给客户端，客户端将其保存在本地（通常是在浏览器的cookie或localStorage中）。</li>
<li>客户端在每次请求时都将JWT token放在请求头中，例如Authorization: Bearer <token>。</li>
<li>服务器在接收到请求后，会从请求头中获取JWT token，并对其进行解析和验证。</li>
<li>服务器使用密钥对JWT token进行解码，如果解码成功则说明该token是有效的。</li>
<li>服务器验证JWT token的签名是否正确，以确保该token没有被篡改过。</li>
<li>服务器检查JWT token的有效期是否已过期，如果过期则拒绝该请求。</li>
<li>如果JWT token验证通过，则服务器可以根据其中携带的信息（例如用户ID）来进行后续的业务逻辑处理。</li>
</ol>
<blockquote>
<p>过期时间是作为JWT payload（负载）的一个字段进行设置的。</p>
<p>具体实现步骤如下：</p>
<ol>
<li>在生成JWT token时，将过期时间（通常是一个时间戳）添加到token的payload中。</li>
<li>客户端在接收到token后，将其保存在本地（例如cookie或localStorage）。</li>
<li>在每次请求时，客户端将token放在请求头中发送给服务器。</li>
<li>服务器在接收到请求时，会解析token，并检查其中的过期时间。</li>
<li>服务器比较当前时间与token中的过期时间，如果当前时间已经超过过期时间，则拒绝该请求。</li>
<li>如果token未过期，则服务器可以继续处理请求。</li>
</ol>
<p>为了进一步提高安全性，可以考虑在JWT中使用刷新令牌（refresh token）的机制。当token过期时，客户端可以使用refresh token向服务器请求新的token，而不需要重新输入用户名和密码进行身份认证。这样可以在一定程度上平衡安全性和用户体验。</p>
</blockquote>
<p>有关公钥私钥：</p>
<ul>
<li>当该用户发送文件时，用私钥签名，别人用他给的公钥解密，可以保证该信息是由他发送的。即<strong>数字签名</strong></li>
<li>当该用户接受文件时，别人用他的公钥加密，他用私钥解密，可以保证该信息只能由他看到。即<strong>安全传输</strong></li>
</ul>
<h2 id="API开放平台模块划分"><a href="#API开放平台模块划分" class="headerlink" title="API开放平台模块划分"></a>API开放平台模块划分</h2><p>API 开放平台分为 5 个<strong>子项目</strong> (核心模块) ，分别为:</p>
<ul>
<li>api-backend: 核心业务后端，负责用户和接口管理等核心业务功能</li>
<li>api-gateway: API 网关服务，负责集中的路由转发、统一鉴权、统一业务处理、访问控制等</li>
<li>api-common: 公共模块，包括各其他模块中需要复用的方法、工具类、实体类、全局异常等</li>
<li>api-client-sdk: 客户端 SDK，封装了对各 API 接口的调用方法，降低开发者的使用成本</li>
<li>api-interface: 提供模拟 API接口</li>
</ul>
<p>交互流程：首先管理员创建接口后通过核心业务后端 (api-backend)保存到数据库中。用户调用某个接口时，在自己的项目中引入客户端 SDK (api-client-sdk) 并通过一行代码发起调用，请求会首先发送到 API 网关 (api.gateway)进行用户的鉴权和接口调用统计，然后将请求转发到实际的 API 接口 (api-interface)。</p>
<p><a target="_blank" rel="noopener" href="https://bcdh.yuque.com/staff-wpxfif/resource/qvvfumg8v8n6nuzm#kSvSF">https://bcdh.yuque.com/staff-wpxfif/resource/qvvfumg8v8n6nuzm#kSvSF</a></p>
<h2 id="API-签名认证算法"><a href="#API-签名认证算法" class="headerlink" title="API 签名认证算法"></a>API 签名认证算法</h2><p>API 签名认证算法是一种用于验证 API 请求的合法性和完整性的安全机制给接口使用 API 签名认证算法，可以增强 API 的安全性，防止未经授权的用户访问、防止恶意用户篡改请求数据。实现步骤如下：</p>
<ol>
<li><p>生成密钥对: 给每个用户生成唯一的密钥对 (accessKey 和secretKey)，并保存到数据库中，仅用户本人可查看自己的密钥对</p>
</li>
<li><p>请求方生成签名: 请求方 (客户端) 使用 secretKey 对请求参数和数据进行签名，签名的内容包括请求参数、时间戳、随机数等，签名加密算法此处选择 MD5。</p>
</li>
<li><p>请求方发送请求:请求方将请求参数、签名、用户标识一起发送给 API 提供者，通常会把签名等元信息放到请求头参数中传递，注意千万不要传递 secretKey。</p>
</li>
<li><p>API 提供者验证签名: 在 API 网关中，通过请求头获取到用户标识，根据标识到数据库中查找该用户对应的 accessKey 和 secretKey，并使用相同的签名算法生成签名，和请求中的签名进行比对，如果签名一致则 API 提供者可以信任请求方，可以进行后续操作。</p>
</li>
</ol>
<h2 id="为什么使用RPC调用-有了解过其他的方式吗-如何使用？"><a href="#为什么使用RPC调用-有了解过其他的方式吗-如何使用？" class="headerlink" title="为什么使用RPC调用? 有了解过其他的方式吗?如何使用？"></a>为什么使用RPC调用? 有了解过其他的方式吗?如何使用？</h2><p><img src="https://qianzeshu.oss-cn-hangzhou.aliyuncs.com/img/image-20231108125721220.png" alt="image-20231108125721220"></p>
<p>因为我的项目是微服务架构的，如果要实现服务之间的交互，要借助远程调用来实现</p>
<p>因为如果在网关引入数据库的操作的话，不仅会增加项目体积，以及违背了设计原则的单一职责原则，所以我考虑通过服务间调用的方式，我了解过有两种方式，第一种是Open feign，原理是构造了一个HTTP请求，并会添加很多的请求头，body是使用json字符串传输，所以调用效率会比较低，更加适合外部服务间的调用。然后我了解到RPC是可以基于TCP协议，避免了无用的请求头，以及可以通过将数据序列化为二进制流的形式传输，效率更加高效，更加安全，所以更适用于我这个场景。最终我选择了Dubbo RPC框架来实现这个功能。</p>
<p>在正式运用 Dubbo 到项目前，我先阅读了 Dubbo 的官方文档，按照快速启动文档跑通了基础的 RPC 调用Demo，明确了注册中心、Maven 包等各依赖的版本号.先在本地启动 Nacos 注册中心，然后在服务提供者和服务调用者项目引入 Dubbo 依赖(尽量引入相同的依赖和配置)、编写 Nacos 的连接配置、并且在项目启动类通过 @EnableDubbo 注解开启 Dubbo 支持编写服务提供者和服务调用客户端类，分别加上 @DubboService 和 @DubboReference 注解.优先启动服务提供者项目，在 Nacos 控制台观察到服务注册信息，再启动服务调用者项目。</p>
<h2 id="接口调用统计及排行的实现（跳表实现）"><a href="#接口调用统计及排行的实现（跳表实现）" class="headerlink" title="接口调用统计及排行的实现（跳表实现）"></a>接口调用统计及排行的实现（跳表实现）</h2><p>通过Mysl统计，每次调用结束后，网关都会发起一个rpc请求，调用次数+1。</p>
<p>注: 这里我会抛出一个设计缺陷，在实际测试过程中，通过 <code>jmeter</code> 压测工具，会出现调用次数不准的情况，原因是因为没有在业务层面加锁，导致数据库出现并发写的问题。并且并发量大的话，对数据库造成很大的压力。引导面试官问出，那你有什么更好的解决方案吗?<br>答: 如果在业务层面加一个写锁的话，会影响业务的执行效率，所以我想使用 <code>Redis</code> 去解决，<code>Redis</code> 有一个数据结构 <code>Zset</code> 支持排序，<code>score</code> 可以用来存储调用次数，并目 <code>Redis</code> 是单线程，可以解决并发问题。</p>
<p>注: 这里被追问过 <code>Zset</code> 的底层实现，以及如何将这些数据进行持久化保存，防止 <code>Redis</code> 宕机导致数据丢失，可以从AOF，RDB展开来讲，或者在后台开启一个定时任务，定时将这些数据进行落库</p>
<p>Redis 的有序集合（ZSet）底层实现主要基于跳跃表（Skip List）和哈希表（Hash Table）两种数据结构的组合。下面将详细介绍 Redis 有序集合的底层实现方式。</p>
<ol>
<li><p><strong>跳跃表（Skip List）：</strong> 跳跃表是一种有序链表的变种，它通过在链表中添加多级索引节点来加速查找操作。每个索引节点包含一个指针，指向链表中的下一个节点，以及一个指针，指向下一级索引节点。通过这种方式，跳跃表可以在平均情况下实现对数时间复杂度的查找、插入和删除操作。</p>
<p>在 Redis 的有序集合中，每个成员都对应一个跳跃表节点，节点按照成员的分值进行排序。同时，每个节点还会保存一个指针，指向哈希表中对应的键对象。这样可以通过跳跃表快速定位到成员，并通过哈希表获取对应的值。</p>
</li>
<li><p><strong>哈希表（Hash Table）：</strong> 哈希表是 Redis 中常用的数据结构，用于实现键值对的存储和查找。在有序集合中，哈希表主要用于存储成员和分值之间的映射关系。每个成员对应一个键对象，该对象中保存了成员的值和分值。通过哈希表，可以快速根据成员查找到对应的分值。</p>
<p>哈希表使用了数组和链表结合的方式来解决哈希冲突，具有常数时间复杂度的查找、插入和删除操作。在有序集合中，哈希表通过成员作为键，保存了成员的值和分值等相关信息。</p>
</li>
<li><p><strong>跳跃表和哈希表的组合：</strong> Redis 的有序集合底层将跳跃表和哈希表进行了组合，以实现高效的有序集合操作。跳跃表提供了快速的范围查找和排序功能，而哈希表则提供了快速的成员定位和值获取功能。</p>
<p>在有序集合中，通过维护跳跃表和哈希表之间的一致性，可以实现对有序集合的插入、删除、更新和范围操作等。通过跳跃表的索引结构，可以高效地进行范围查询，并且保持了有序集合的顺序性。同时，通过哈希表，可以快速定位到成员，并获取对应的值和分值。</p>
</li>
</ol>
<p>接口调用 <code>qps = 300</code></p>
<h2 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h2><p><a target="_blank" rel="noopener" href="https://bcdh.yuque.com/staff-wpxfif/resource/qvvfumg8v8n6nuzm">https://bcdh.yuque.com/staff-wpxfif/resource/qvvfumg8v8n6nuzm</a></p>
<p><a target="_blank" rel="noopener" href="https://bcdh.yuque.com/staff-wpxfif/resource/sntu12#vRzUI">https://bcdh.yuque.com/staff-wpxfif/resource/sntu12#vRzUI</a></p>
<p>知识：<a target="_blank" rel="noopener" href="https://bcdh.yuque.com/staff-wpxfif/resource/mp0lgqaent6qfsny#Z08q1">https://bcdh.yuque.com/staff-wpxfif/resource/mp0lgqaent6qfsny#Z08q1</a></p>
<p>作为 API 网关，集中接受客户端的请求，并执行统一的安全认证、请求转发、流量控制、请求日志公共业务等操作。</p>
<p>我这个平台的关键点就在于提供接口服务，要保证接口的可用性和稳定性，所以将接口服务独立部署在另一台机器上，隐藏真实的接口地址及端口，调用接口服务的请求都必须经过网关流量染色之后…(这里细节太多，比如rpc调用获取用户sk，重新生成签名认证等等)之后，将请求转发到真实的接口地址，防止接口被恶意调用、盗刷。</p>
<ol>
<li><p>路由</p>
</li>
<li><p>负载均衡</p>
</li>
<li><p>统一鉴权</p>
</li>
<li><p>跨域</p>
</li>
<li><p>统一业务处理 (缓存)</p>
</li>
<li><p>访问控制</p>
</li>
<li><p>发布控制</p>
</li>
<li><p>流量染色</p>
</li>
<li><p>接口保护</p>
<ul>
<li>限制请求</li>
<li>信息脱敏</li>
<li>降级 (熔断)</li>
<li>限流: 学习令牌桶算法、学习漏桶算法，学习一下 RedisLimitHandler</li>
<li>超时时间</li>
</ul>
</li>
<li><p>统一日志</p>
</li>
<li><p>统一文档</p>
</li>
</ol>
<p><strong>梳理网关业务逻辑</strong></p>
<p>以下操作可以复用:</p>
<ol>
<li><p>实际情况应该是去数据库中查是否已分配给用户秘钥 (ak、sk是否合法)</p>
<ul>
<li><p>先根据 accessKey 判断用户是否存在，查到 secretKey</p>
</li>
<li><p>对比 secretKey 和用户传的加密后的 secretKey 是否一致</p>
</li>
</ul>
</li>
<li><p>从数据库中查询模拟接口是否存在，以及请求方法是否匹配 (还可以校验请求参数)</p>
</li>
<li><p>调用成功，接口调用次数 + 1 invokeCount</p>
</li>
</ol>
<p>步骤:</p>
<ol>
<li><p>新建干净的 maven 项目，只保留必要的公共依赖</p>
</li>
<li><p>抽取 service 和实体类</p>
</li>
<li><p>install 本地 maven 包</p>
</li>
<li><p>让服务提供者引入 common 包，测试是否正常运行</p>
</li>
<li><p>让服务消费者引入 common 包</p>
</li>
</ol>
<h2 id="用户如何使用你开发的客户端-SDK"><a href="#用户如何使用你开发的客户端-SDK" class="headerlink" title="用户如何使用你开发的客户端 SDK"></a>用户如何使用你开发的客户端 SDK</h2><p>用户只需要在我的网站中下载sdk对应的jar包，引入到自己的项目中，填写自己的ak,sk，即可实现一行代码调用相应的接口</p>
<h2 id="如何基于-Spring-Boot-Starter-开发了客户端-SDK-的，讲述一下实现过程"><a href="#如何基于-Spring-Boot-Starter-开发了客户端-SDK-的，讲述一下实现过程" class="headerlink" title="如何基于 Spring Boot Starter 开发了客户端 SDK 的，讲述一下实现过程?"></a>如何基于 Spring Boot Starter 开发了客户端 SDK 的，讲述一下实现过程?</h2><p>A.引入spring-boot-configuration-processor依赖</p>
<p>B.绑定application.properties/yml配置文件</p>
<p>C.在META-IFNO下填写启动时需要加载的sdk对应的类全路径</p>
<p>D.安装自己实现的sdk到本地仓库中</p>
<h2 id="路由转发、访问控制、流量染色概念解释"><a href="#路由转发、访问控制、流量染色概念解释" class="headerlink" title="路由转发、访问控制、流量染色概念解释"></a>路由转发、访问控制、流量染色概念解释</h2><ol>
<li>路由转发：路由转发是指根据特定的路由规则将数据包从源地址转发到目标地址的过程。在计算机网络中，路由器是负责实现路由转发功能的设备。路由器根据网络中的路由表，判断数据包的最佳路径，并将数据包转发到正确的目标地址。路由转发是实现网络通信的核心机制，它使得数据包能够在网络中正确地传递和到达目的地。</li>
<li>访问控制：访问控制是指对系统、网络或资源进行限制和管理，以确保只有授权的用户或设备能够访问和使用它们。访问控制的目的是保护系统免受未经授权的访问、数据泄露、恶意操作等威胁。常见的访问控制机制包括身份验证（如用户名和密码）、访问权限（如角色或权限级别）和访问策略（如访问控制列表或防火墙规则）。通过访问控制，系统管理员可以限制用户的访问范围和操作权限，以确保系统的安全性和完整性。</li>
<li>流量染色：流量染色是一种网络管理技术，用于标记或识别特定类型的网络流量。通常，流量染色通过在数据包的头部或有效载荷中添加特定的标记、标签或元数据来实现。流量染色可以用于不同的目的，例如：<ul>
<li>优先级和服务质量（Quality of Service，QoS）管理：通过为不同类型的流量添加不同的优先级标记，网络设备可以根据优先级对流量进行调度和处理，以实现更好的服务质量。</li>
<li>安全性和策略控制：通过为流量添加特定的安全标记，网络设备可以根据标记对流量进行安全策略的检查和过滤，以保护网络免受恶意流量的攻击。</li>
<li>流量分析和监控：通过对流量添加特定的标签或元数据，网络设备或监控系统可以识别和跟踪特定类型的流量，以进行流量分析、性能监控或故障排除。</li>
</ul>
</li>
</ol>
<p>流量染色是指根据请求的属性对请求进行分类和标记，从而进行特定的处理<br>3 个关键概念:</p>
<p>1)请求分类:在请求层面的流量染色中，将请求分为不同的类别或组，通常基于请求的特性、内容、来源、用户身份等因素来进行分类</p>
<p>2)请求标记:每个请求被标记为属于特定的类别或组，这个标记可以是请求头中的特定字段、请求参数、或其他识别请求的方式。</p>
<p>3)处理策略:为每个请求类别定义特定的处理策略，包括资源分配、访问控制、限流、缓存策略、安全性等.</p>
<p>在本项目中，所有的外部请求都要先经过 Gateway 网关，由网关给请求加上特定的请求头参数(比如 Source =MyAPI)，便于让下游的 API 服务确定请求来源及合法性。</p>
<p>流量染色（Traffic Shaping）是一种网络管理技术，用于控制网络流量的传输速率、优先级或者其他属性。它通常被应用于网络设备（如路由器、防火墙等）上，以便更好地管理网络资源并提供良好的用户体验。以下是一些流量染色在项目中的应用场景：</p>
<ol>
<li><strong>服务质量保障</strong>：在实时音视频通信或在线游戏等对延迟敏感的应用中，可以通过流量染色来优先处理这类流量，以确保低延迟和高可靠性的传输。</li>
<li><strong>带宽控制</strong>：在企业网络或数据中心中，可以使用流量染色来限制特定应用或用户组的带宽使用，以确保网络资源能够公平分配和有效利用。</li>
<li><strong>流量分类与管理</strong>：通过对流量进行染色，可以根据应用类型、来源、目的地等特征对流量进行分类和管理，从而实现针对性的流量控制和优化。</li>
<li><strong>网络安全防护</strong>：流量染色也可以用于网络安全领域，通过标记流量并应用不同的安全策略，来识别和阻止恶意流量或攻击流量的传输。</li>
<li><strong>业务优化</strong>：染色技术还可以用于优化特定业务的网络传输，例如对于文件传输、数据库查询等不太紧急但需要稳定传输的业务，可以降低其传输优先级，以便给予对实时性要求更高的业务更多的带宽和资源。</li>
</ol>
<p>在项目中，流量染色可以根据具体需求和场景进行灵活应用。通过合理的流量染色策略，可以提升网络性能、改善用户体验、增强网络安全，并且更好地满足不同业务需求。</p>
<h2 id="API项目的背景-初衷-是什么"><a href="#API项目的背景-初衷-是什么" class="headerlink" title="API项目的背景(初衷)是什么?"></a>API项目的背景(初衷)是什么?</h2><p>我的初衷是尽可能地帮助和服务更多的用户和开发者，让他们更加方便快捷地获取他们想要的信息和功能。接口开放平台它可以帮助开发者快速接入一些常用的服务，从而提高他们的开发效率，比如天气服务、随机头像和心灵鸡汤等服务，它们是一些应用或者小程序中常见的功能，所以提供这些接口可以帮助开发者更加方便地实现这些功能。这些接口也可以让用户在使用应用时获得更加全面的功能和服务，从而提高他们的用户体验。所以我认为接口开放平台是一个有意义的项目，可以为用户和开发者带来更多的便利和价值。</p>

                                    
                            </div>
                            <hr />

                            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">ShiQuLiZhi</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://www.qqzzss.top/2023/10/27/development/ba-gu-wen-zheng-li/">https://www.qqzzss.top/2023/10/27/development/ba-gu-wen-zheng-li/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特别声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">ShiQuLiZhi</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



                                <div class="tag_share" style="display: block;">
                                    <div class="post-meta__tag-list" style="display: inline-block;">
                                        
                                            <div class="article-tag">
                                                
                                                    <a href="/tags/Web%E6%8A%80%E6%9C%AF/">
                                                        <span class="chip bg-color">
                                                            Web技术
                                                        </span>
                                                    </a>
                                                    
                                            </div>
                                            
                                    </div>
                                    <div class="post_share"
                                        style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                                        <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                                    </div>
                                </div>
                                
                        </div>
    </div>

    

                

                            

                                        

                                                    
                                                        <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }

    #vcomments textarea {
        box-sizing: border-box;
        background: url("/medias/comment_bg.png") 100% 100% no-repeat;
    }

    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #4cbf30;
        font-weight: 500;
        text-decoration: none;
    }

    #vcomments img {
        max-width: 100%;
        height: auto;
        cursor: pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table,
    th,
    td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table,
    th,
    td {
        border: 0;
    }

    table tr:nth-child(2n),
    thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked),
    [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table,
    th,
    td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n),
    thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked),
    [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div class="comment_headling"
        style="font-size: 20px; font-weight: 700; position: relative; padding-left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="vcomments" class="card-content" style="display: grid">
    </div>
</div>

<script src="/libs/valine/av-min.js"></script>
<script src="https://unpkg.com/valine/dist/Valine.min.js"></script>
<script>
    new Valine({
        el: '#vcomments',
        appId: '8SzvSoQjCOrTadqpJ1LjqujD-9Nh9j0Va',
        appKey: 'iv4mV6VBG7twuE7yQgwpsYaq',
        notify: '' === 'true',
        verify: '' === 'true',
        visitor: '' === 'true',
        avatar: '/medias/moren.png',
        pageSize: '10',
        lang: 'zh-cn',
        placeholder: '快来评论区发表你的观点吧~ 听说昵称填写qq号可以显示qq头像和qq昵称哦!',
        enableQQ: true,
        boolean: true,
        emojiCDN: '//i0.hdslb.com/bfs/emote/',
        // 表情title和图片映射
        emojiMaps: {
            "tv_doge": "6ea59c827c414b4a2955fe79e0f6fd3dcd515e24.png",
            "tv_亲亲": "a8111ad55953ef5e3be3327ef94eb4a39d535d06.png",
            "tv_偷笑": "bb690d4107620f1c15cff29509db529a73aee261.png",
            "tv_再见": "180129b8ea851044ce71caf55cc8ce44bd4a4fc8.png",
            "tv_冷漠": "b9cbc755c2b3ee43be07ca13de84e5b699a3f101.png",
            "tv_发怒": "34ba3cd204d5b05fec70ce08fa9fa0dd612409ff.png",
            "tv_发财": "34db290afd2963723c6eb3c4560667db7253a21a.png",
            "tv_可爱": "9e55fd9b500ac4b96613539f1ce2f9499e314ed9.png",
            "tv_吐血": "09dd16a7aa59b77baa1155d47484409624470c77.png",
            "tv_呆": "fe1179ebaa191569b0d31cecafe7a2cd1c951c9d.png",
            "tv_呕吐": "9f996894a39e282ccf5e66856af49483f81870f3.png",
            "tv_困": "241ee304e44c0af029adceb294399391e4737ef2.png",
            "tv_坏笑": "1f0b87f731a671079842116e0991c91c2c88645a.png",
            "tv_大佬": "093c1e2c490161aca397afc45573c877cdead616.png",
            "tv_大哭": "23269aeb35f99daee28dda129676f6e9ea87934f.png",
            "tv_委屈": "d04dba7b5465779e9755d2ab6f0a897b9b33bb77.png",
            "tv_害羞": "a37683fb5642fa3ddfc7f4e5525fd13e42a2bdb1.png",
            "tv_尴尬": "7cfa62dafc59798a3d3fb262d421eeeff166cfa4.png",
            "tv_微笑": "70dc5c7b56f93eb61bddba11e28fb1d18fddcd4c.png",
            "tv_思考": "90cf159733e558137ed20aa04d09964436f618a1.png",
            "tv_惊吓": "0d15c7e2ee58e935adc6a7193ee042388adc22af.png",
            "tv_打脸": "56ab10b624063e966bfcb76ea5dc4794d87dfd47.png",
            "tv_抓狂": "fe31c08edad661d63762b04e17b8d5ae3c71a757.png",
            "tv_抠鼻": "c666f55e88d471e51bbd9fab9bb308110824a6eb.png",
            "tv_斜眼笑": "911f987aa8bc1bee12d52aafe62bc41ef4474e6c.png",
            "tv_无奈": "ea8ed89ee9878f2fece2dda0ea8a5dbfe21b5751.png",
            "tv_晕": "5443c22b4d07fb1907ccc610c8e6db254f2461b7.png",
            "tv_流汗": "cead1c351ab8d79e9f369605beb90148db0fbed3.png",
            "tv_流泪": "7e71cde7858f0cd50d74b0264aa26db612a8a167.png",
            "tv_流鼻血": "c32d39db2737f89b904ca32700d140a9241b0767.png",
            "tv_点赞": "f85c354995bd99e28fc76c869bfe42ba6438eff4.png",
            "tv_生气": "26702dcafdab5e8225b43ffd23c94ac1ff932654.png",
            "tv_生病": "8b0ec90e6b86771092a498c54f09fc94621c1900.png",
            "tv_疑问": "0793d949b18d7be716078349c202c15ff166f314.png",
            "tv_白眼": "c1d59f439e379ee50eef488bcb5e5378e5044ea4.png",
            "tv_皱眉": "72ccad6679fea0d14cce648b4d818e09b8ffea2d.png",
            "tv_目瞪口呆": "0b8cb81a68de5d5365212c99375e7ace3e7891b7.png",
            "tv_睡着": "8b196675b53af58264f383c50ad0945048290b33.png",
            "tv_笑哭": "1abc628f6d4f4caf9d0e7800878f4697abbc8273.png",
            "tv_腼腆": "89712c0d4af73e67f89e35cbc518420380a7f6f4.png",
            "tv_色": "61822c7e9aae5da76475e7892534545336b23a6f.png",
            "tv_调侃": "4bc022533ef31544ca0d72c12c808cf4a1cce3e3.png",
            "tv_调皮": "b9c41de8e82dd7a8515ae5e3cb63e898bf245186.png",
            "tv_鄙视": "6e72339f346a692a495b123174b49e4e8e781303.png",
            "tv_闭嘴": "c9e990da7f6e93975e25fd8b70e2e290aa4086ef.png",
            "tv_难过": "87f46748d3f142ebc6586ff58860d0e2fc8263ba.png",
            "tv_馋": "fc7e829b845c43c623c8b490ee3602b7f0e76a31.png",
            "tv_鬼脸": "0ffbbddf8a94d124ca2f54b360bbc04feb6bbfea.png",
            "tv_黑人问号": "45821a01f51bc867da9edbaa2e070410819a95b2.png",
            "tv_鼓掌": "1d21793f96ef4e6f48b23e53e3b9e42da833a0f6.png"
        },
        requiredFields: ['nick'], //设置必填项
    });
</script>
                                                            

                                                                

                                                                            

                                                                                        

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2023/11/05/paperreading/paper02-hardlog/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/13.jpg" class="responsive-img" alt="HARDLOG_Practical Tamper-Proof System Auditing Using a Novel Audit Device">
                        
                        <span class="card-title">HARDLOG_Practical Tamper-Proof System Auditing Using a Novel Audit Device</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2023-11-05
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/" class="post-category">
                                    论文阅读
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/">
                        <span class="chip bg-color">信息安全</span>
                    </a>
                    
                    <a href="/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/">
                        <span class="chip bg-color">论文阅读</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2023/10/25/algorithmlearning/suan-fa-shua-ti-leetcode-shua-ti-ji-lu/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/5.jpg" class="responsive-img" alt="LeetCode刷题记录">
                        
                        <span class="card-title">LeetCode刷题记录</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-10-25
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/" class="post-category">
                                    算法学习
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E7%AE%97%E6%B3%95/">
                        <span class="chip bg-color">算法</span>
                    </a>
                    
                    <a href="/tags/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">
                        <span class="chip bg-color">程序设计</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


    <script>
        $('#articleContent').on('copy', function (e) {
            // IE8 or earlier browser is 'undefined'
            if (typeof window.getSelection === 'undefined') return;

            var selection = window.getSelection();
            // if the selection is short let's not annoy our users.
            if (('' + selection).length < Number.parseInt('150')) {
                return;
            }

            // create a div outside of the visible area and fill it with the selected text.
            var bodyElement = document.getElementsByTagName('body')[0];
            var newdiv = document.createElement('div');
            newdiv.style.position = 'absolute';
            newdiv.style.left = '-99999px';
            bodyElement.appendChild(newdiv);
            newdiv.appendChild(selection.getRangeAt(0).cloneContents());

            // we need a <pre> tag workaround.
            // otherwise the text inside "pre" loses all the line breaks!
            if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'CODE') {
                newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
            }

            var url = document.location.href;
            newdiv.innerHTML += '<br />'
                + '来源: ShiQuLiZhi BLOG<br />'
                + '文章作者: ShiQuLiZhi<br />'
                + '文章链接: <a href="' + url + '">' + url + '</a><br />'
                + '本文著作权归作者所有，任何形式的转载均请注明出处。';

            selection.selectAllChildren(newdiv);
            window.setTimeout(function () { bodyElement.removeChild(newdiv); }, 200);
        });
    </script>
    

        <!-- 代码块功能依赖 -->
        <script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

        <!-- 代码语言 -->
        
            <script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>
            

                <!-- 代码块复制 -->
                
                    <script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>
                    

                        <!-- 代码块收缩 -->
                        
                            <script type="text/javascript"
                                src="/libs/codeBlock/codeShrink.js"></script>
                            

                                <!-- 代码块折行 -->
                                
    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('1'),
            headingSelector: 'h1, h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




                            <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    
    <div class="container row center-align" style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2022-2023</span>
            
            <span id="year">2022</span>
            <a href="/about" target="_blank">ShiQuLiZhi</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">479.2k</span>&nbsp;字
            
            
            
            
            
            <br>
            
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2022";
                    var startMonth = "8";
                    var startDate = "13";
                    var startHour = "0";
                    var startMinute = "0";
                    var startSecond = "0";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link ">
    <a href="https://github.com/sxhthreo" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub"
        data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>
    

        
            <a href="mailto:951161604@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我"
                data-position="top" data-delay="50">
                <i class="fas fa-envelope-open"></i>
            </a>
            

                

                        

                                
                                    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=951161604"
                                        class="tooltipped" target="_blank"
                                        data-tooltip="QQ联系我: 951161604" data-position="top"
                                        data-delay="50">
                                        <i class="fab fa-qq"></i>
                                    </a>
                                    

                                        

                                                
                                                    <a href="https://www.zhihu.com/people/shui-he-qing-chi-zi-14" class="tooltipped"
                                                        target="_blank"
                                                        data-tooltip="关注我的知乎: https://www.zhihu.com/people/shui-he-qing-chi-zi-14"
                                                        data-position="top" data-delay="50">
                                                        <i class="fab fa-zhihu1">知</i>
                                                    </a>
                                                    

                                                        

                                                                
                                                                    <a href="https://blog.csdn.net/sxH3O?type=blog"
                                                                        class="tooltipped" target="_blank"
                                                                        data-tooltip="关注我的CSDN: https://blog.csdn.net/sxH3O?type=blog"
                                                                        data-position="top" data-delay="50">
                                                                        <i class="fab fa-csdn">C</i>
                                                                    </a>
                                                                    </div>
    </div>
</footer>

<div class="progress-bar"></div>


                                <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

                                    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


                                        <script
                                            src="/libs/materialize/materialize.min.js"></script>
                                        <script
                                            src="/libs/masonry/masonry.pkgd.min.js"></script>
                                        <script
                                            src="/libs/aos/aos.js"></script>
                                        <script
                                            src="/libs/scrollprogress/scrollProgress.min.js"></script>
                                        <script
                                            src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
                                        <script
                                            src="/js/matery.js"></script>

                                        <!-- Baidu Analytics -->

                                            <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

                                                
                                                    <script
                                                        src="/libs/others/clicklove.js"
                                                        async="async"></script>
                                                    
                                                        

                                                                

                                                                        

                                                                                
                                                                                        
                                                                                            <script
                                                                                                type="text/javascript"
                                                                                                color="0,0,255"
                                                                                                pointColor="0,0,255"
                                                                                                opacity='0.7'
                                                                                                zIndex="-1"
                                                                                                count="99"
                                                                                                src="/libs/background/canvas-nest.js"></script>
                                                                                            

                                                                                                

                                                                                                            
                                                                                                                <script
                                                                                                                    type="text/javascript"
                                                                                                                    src="/libs/background/ribbon-dynamic.js"
                                                                                                                    async="async"></script>
                                                                                                                

                                                                                                                    
                                                                                                                        <script
                                                                                                                            src="/libs/instantpage/instantpage.js"
                                                                                                                            type="module"></script>
                                                                                                                        




                <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>

</html>